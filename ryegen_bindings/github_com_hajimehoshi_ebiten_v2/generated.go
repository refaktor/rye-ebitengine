// Code generated by ryegen. DO NOT EDIT.

// You can add custom binding code to builtins_custom.go!

//go:build !b_no_ebiten

package github_com_hajimehoshi_ebiten_v2

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/audio"
	"github.com/hajimehoshi/ebiten/v2/audio/mp3"
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis"
	"github.com/hajimehoshi/ebiten/v2/audio/wav"
	"github.com/hajimehoshi/ebiten/v2/colorm"
	"github.com/hajimehoshi/ebiten/v2/ebitenutil"
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048"
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/keyboard/keyboard"
	resources_audio "github.com/hajimehoshi/ebiten/v2/examples/resources/audio"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/fonts"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images"
	images_audio "github.com/hajimehoshi/ebiten/v2/examples/resources/images/audio"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/blend"
	images_blocks "github.com/hajimehoshi/ebiten/v2/examples/resources/images/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/flappy"
	images_keyboard "github.com/hajimehoshi/ebiten/v2/examples/resources/images/keyboard"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/mascot"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/platformer"
	images_shader "github.com/hajimehoshi/ebiten/v2/examples/resources/images/shader"
	"github.com/hajimehoshi/ebiten/v2/exp/textinput"
	"github.com/hajimehoshi/ebiten/v2/inpututil"
	"github.com/hajimehoshi/ebiten/v2/mobile"
	ebiten_text "github.com/hajimehoshi/ebiten/v2/text"
	"github.com/hajimehoshi/ebiten/v2/text/v2"
	"github.com/hajimehoshi/ebiten/v2/vector"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"golang.org/x/image/font"
	"golang.org/x/text/language"
	"image"
	"image/color"
	"image/draw"
	"image/gif"
	"image/jpeg"
	"image/png"
	"io"
	"io/fs"
	"reflect"
	"strconv"
	"time"
	"unicode"
)

var Builtins map[string]*env.Builtin

func init() {
	Builtins = make(map[string]*env.Builtin, len(builtinsGenerated)+len(builtinsCustom))
	for k, v := range builtinsGenerated {
		Builtins[k] = v
	}
	for k, v := range builtinsCustom {
		Builtins[k] = v
	}
}

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

func objectDebugString(idx *env.Idxs, v any) string {
	if v, ok := v.(env.Object); ok {
		return v.Inspect(*idx)
	} else {
		return "[Non-object of type " + reflect.TypeOf(v).String() + "]"
	}
}

func ifaceToNative(idx *env.Idxs, v any, ifaceName string) env.Native {
	rV := reflect.ValueOf(v)
	var typRyeName string
	var ok bool
	if rV.Type() != nil {
		var typPfx string
		if rV.Type().Kind() == reflect.Struct {
			newRV := reflect.New(rV.Type())
			newRV.Elem().Set(rV)
			rV = newRV
		}
		typ := rV.Type()
		if typ.Kind() == reflect.Pointer {
			typ = rV.Type().Elem()
			typPfx = "*"
		}
		typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
	}
	if ok {
		return *env.NewNative(idx, rV.Interface(), typRyeName)
	} else {
		return *env.NewNative(idx, rV.Interface(), ifaceName)
	}
}

var ryeStructNameLookup = map[string]string{
	"bytes.*Buffer": "Go(*bytes.Buffer)",
	"bytes.*Reader": "Go(*bytes.Reader)",
	"github.com/hajimehoshi/ebiten/v2.*Blend":                               "Go(*ebiten.Blend)",
	"github.com/hajimehoshi/ebiten/v2.*ColorM":                              "Go(*ebiten.ColorM)",
	"github.com/hajimehoshi/ebiten/v2.*ColorScale":                          "Go(*ebiten.ColorScale)",
	"github.com/hajimehoshi/ebiten/v2.*DebugInfo":                           "Go(*ebiten.DebugInfo)",
	"github.com/hajimehoshi/ebiten/v2.*DrawImageOptions":                    "Go(*ebiten.DrawImageOptions)",
	"github.com/hajimehoshi/ebiten/v2.*DrawTrianglesOptions":                "Go(*ebiten.DrawTrianglesOptions)",
	"github.com/hajimehoshi/ebiten/v2.*GeoM":                                "Go(*ebiten.GeoM)",
	"github.com/hajimehoshi/ebiten/v2.*Image":                               "Go(*ebiten.Image)",
	"github.com/hajimehoshi/ebiten/v2.*NewImageFromImageOptions":            "Go(*ebiten.NewImageFromImageOptions)",
	"github.com/hajimehoshi/ebiten/v2.*NewImageOptions":                     "Go(*ebiten.NewImageOptions)",
	"github.com/hajimehoshi/ebiten/v2.*RunGameOptions":                      "Go(*ebiten.RunGameOptions)",
	"github.com/hajimehoshi/ebiten/v2.*Shader":                              "Go(*ebiten.Shader)",
	"github.com/hajimehoshi/ebiten/v2.*Vertex":                              "Go(*ebiten.Vertex)",
	"github.com/hajimehoshi/ebiten/v2.*VibrateGamepadOptions":               "Go(*ebiten.VibrateGamepadOptions)",
	"github.com/hajimehoshi/ebiten/v2.*VibrateOptions":                      "Go(*ebiten.VibrateOptions)",
	"github.com/hajimehoshi/ebiten/v2/audio.*Context":                       "Go(*audio.Context)",
	"github.com/hajimehoshi/ebiten/v2/audio.*InfiniteLoop":                  "Go(*audio.InfiniteLoop)",
	"github.com/hajimehoshi/ebiten/v2/audio.*Player":                        "Go(*audio.Player)",
	"github.com/hajimehoshi/ebiten/v2/audio/mp3.*Stream":                    "Go(*mp3.Stream)",
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis.*Stream":                 "Go(*vorbis.Stream)",
	"github.com/hajimehoshi/ebiten/v2/audio/wav.*Stream":                    "Go(*wav.Stream)",
	"github.com/hajimehoshi/ebiten/v2/colorm.*ColorM":                       "Go(*colorm.ColorM)",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawImageOptions":             "Go(*colorm.DrawImageOptions)",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawTrianglesOptions":         "Go(*colorm.DrawTrianglesOptions)",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Board":            "Go(*twenty48.Board)",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Game":             "Go(*twenty48.Game)",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Input":            "Go(*twenty48.Input)",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Tile":             "Go(*twenty48.Tile)",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*TileData":         "Go(*twenty48.TileData)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Field":        "Go(*blocks.Field)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Game":         "Go(*blocks.Game)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameScene":    "Go(*blocks.GameScene)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameState":    "Go(*blocks.GameState)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GamepadScene": "Go(*blocks.GamepadScene)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Input":        "Go(*blocks.Input)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Piece":        "Go(*blocks.Piece)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*SceneManager": "Go(*blocks.SceneManager)",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*TitleScene":   "Go(*blocks.TitleScene)",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.*Field":                 "Go(*textinput.Field)",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.*State":                 "Go(*textinput.State)",
	"github.com/hajimehoshi/ebiten/v2/text.*Glyph":                          "Go(*ebiten_text.Glyph)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*DrawOptions":                 "Go(*text.DrawOptions)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Glyph":                       "Go(*text.Glyph)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*GoTextFace":                  "Go(*text.GoTextFace)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*GoTextFaceSource":            "Go(*text.GoTextFaceSource)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*GoXFace":                     "Go(*text.GoXFace)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LayoutOptions":               "Go(*text.LayoutOptions)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LimitedFace":                 "Go(*text.LimitedFace)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metadata":                    "Go(*text.Metadata)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metrics":                     "Go(*text.Metrics)",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*MultiFace":                   "Go(*text.MultiFace)",
	"github.com/hajimehoshi/ebiten/v2/vector.*Path":                         "Go(*vector.Path)",
	"github.com/hajimehoshi/ebiten/v2/vector.*StrokeOptions":                "Go(*vector.StrokeOptions)",
	"image.*Alpha":         "Go(*image.Alpha)",
	"image.*Alpha16":       "Go(*image.Alpha16)",
	"image.*CMYK":          "Go(*image.CMYK)",
	"image.*Config":        "Go(*image.Config)",
	"image.*Gray":          "Go(*image.Gray)",
	"image.*Gray16":        "Go(*image.Gray16)",
	"image.*NRGBA":         "Go(*image.NRGBA)",
	"image.*NRGBA64":       "Go(*image.NRGBA64)",
	"image.*NYCbCrA":       "Go(*image.NYCbCrA)",
	"image.*Paletted":      "Go(*image.Paletted)",
	"image.*Point":         "Go(*image.Point)",
	"image.*RGBA":          "Go(*image.RGBA)",
	"image.*RGBA64":        "Go(*image.RGBA64)",
	"image.*Rectangle":     "Go(*image.Rectangle)",
	"image.*Uniform":       "Go(*image.Uniform)",
	"image.*YCbCr":         "Go(*image.YCbCr)",
	"image/color.*Alpha":   "Go(*color.Alpha)",
	"image/color.*Alpha16": "Go(*color.Alpha16)",
	"image/color.*CMYK":    "Go(*color.CMYK)",
	"image/color.*Gray":    "Go(*color.Gray)",
	"image/color.*Gray16":  "Go(*color.Gray16)",
	"image/color.*NRGBA":   "Go(*color.NRGBA)",
	"image/color.*NRGBA64": "Go(*color.NRGBA64)",
	"image/color.*NYCbCrA": "Go(*color.NYCbCrA)",
	"image/color.*RGBA":    "Go(*color.RGBA)",
	"image/color.*RGBA64":  "Go(*color.RGBA64)",
	"image/color.*YCbCr":   "Go(*color.YCbCr)",
	"image/gif.*GIF":       "Go(*gif.GIF)",
	"image/gif.*Options":   "Go(*gif.Options)",
	"image/jpeg.*Options":  "Go(*jpeg.Options)",
	"image/png.*Encoder":   "Go(*png.Encoder)",
	"io.*LimitedReader":    "Go(*io.LimitedReader)",
	"io.*PipeReader":       "Go(*io.PipeReader)",
	"io.*PipeWriter":       "Go(*io.PipeWriter)",
	"io.*SectionReader":    "Go(*io.SectionReader)",
	"io/fs.*PathError":     "Go(*fs.PathError)",
}

type iface_blocks_Scene struct {
	self      env.RyeCtx
	fn_Update func(self env.RyeCtx, arg0 *blocks.GameState) error
	fn_Draw   func(self env.RyeCtx, arg0 *ebiten.Image)
}

func (self *iface_blocks_Scene) Update(arg0 *blocks.GameState) error {
	return self.fn_Update(self.self, arg0)
}
func (self *iface_blocks_Scene) Draw(arg0 *ebiten.Image) {
	self.fn_Draw(self.self, arg0)
}

func ctxTo_blocks_Scene(ps *env.ProgramState, v env.RyeCtx) (blocks.Scene, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_blocks_Scene{
		self: v,
	}
	ctxObj0, ok := wordToObj["update"]
	if !ok {
		return nil, errors.New("context to blocks.Scene: expected context to have function Update")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to blocks.Scene: context fn Update: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Update = func(ctx env.RyeCtx, farg0 *blocks.GameState) error {
			var farg0Val env.Object
			farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*blocks.GameState)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to blocks.Scene: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to blocks.Scene: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to blocks.Scene: context fn Update: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["draw"]
	if !ok {
		return nil, errors.New("context to blocks.Scene: expected context to have function Draw")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to blocks.Scene: context fn Draw: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Draw = func(ctx env.RyeCtx, farg0 *ebiten.Image) {
			var farg0Val env.Object
			farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*ebiten.Image)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
		}
	default:
		return nil, errors.New("context to blocks.Scene: context fn Draw: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_color_Color struct {
	self    env.RyeCtx
	fn_RGBA func(self env.RyeCtx) (uint32, uint32, uint32, uint32)
}

func (self *iface_color_Color) RGBA() (uint32, uint32, uint32, uint32) {
	return self.fn_RGBA(self.self)
}

func ctxTo_color_Color(ps *env.ProgramState, v env.RyeCtx) (color.Color, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_color_Color{
		self: v,
	}
	ctxObj0, ok := wordToObj["rgba"]
	if !ok {
		return nil, errors.New("context to color.Color: expected context to have function RGBA")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to color.Color: context fn RGBA: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_RGBA = func(ctx env.RyeCtx) (uint32, uint32, uint32, uint32) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res0 uint32
			var res1 uint32
			var res2 uint32
			var res3 uint32
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if len(res.Series.S) != 4 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: "+"expected block with 4 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = uint32(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if vc, ok := res.Series.S[1].(env.Integer); ok {
				res1 = uint32(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[1]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if vc, ok := res.Series.S[2].(env.Integer); ok {
				res2 = uint32(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[2]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if vc, ok := res.Series.S[3].(env.Integer); ok {
				res3 = uint32(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[3]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			return res0, res1, res2, res3
		}
	default:
		return nil, errors.New("context to color.Color: context fn RGBA: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_color_Model struct {
	self       env.RyeCtx
	fn_Convert func(self env.RyeCtx, arg0 color.Color) color.Color
}

func (self *iface_color_Model) Convert(arg0 color.Color) color.Color {
	return self.fn_Convert(self.self, arg0)
}

func ctxTo_color_Model(ps *env.ProgramState, v env.RyeCtx) (color.Model, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_color_Model{
		self: v,
	}
	ctxObj0, ok := wordToObj["convert"]
	if !ok {
		return nil, errors.New("context to color.Model: expected context to have function Convert")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to color.Model: context fn Convert: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Convert = func(ctx env.RyeCtx, farg0 color.Color) color.Color {
			var farg0Val env.Object
			farg0Val = ifaceToNative(ps.Idx, farg0, "Go(color.Color)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to color.Model: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to color.Model: arg 0: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to color.Model: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Model: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to color.Model: context fn Convert: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_draw_Drawer struct {
	self    env.RyeCtx
	fn_Draw func(self env.RyeCtx, arg0 draw.Image, arg1 image.Rectangle, arg2 image.Image, arg3 image.Point)
}

func (self *iface_draw_Drawer) Draw(arg0 draw.Image, arg1 image.Rectangle, arg2 image.Image, arg3 image.Point) {
	self.fn_Draw(self.self, arg0, arg1, arg2, arg3)
}

func ctxTo_draw_Drawer(ps *env.ProgramState, v env.RyeCtx) (draw.Drawer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_Drawer{
		self: v,
	}
	ctxObj0, ok := wordToObj["draw"]
	if !ok {
		return nil, errors.New("context to draw.Drawer: expected context to have function Draw")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 4 {
			return nil, errors.New("context to draw.Drawer: context fn Draw: " + "expected 4 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Draw = func(ctx env.RyeCtx, farg0 draw.Image, farg1 image.Rectangle, farg2 image.Image, farg3 image.Point) {
			var farg0Val, farg1Val, farg2Val, farg3Val env.Object
			farg0Val = ifaceToNative(ps.Idx, farg0, "Go(draw.Image)")
			farg1Val = *env.NewNative(ps.Idx, &farg1, "Go(*image.Rectangle)")
			farg2Val = ifaceToNative(ps.Idx, farg2, "Go(image.Image)")
			farg3Val = *env.NewNative(ps.Idx, &farg3, "Go(*image.Point)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val, farg2Val, farg3Val)
		}
	default:
		return nil, errors.New("context to draw.Drawer: context fn Draw: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_draw_Image struct {
	self          env.RyeCtx
	fn_Set        func(self env.RyeCtx, arg0 int, arg1 int, arg2 color.Color)
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_draw_Image) Set(arg0 int, arg1 int, arg2 color.Color) {
	self.fn_Set(self.self, arg0, arg1, arg2)
}
func (self *iface_draw_Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_draw_Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_draw_Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_draw_Image(ps *env.ProgramState, v env.RyeCtx) (draw.Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["set"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function Set")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to draw.Image: context fn Set: " + "expected 3 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Set = func(ctx env.RyeCtx, farg0 int, farg1 int, farg2 color.Color) {
			var farg0Val, farg1Val, farg2Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			farg2Val = ifaceToNative(ps.Idx, farg2, "Go(color.Color)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val, farg2Val)
		}
	default:
		return nil, errors.New("context to draw.Image: context fn Set: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function ColorModel")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.Image: context fn ColorModel: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+"expected native of type color.Model, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Image: context fn ColorModel: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function Bounds")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.Image: context fn Bounds: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+"expected native of type *image.Rectangle, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Image: context fn Bounds: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj3, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function At")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.Image: context fn At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.Color {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Image: context fn At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_draw_Quantizer struct {
	self        env.RyeCtx
	fn_Quantize func(self env.RyeCtx, arg0 color.Palette, arg1 image.Image) color.Palette
}

func (self *iface_draw_Quantizer) Quantize(arg0 color.Palette, arg1 image.Image) color.Palette {
	return self.fn_Quantize(self.self, arg0, arg1)
}

func ctxTo_draw_Quantizer(ps *env.ProgramState, v env.RyeCtx) (draw.Quantizer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_Quantizer{
		self: v,
	}
	ctxObj0, ok := wordToObj["quantize"]
	if !ok {
		return nil, errors.New("context to draw.Quantizer: expected context to have function Quantize")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.Quantizer: context fn Quantize: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Quantize = func(ctx env.RyeCtx, farg0 color.Palette, farg1 image.Image) color.Palette {
			var farg0Val, farg1Val env.Object
			{
				items := make([]env.Object, len([]color.Color(farg0)))
				for i, it := range []color.Color(farg0) {
					items[i] = ifaceToNative(ps.Idx, it, "Go(color.Color)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			farg1Val = ifaceToNative(ps.Idx, farg1, "Go(image.Image)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.Palette
			{
				nat, natOk := ps.Res.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					res = natVal
				} else {
					var u []color.Color
					switch v := ps.Res.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"context to draw.Quantizer: arg 0: callback result: "+"block item: "+err.Error(),
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							case env.Native:
								if vc, ok := v.Value.(color.Color); ok {
									u[i] = vc
								} else {
									ps.FailureFlag = true
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"context to draw.Quantizer: arg 0: callback result: "+"block item: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"context to draw.Quantizer: arg 0: callback result: "+"block item: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"context to draw.Quantizer: arg 0: callback result: "+"block item: "+"expected native, but got "+objectDebugString(ps.Idx, v),
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"context to draw.Quantizer: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
						u = nil
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"context to draw.Quantizer: arg 0: callback result: "+"expected block or nil, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					res = color.Palette(u)
				}
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Quantizer: context fn Quantize: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_draw_RGBA64Image struct {
	self          env.RyeCtx
	fn_Set        func(self env.RyeCtx, arg0 int, arg1 int, arg2 color.Color)
	fn_SetRGBA64  func(self env.RyeCtx, arg0 int, arg1 int, arg2 color.RGBA64)
	fn_RGBA64At   func(self env.RyeCtx, arg0 int, arg1 int) color.RGBA64
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_draw_RGBA64Image) Set(arg0 int, arg1 int, arg2 color.Color) {
	self.fn_Set(self.self, arg0, arg1, arg2)
}
func (self *iface_draw_RGBA64Image) SetRGBA64(arg0 int, arg1 int, arg2 color.RGBA64) {
	self.fn_SetRGBA64(self.self, arg0, arg1, arg2)
}
func (self *iface_draw_RGBA64Image) RGBA64At(arg0 int, arg1 int) color.RGBA64 {
	return self.fn_RGBA64At(self.self, arg0, arg1)
}
func (self *iface_draw_RGBA64Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_draw_RGBA64Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_draw_RGBA64Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_draw_RGBA64Image(ps *env.ProgramState, v env.RyeCtx) (draw.RGBA64Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_RGBA64Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["set"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function Set")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to draw.RGBA64Image: context fn Set: " + "expected 3 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Set = func(ctx env.RyeCtx, farg0 int, farg1 int, farg2 color.Color) {
			var farg0Val, farg1Val, farg2Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			farg2Val = ifaceToNative(ps.Idx, farg2, "Go(color.Color)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val, farg2Val)
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn Set: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["set-rgba-64"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function SetRGBA64")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to draw.RGBA64Image: context fn SetRGBA64: " + "expected 3 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_SetRGBA64 = func(ctx env.RyeCtx, farg0 int, farg1 int, farg2 color.RGBA64) {
			var farg0Val, farg1Val, farg2Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			farg2Val = *env.NewNative(ps.Idx, &farg2, "Go(*color.RGBA64)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val, farg2Val)
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn SetRGBA64: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["rgba-64-at"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function RGBA64At")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.RGBA64Image: context fn RGBA64At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_RGBA64At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.RGBA64 {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.RGBA64
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+"expected native of type *color.RGBA64, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn RGBA64At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj3, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function ColorModel")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.RGBA64Image: context fn ColorModel: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+"expected native of type color.Model, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn ColorModel: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj4, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function Bounds")
	}
	switch fn := ctxObj4.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.RGBA64Image: context fn Bounds: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+"expected native of type *image.Rectangle, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn Bounds: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj5, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function At")
	}
	switch fn := ctxObj5.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.RGBA64Image: context fn At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.Color {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_ebiten_FinalScreenDrawer struct {
	self               env.RyeCtx
	fn_DrawFinalScreen func(self env.RyeCtx, arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM)
}

func (self *iface_ebiten_FinalScreenDrawer) DrawFinalScreen(arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM) {
	self.fn_DrawFinalScreen(self.self, arg0, arg1, arg2)
}

func ctxTo_ebiten_FinalScreenDrawer(ps *env.ProgramState, v env.RyeCtx) (ebiten.FinalScreenDrawer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebiten_FinalScreenDrawer{
		self: v,
	}
	ctxObj0, ok := wordToObj["draw-final-screen"]
	if !ok {
		return nil, errors.New("context to ebiten.FinalScreenDrawer: expected context to have function DrawFinalScreen")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to ebiten.FinalScreenDrawer: context fn DrawFinalScreen: " + "expected 3 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_DrawFinalScreen = func(ctx env.RyeCtx, farg0 ebiten.FinalScreen, farg1 *ebiten.Image, farg2 ebiten.GeoM) {
			var farg0Val, farg1Val, farg2Val env.Object
			farg0Val = ifaceToNative(ps.Idx, farg0, "Go(ebiten.FinalScreen)")
			farg1Val = *env.NewNative(ps.Idx, farg1, "Go(*ebiten.Image)")
			farg2Val = *env.NewNative(ps.Idx, &farg2, "Go(*ebiten.GeoM)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val, farg2Val)
		}
	default:
		return nil, errors.New("context to ebiten.FinalScreenDrawer: context fn DrawFinalScreen: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_ebiten_Game struct {
	self      env.RyeCtx
	fn_Update func(self env.RyeCtx) error
	fn_Draw   func(self env.RyeCtx, arg0 *ebiten.Image)
	fn_Layout func(self env.RyeCtx, arg0 int, arg1 int) (int, int)
}

func (self *iface_ebiten_Game) Update() error {
	return self.fn_Update(self.self)
}
func (self *iface_ebiten_Game) Draw(arg0 *ebiten.Image) {
	self.fn_Draw(self.self, arg0)
}
func (self *iface_ebiten_Game) Layout(arg0 int, arg1 int) (int, int) {
	return self.fn_Layout(self.self, arg0, arg1)
}

func ctxTo_ebiten_Game(ps *env.ProgramState, v env.RyeCtx) (ebiten.Game, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebiten_Game{
		self: v,
	}
	ctxObj0, ok := wordToObj["update"]
	if !ok {
		return nil, errors.New("context to ebiten.Game: expected context to have function Update")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to ebiten.Game: context fn Update: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Update = func(ctx env.RyeCtx) error {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to ebiten.Game: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to ebiten.Game: context fn Update: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["draw"]
	if !ok {
		return nil, errors.New("context to ebiten.Game: expected context to have function Draw")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to ebiten.Game: context fn Draw: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Draw = func(ctx env.RyeCtx, farg0 *ebiten.Image) {
			var farg0Val env.Object
			farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*ebiten.Image)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
		}
	default:
		return nil, errors.New("context to ebiten.Game: context fn Draw: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["layout"]
	if !ok {
		return nil, errors.New("context to ebiten.Game: expected context to have function Layout")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to ebiten.Game: context fn Layout: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Layout = func(ctx env.RyeCtx, farg0 int, farg1 int) (int, int) {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res0 int
			var res1 int
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[1].(env.Integer); ok {
				res1 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[1]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to ebiten.Game: context fn Layout: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_ebiten_LayoutFer struct {
	self       env.RyeCtx
	fn_LayoutF func(self env.RyeCtx, arg0 float64, arg1 float64) (float64, float64)
}

func (self *iface_ebiten_LayoutFer) LayoutF(arg0 float64, arg1 float64) (float64, float64) {
	return self.fn_LayoutF(self.self, arg0, arg1)
}

func ctxTo_ebiten_LayoutFer(ps *env.ProgramState, v env.RyeCtx) (ebiten.LayoutFer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebiten_LayoutFer{
		self: v,
	}
	ctxObj0, ok := wordToObj["layout-f"]
	if !ok {
		return nil, errors.New("context to ebiten.LayoutFer: expected context to have function LayoutF")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to ebiten.LayoutFer: context fn LayoutF: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_LayoutF = func(ctx env.RyeCtx, farg0 float64, farg1 float64) (float64, float64) {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewDecimal(float64(farg0))
			farg1Val = *env.NewDecimal(float64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res0 float64
			var res1 float64
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Decimal); ok {
				res0 = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: "+"expected decimal, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[1].(env.Decimal); ok {
				res1 = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: "+"expected decimal, but got "+objectDebugString(ps.Idx, res.Series.S[1]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to ebiten.LayoutFer: context fn LayoutF: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_ebitenutil_ReadSeekCloser struct {
	self     env.RyeCtx
	fn_Read  func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Seek  func(self env.RyeCtx, arg0 int64, arg1 int) (int64, error)
	fn_Close func(self env.RyeCtx) error
}

func (self *iface_ebitenutil_ReadSeekCloser) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *iface_ebitenutil_ReadSeekCloser) Seek(arg0 int64, arg1 int) (int64, error) {
	return self.fn_Seek(self.self, arg0, arg1)
}
func (self *iface_ebitenutil_ReadSeekCloser) Close() error {
	return self.fn_Close(self.self)
}

func ctxTo_ebitenutil_ReadSeekCloser(ps *env.ProgramState, v env.RyeCtx) (ebitenutil.ReadSeekCloser, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebitenutil_ReadSeekCloser{
		self: v,
	}
	ctxObj0, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to ebitenutil.ReadSeekCloser: expected context to have function Read")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to ebitenutil.ReadSeekCloser: context fn Read: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Read = func(ctx env.RyeCtx, farg0 []byte) (int, error) {
			var farg0Val env.Object
			{
				items := make([]env.Object, len(farg0))
				for i, it := range farg0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to ebitenutil.ReadSeekCloser: context fn Read: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["seek"]
	if !ok {
		return nil, errors.New("context to ebitenutil.ReadSeekCloser: expected context to have function Seek")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to ebitenutil.ReadSeekCloser: context fn Seek: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Seek = func(ctx env.RyeCtx, farg0 int64, farg1 int) (int64, error) {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res0 int64
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to ebitenutil.ReadSeekCloser: context fn Seek: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["close"]
	if !ok {
		return nil, errors.New("context to ebitenutil.ReadSeekCloser: expected context to have function Close")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to ebitenutil.ReadSeekCloser: context fn Close: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Close = func(ctx env.RyeCtx) error {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebitenutil.ReadSeekCloser: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to ebitenutil.ReadSeekCloser: context fn Close: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_fs_FS struct {
	self    env.RyeCtx
	fn_Open func(self env.RyeCtx, arg0 string) (fs.File, error)
}

func (self *iface_fs_FS) Open(arg0 string) (fs.File, error) {
	return self.fn_Open(self.self, arg0)
}

func ctxTo_fs_FS(ps *env.ProgramState, v env.RyeCtx) (fs.FS, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_fs_FS{
		self: v,
	}
	ctxObj0, ok := wordToObj["open"]
	if !ok {
		return nil, errors.New("context to fs.FS: expected context to have function Open")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to fs.FS: context fn Open: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Open = func(ctx env.RyeCtx, farg0 string) (fs.File, error) {
			var farg0Val env.Object
			farg0Val = *env.NewString(farg0)
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 fs.File
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[0].(type) {
			case env.RyeCtx:
				var err error
				res0, err = ctxTo_fs_File(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Native:
				if vc, ok := v.Value.(fs.File); ok {
					res0 = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: "+"expected native of type fs.File, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res0 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to fs.FS: context fn Open: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_fs_File struct {
	self     env.RyeCtx
	fn_Stat  func(self env.RyeCtx) (fs.FileInfo, error)
	fn_Read  func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Close func(self env.RyeCtx) error
}

func (self *iface_fs_File) Stat() (fs.FileInfo, error) {
	return self.fn_Stat(self.self)
}
func (self *iface_fs_File) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *iface_fs_File) Close() error {
	return self.fn_Close(self.self)
}

func ctxTo_fs_File(ps *env.ProgramState, v env.RyeCtx) (fs.File, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_fs_File{
		self: v,
	}
	ctxObj0, ok := wordToObj["stat"]
	if !ok {
		return nil, errors.New("context to fs.File: expected context to have function Stat")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.File: context fn Stat: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Stat = func(ctx env.RyeCtx) (fs.FileInfo, error) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res0 fs.FileInfo
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[0].(type) {
			case env.RyeCtx:
				var err error
				res0, err = ctxTo_fs_FileInfo(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Native:
				if vc, ok := v.Value.(fs.FileInfo); ok {
					res0 = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+"expected native of type fs.FileInfo, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res0 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to fs.File: context fn Stat: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to fs.File: expected context to have function Read")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to fs.File: context fn Read: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Read = func(ctx env.RyeCtx, farg0 []byte) (int, error) {
			var farg0Val env.Object
			{
				items := make([]env.Object, len(farg0))
				for i, it := range farg0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to fs.File: context fn Read: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["close"]
	if !ok {
		return nil, errors.New("context to fs.File: expected context to have function Close")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.File: context fn Close: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Close = func(ctx env.RyeCtx) error {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.File: context fn Close: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_fs_FileInfo struct {
	self       env.RyeCtx
	fn_Name    func(self env.RyeCtx) string
	fn_Size    func(self env.RyeCtx) int64
	fn_Mode    func(self env.RyeCtx) fs.FileMode
	fn_ModTime func(self env.RyeCtx) time.Time
	fn_IsDir   func(self env.RyeCtx) bool
	fn_Sys     func(self env.RyeCtx) any
}

func (self *iface_fs_FileInfo) Name() string {
	return self.fn_Name(self.self)
}
func (self *iface_fs_FileInfo) Size() int64 {
	return self.fn_Size(self.self)
}
func (self *iface_fs_FileInfo) Mode() fs.FileMode {
	return self.fn_Mode(self.self)
}
func (self *iface_fs_FileInfo) ModTime() time.Time {
	return self.fn_ModTime(self.self)
}
func (self *iface_fs_FileInfo) IsDir() bool {
	return self.fn_IsDir(self.self)
}
func (self *iface_fs_FileInfo) Sys() any {
	return self.fn_Sys(self.self)
}

func ctxTo_fs_FileInfo(ps *env.ProgramState, v env.RyeCtx) (fs.FileInfo, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_fs_FileInfo{
		self: v,
	}
	ctxObj0, ok := wordToObj["name"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function Name")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn Name: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Name = func(ctx env.RyeCtx) string {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res string
			if vc, ok := ps.Res.(env.String); ok {
				res = string(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: "+"expected string, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn Name: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["size"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function Size")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn Size: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Size = func(ctx env.RyeCtx) int64 {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res int64
			if vc, ok := ps.Res.(env.Integer); ok {
				res = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn Size: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["mode"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function Mode")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn Mode: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Mode = func(ctx env.RyeCtx) fs.FileMode {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res fs.FileMode
			{
				nat, natOk := ps.Res.(env.Native)
				var natValOk bool
				var natVal fs.FileMode
				if natOk {
					natVal, natValOk = nat.Value.(fs.FileMode)
				}
				if natValOk {
					res = natVal
				} else {
					var u uint32
					if vc, ok := ps.Res.(env.Integer); ok {
						u = uint32(vc.Value)
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"context to fs.FileInfo: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					res = fs.FileMode(u)
				}
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn Mode: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj3, ok := wordToObj["mod-time"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function ModTime")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn ModTime: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ModTime = func(ctx env.RyeCtx) time.Time {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res time.Time
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(time.Time); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FileInfo: arg 0: callback result: "+"expected native of type time.Time, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn ModTime: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj4, ok := wordToObj["is-dir"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function IsDir")
	}
	switch fn := ctxObj4.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn IsDir: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_IsDir = func(ctx env.RyeCtx) bool {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res bool
			if vc, ok := ps.Res.(env.Integer); ok {
				res = vc.Value != 0
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn IsDir: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj5, ok := wordToObj["sys"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function Sys")
	}
	switch fn := ctxObj5.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn Sys: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Sys = func(ctx env.RyeCtx) any {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res any
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(any); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FileInfo: arg 0: callback result: "+"expected native of type any, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn Sys: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_image_Image struct {
	self          env.RyeCtx
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_image_Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_image_Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_image_Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_image_Image(ps *env.ProgramState, v env.RyeCtx) (image.Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_image_Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to image.Image: expected context to have function ColorModel")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.Image: context fn ColorModel: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+"expected native of type color.Model, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.Image: context fn ColorModel: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to image.Image: expected context to have function Bounds")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.Image: context fn Bounds: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+"expected native of type *image.Rectangle, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.Image: context fn Bounds: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to image.Image: expected context to have function At")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.Image: context fn At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.Color {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.Image: context fn At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_image_PalettedImage struct {
	self            env.RyeCtx
	fn_ColorIndexAt func(self env.RyeCtx, arg0 int, arg1 int) uint8
	fn_ColorModel   func(self env.RyeCtx) color.Model
	fn_Bounds       func(self env.RyeCtx) image.Rectangle
	fn_At           func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_image_PalettedImage) ColorIndexAt(arg0 int, arg1 int) uint8 {
	return self.fn_ColorIndexAt(self.self, arg0, arg1)
}
func (self *iface_image_PalettedImage) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_image_PalettedImage) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_image_PalettedImage) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_image_PalettedImage(ps *env.ProgramState, v env.RyeCtx) (image.PalettedImage, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_image_PalettedImage{
		self: v,
	}
	ctxObj0, ok := wordToObj["color-index-at"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function ColorIndexAt")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.PalettedImage: context fn ColorIndexAt: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ColorIndexAt = func(ctx env.RyeCtx, farg0 int, farg1 int) uint8 {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res uint8
			if vc, ok := ps.Res.(env.Integer); ok {
				res = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn ColorIndexAt: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function ColorModel")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.PalettedImage: context fn ColorModel: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+"expected native of type color.Model, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn ColorModel: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function Bounds")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.PalettedImage: context fn Bounds: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+"expected native of type *image.Rectangle, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn Bounds: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj3, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function At")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.PalettedImage: context fn At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.Color {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_image_RGBA64Image struct {
	self          env.RyeCtx
	fn_RGBA64At   func(self env.RyeCtx, arg0 int, arg1 int) color.RGBA64
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_image_RGBA64Image) RGBA64At(arg0 int, arg1 int) color.RGBA64 {
	return self.fn_RGBA64At(self.self, arg0, arg1)
}
func (self *iface_image_RGBA64Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_image_RGBA64Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_image_RGBA64Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_image_RGBA64Image(ps *env.ProgramState, v env.RyeCtx) (image.RGBA64Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_image_RGBA64Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["rgba-64-at"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function RGBA64At")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.RGBA64Image: context fn RGBA64At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_RGBA64At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.RGBA64 {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.RGBA64
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+"expected native of type *color.RGBA64, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn RGBA64At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function ColorModel")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.RGBA64Image: context fn ColorModel: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+"expected native of type color.Model, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn ColorModel: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj2, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function Bounds")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.RGBA64Image: context fn Bounds: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					res = *vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+"expected native of type *image.Rectangle, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn Bounds: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj3, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function At")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.RGBA64Image: context fn At: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_At = func(ctx env.RyeCtx, farg0 int, farg1 int) color.Color {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+err.Error(),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn At: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_io_ReadSeeker struct {
	self    env.RyeCtx
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Seek func(self env.RyeCtx, arg0 int64, arg1 int) (int64, error)
}

func (self *iface_io_ReadSeeker) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *iface_io_ReadSeeker) Seek(arg0 int64, arg1 int) (int64, error) {
	return self.fn_Seek(self.self, arg0, arg1)
}

func ctxTo_io_ReadSeeker(ps *env.ProgramState, v env.RyeCtx) (io.ReadSeeker, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_ReadSeeker{
		self: v,
	}
	ctxObj0, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to io.ReadSeeker: expected context to have function Read")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to io.ReadSeeker: context fn Read: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Read = func(ctx env.RyeCtx, farg0 []byte) (int, error) {
			var farg0Val env.Object
			{
				items := make([]env.Object, len(farg0))
				for i, it := range farg0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.ReadSeeker: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.ReadSeeker: context fn Read: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["seek"]
	if !ok {
		return nil, errors.New("context to io.ReadSeeker: expected context to have function Seek")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to io.ReadSeeker: context fn Seek: " + "expected 2 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Seek = func(ctx env.RyeCtx, farg0 int64, farg1 int) (int64, error) {
			var farg0Val, farg1Val env.Object
			farg0Val = *env.NewInteger(int64(farg0))
			farg1Val = *env.NewInteger(int64(farg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val)
			var res0 int64
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.ReadSeeker: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.ReadSeeker: context fn Seek: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_io_Reader struct {
	self    env.RyeCtx
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
}

func (self *iface_io_Reader) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}

func ctxTo_io_Reader(ps *env.ProgramState, v env.RyeCtx) (io.Reader, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_Reader{
		self: v,
	}
	ctxObj0, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to io.Reader: expected context to have function Read")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to io.Reader: context fn Read: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Read = func(ctx env.RyeCtx, farg0 []byte) (int, error) {
			var farg0Val env.Object
			{
				items := make([]env.Object, len(farg0))
				for i, it := range farg0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.Reader: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.Reader: context fn Read: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_io_Writer struct {
	self     env.RyeCtx
	fn_Write func(self env.RyeCtx, arg0 []byte) (int, error)
}

func (self *iface_io_Writer) Write(arg0 []byte) (int, error) {
	return self.fn_Write(self.self, arg0)
}

func ctxTo_io_Writer(ps *env.ProgramState, v env.RyeCtx) (io.Writer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_Writer{
		self: v,
	}
	ctxObj0, ok := wordToObj["write"]
	if !ok {
		return nil, errors.New("context to io.Writer: expected context to have function Write")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to io.Writer: context fn Write: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Write = func(ctx env.RyeCtx, farg0 []byte) (int, error) {
			var farg0Val env.Object
			{
				items := make([]env.Object, len(farg0))
				for i, it := range farg0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.Writer: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.Writer: context fn Write: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_jpeg_Reader struct {
	self        env.RyeCtx
	fn_ReadByte func(self env.RyeCtx) (byte, error)
	fn_Read     func(self env.RyeCtx, arg0 []byte) (int, error)
}

func (self *iface_jpeg_Reader) ReadByte() (byte, error) {
	return self.fn_ReadByte(self.self)
}
func (self *iface_jpeg_Reader) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}

func ctxTo_jpeg_Reader(ps *env.ProgramState, v env.RyeCtx) (jpeg.Reader, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_jpeg_Reader{
		self: v,
	}
	ctxObj0, ok := wordToObj["read-byte"]
	if !ok {
		return nil, errors.New("context to jpeg.Reader: expected context to have function ReadByte")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to jpeg.Reader: context fn ReadByte: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_ReadByte = func(ctx env.RyeCtx) (byte, error) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res0 byte
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[0].(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					res0 = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to jpeg.Reader: arg 0: callback result: "+"expected native of type byte, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to jpeg.Reader: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to jpeg.Reader: context fn ReadByte: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to jpeg.Reader: expected context to have function Read")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to jpeg.Reader: context fn Read: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Read = func(ctx env.RyeCtx, farg0 []byte) (int, error) {
			var farg0Val env.Object
			{
				items := make([]env.Object, len(farg0))
				for i, it := range farg0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				farg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if vc, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(vc.Value)
			} else {
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, res.Series.S[0]),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to jpeg.Reader: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to jpeg.Reader: arg 0: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to jpeg.Reader: context fn Read: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

type iface_png_EncoderBufferPool struct {
	self   env.RyeCtx
	fn_Get func(self env.RyeCtx) *png.EncoderBuffer
	fn_Put func(self env.RyeCtx, arg0 *png.EncoderBuffer)
}

func (self *iface_png_EncoderBufferPool) Get() *png.EncoderBuffer {
	return self.fn_Get(self.self)
}
func (self *iface_png_EncoderBufferPool) Put(arg0 *png.EncoderBuffer) {
	self.fn_Put(self.self, arg0)
}

func ctxTo_png_EncoderBufferPool(ps *env.ProgramState, v env.RyeCtx) (png.EncoderBufferPool, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_png_EncoderBufferPool{
		self: v,
	}
	ctxObj0, ok := wordToObj["get"]
	if !ok {
		return nil, errors.New("context to png.EncoderBufferPool: expected context to have function Get")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to png.EncoderBufferPool: context fn Get: " + "expected 0 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Get = func(ctx env.RyeCtx) *png.EncoderBuffer {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res *png.EncoderBuffer
			switch v := ps.Res.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.EncoderBuffer); ok {
					res = vc
				} else {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to png.EncoderBufferPool: arg 0: callback result: "+"expected native of type *png.EncoderBuffer, but got "+objectDebugString(ps.Idx, v),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to png.EncoderBufferPool: arg 0: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				ps.FailureFlag = true
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to png.EncoderBufferPool: arg 0: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to png.EncoderBufferPool: context fn Get: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	ctxObj1, ok := wordToObj["put"]
	if !ok {
		return nil, errors.New("context to png.EncoderBufferPool: expected context to have function Put")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to png.EncoderBufferPool: context fn Put: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
		}
		impl.fn_Put = func(ctx env.RyeCtx, farg0 *png.EncoderBuffer) {
			var farg0Val env.Object
			farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*png.EncoderBuffer)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
		}
	default:
		return nil, errors.New("context to png.EncoderBufferPool: context fn Put: " + "expected function, but got " + objectDebugString(ps.Idx, fn))
	}
	return impl, nil
}

var builtinsGenerated = map[string]*env.Builtin{
	"Go(*audio.Context)//is-ready": {
		Doc:   "(*audio.Context).IsReady",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//is-ready: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//is-ready: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Context)//is-ready: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsReady()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*audio.Context)//player": {
		Doc:   "(*audio.Context).NewPlayer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Context)//player: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Context)//player: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.NewPlayer(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.Player)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*audio.Context)//player-from-bytes": {
		Doc:   "(*audio.Context).NewPlayerFromBytes",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player-from-bytes: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player-from-bytes: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Context)//player-from-bytes: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*audio.Context)//player-from-bytes: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*audio.Context)//player-from-bytes: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//player-from-bytes: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Context)//player-from-bytes: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.NewPlayerFromBytes(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.Player)")
			return res0Obj
		},
	},
	"Go(*audio.Context)//sample-rate": {
		Doc:   "(*audio.Context).SampleRate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//sample-rate: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Context)//sample-rate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Context)//sample-rate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SampleRate()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*audio.InfiniteLoop)//read": {
		Doc:   "(*audio.InfiniteLoop).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.InfiniteLoop); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.InfiniteLoop)//read: arg 1: " + "expected native of type *audio.InfiniteLoop, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.InfiniteLoop)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.InfiniteLoop)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*audio.InfiniteLoop)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*audio.InfiniteLoop)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.InfiniteLoop)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.InfiniteLoop)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*audio.InfiniteLoop)//seek": {
		Doc:   "(*audio.InfiniteLoop).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.InfiniteLoop); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.InfiniteLoop)//seek: arg 1: " + "expected native of type *audio.InfiniteLoop, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.InfiniteLoop)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.InfiniteLoop)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*audio.InfiniteLoop)//seek: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*audio.InfiniteLoop)//seek: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*audio.Player)//close": {
		Doc:   "(*audio.Player).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//close: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//close: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//close: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Close()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*audio.Player)//current": {
		Doc:   "(*audio.Player).Current",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//current: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//current: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//current: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Current()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(time.Duration)")
			return res0Obj
		},
	},
	"Go(*audio.Player)//is-playing": {
		Doc:   "(*audio.Player).IsPlaying",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//is-playing: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//is-playing: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//is-playing: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsPlaying()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*audio.Player)//pause": {
		Doc:   "(*audio.Player).Pause",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//pause: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//pause: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//pause: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Pause()
			return arg0
		},
	},
	"Go(*audio.Player)//play": {
		Doc:   "(*audio.Player).Play",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//play: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//play: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//play: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Play()
			return arg0
		},
	},
	"Go(*audio.Player)//position": {
		Doc:   "(*audio.Player).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//position: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//position: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//position: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(time.Duration)")
			return res0Obj
		},
	},
	"Go(*audio.Player)//rewind": {
		Doc:   "(*audio.Player).Rewind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//rewind: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//rewind: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//rewind: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Rewind()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*audio.Player)//seek": {
		Doc:   "(*audio.Player).Seek",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//seek: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val time.Duration
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(time.Duration); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//seek: arg 2: " + "expected native of type time.Duration, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//seek: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Seek(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*audio.Player)//set-buffer-size": {
		Doc:   "(*audio.Player).SetBufferSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-buffer-size: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-buffer-size: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//set-buffer-size: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val time.Duration
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(time.Duration); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-buffer-size: arg 2: " + "expected native of type time.Duration, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//set-buffer-size: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetBufferSize(arg1Val)
			return arg0
		},
	},
	"Go(*audio.Player)//set-position": {
		Doc:   "(*audio.Player).SetPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-position: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-position: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//set-position: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val time.Duration
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(time.Duration); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-position: arg 2: " + "expected native of type time.Duration, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//set-position: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.SetPosition(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*audio.Player)//set-volume": {
		Doc:   "(*audio.Player).SetVolume",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-volume: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//set-volume: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//set-volume: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//set-volume: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.SetVolume(arg1Val)
			return arg0
		},
	},
	"Go(*audio.Player)//volume": {
		Doc:   "(*audio.Player).Volume",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Player); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//volume: arg 1: " + "expected native of type *audio.Player, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*audio.Player)//volume: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*audio.Player)//volume: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Volume()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//absorb-piece": {
		Doc:   "(*blocks.Field).AbsorbPiece",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//absorb-piece: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//absorb-piece: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//absorb-piece: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//absorb-piece: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//absorb-piece: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//absorb-piece: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//absorb-piece: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//absorb-piece: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//absorb-piece: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbPiece(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*blocks.Field)//draw": {
		Doc:   "(*blocks.Field).Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//draw: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//draw: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//draw: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*blocks.Field)//drop-piece": {
		Doc:   "(*blocks.Field).DropPiece",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//drop-piece: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//drop-piece: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//drop-piece: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//drop-piece: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//drop-piece: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//drop-piece: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//drop-piece: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//drop-piece: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//drop-piece: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.DropPiece(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//is-blocked": {
		Doc:   "(*blocks.Field).IsBlocked",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//is-blocked: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//is-blocked: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//is-blocked: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//is-blocked: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//is-blocked: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.IsBlocked(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//is-flush-animating": {
		Doc:   "(*blocks.Field).IsFlushAnimating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//is-flush-animating: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//is-flush-animating: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//is-flush-animating: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsFlushAnimating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//move-piece-to-left": {
		Doc:   "(*blocks.Field).MovePieceToLeft",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//move-piece-to-left: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.MovePieceToLeft(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//move-piece-to-right": {
		Doc:   "(*blocks.Field).MovePieceToRight",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//move-piece-to-right: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.MovePieceToRight(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//piece-droppable": {
		Doc:   "(*blocks.Field).PieceDroppable",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//piece-droppable: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//piece-droppable: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//piece-droppable: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//piece-droppable: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//piece-droppable: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//piece-droppable: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//piece-droppable: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//piece-droppable: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//piece-droppable: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.PieceDroppable(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//rotate-piece-left": {
		Doc:   "(*blocks.Field).RotatePieceLeft",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//rotate-piece-left: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotatePieceLeft(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//rotate-piece-right": {
		Doc:   "(*blocks.Field).RotatePieceRight",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 2: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Field)//rotate-piece-right: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotatePieceRight(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"Go(*blocks.Field)//set-end-flush-animating": {
		Doc:   "(*blocks.Field).SetEndFlushAnimating",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//set-end-flush-animating: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//set-end-flush-animating: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//set-end-flush-animating: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(int)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//set-end-flush-animating: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 int) {
					var farg0Val env.Object
					farg0Val = *env.NewInteger(int64(farg0))
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//set-end-flush-animating: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//set-end-flush-animating: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			arg0Val.SetEndFlushAnimating(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.Field)//update": {
		Doc:   "(*blocks.Field).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//update: arg 1: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Field)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Field)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Update()
			return arg0
		},
	},
	"Go(*blocks.Game)//draw": {
		Doc:   "(*blocks.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//draw: arg 1: " + "expected native of type *blocks.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Game)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Game)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.Game)//layout": {
		Doc:   "(*blocks.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//layout: arg 1: " + "expected native of type *blocks.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//layout: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Game)//layout: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Game)//layout: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Game)//layout: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*blocks.Game)//update": {
		Doc:   "(*blocks.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//update: arg 1: " + "expected native of type *blocks.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Game)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Game)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*blocks.GameScene)//draw": {
		Doc:   "(*blocks.GameScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameScene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//draw: arg 1: " + "expected native of type *blocks.GameScene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameScene)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameScene)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.GameScene)//update": {
		Doc:   "(*blocks.GameScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameScene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//update: arg 1: " + "expected native of type *blocks.GameScene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameScene)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//update: arg 2: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameScene)//update: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameScene)//update: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*blocks.GameState)//input!": {
		Doc:   "Set *blocks.GameState Input value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//input!: arg 1: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//input!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameState)//input!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *blocks.Input
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//input!: arg 2: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//input!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameState)//input!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Input = newVal
			return arg0
		},
	},
	"Go(*blocks.GameState)//input?": {
		Doc:   "Get *blocks.GameState Input value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//input?: arg 1: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//input?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameState)//input?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Input, "Go(*blocks.Input)")
			return resObj
		},
	},
	"Go(*blocks.GameState)//scene-manager!": {
		Doc:   "Set *blocks.GameState SceneManager value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//scene-manager!: arg 1: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//scene-manager!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameState)//scene-manager!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *blocks.SceneManager
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.SceneManager); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//scene-manager!: arg 2: " + "expected native of type *blocks.SceneManager, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//scene-manager!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameState)//scene-manager!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.SceneManager = newVal
			return arg0
		},
	},
	"Go(*blocks.GameState)//scene-manager?": {
		Doc:   "Get *blocks.GameState SceneManager value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//scene-manager?: arg 1: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GameState)//scene-manager?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GameState)//scene-manager?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SceneManager, "Go(*blocks.SceneManager)")
			return resObj
		},
	},
	"Go(*blocks.GamepadScene)//draw": {
		Doc:   "(*blocks.GamepadScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GamepadScene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//draw: arg 1: " + "expected native of type *blocks.GamepadScene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GamepadScene)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GamepadScene)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.GamepadScene)//update": {
		Doc:   "(*blocks.GamepadScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GamepadScene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//update: arg 1: " + "expected native of type *blocks.GamepadScene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GamepadScene)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//update: arg 2: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.GamepadScene)//update: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.GamepadScene)//update: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*blocks.Input)//gamepad-id-button-pressed": {
		Doc:   "(*blocks.Input).GamepadIDButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//gamepad-id-button-pressed: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//gamepad-id-button-pressed: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//gamepad-id-button-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.GamepadIDButtonPressed()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(ebiten.GamepadID)")
			return res0Obj
		},
	},
	"Go(*blocks.Input)//is-rotate-left-just-pressed": {
		Doc:   "(*blocks.Input).IsRotateLeftJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//is-rotate-left-just-pressed: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//is-rotate-left-just-pressed: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//is-rotate-left-just-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsRotateLeftJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Input)//is-rotate-right-just-pressed": {
		Doc:   "(*blocks.Input).IsRotateRightJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//is-rotate-right-just-pressed: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//is-rotate-right-just-pressed: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//is-rotate-right-just-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsRotateRightJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Input)//state-for-down": {
		Doc:   "(*blocks.Input).StateForDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//state-for-down: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//state-for-down: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//state-for-down: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.StateForDown()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Input)//state-for-left": {
		Doc:   "(*blocks.Input).StateForLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//state-for-left: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//state-for-left: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//state-for-left: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.StateForLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Input)//state-for-right": {
		Doc:   "(*blocks.Input).StateForRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//state-for-right: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//state-for-right: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//state-for-right: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.StateForRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*blocks.Input)//update": {
		Doc:   "(*blocks.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//update: arg 1: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Input)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Input)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Update()
			return arg0
		},
	},
	"Go(*blocks.Piece)//absorb-into": {
		Doc:   "(*blocks.Piece).AbsorbInto",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//absorb-into: arg 1: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//absorb-into: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//absorb-into: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Field
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Field); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//absorb-into: arg 2: " + "expected native of type *blocks.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//absorb-into: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//absorb-into: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//absorb-into: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//absorb-into: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Piece)//absorb-into: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbInto(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*blocks.Piece)//draw": {
		Doc:   "(*blocks.Piece).Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//draw: arg 1: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//draw: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//draw: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*blocks.Piece)//draw: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*blocks.Piece)//initial-position": {
		Doc:   "(*blocks.Piece).InitialPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Piece); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//initial-position: arg 1: " + "expected native of type *blocks.Piece, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.Piece)//initial-position: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.Piece)//initial-position: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.InitialPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*blocks.SceneManager)//draw": {
		Doc:   "(*blocks.SceneManager).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.SceneManager); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//draw: arg 1: " + "expected native of type *blocks.SceneManager, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.SceneManager)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.SceneManager)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.SceneManager)//go-to": {
		Doc:   "(*blocks.SceneManager).GoTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.SceneManager); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//go-to: arg 1: " + "expected native of type *blocks.SceneManager, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//go-to: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.SceneManager)//go-to: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val blocks.Scene
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_blocks_Scene(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//go-to: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(blocks.Scene); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//go-to: arg 2: " + "expected native of type blocks.Scene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//go-to: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.SceneManager)//go-to: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.GoTo(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.SceneManager)//update": {
		Doc:   "(*blocks.SceneManager).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.SceneManager); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//update: arg 1: " + "expected native of type *blocks.SceneManager, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.SceneManager)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.Input
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.Input); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//update: arg 2: " + "expected native of type *blocks.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.SceneManager)//update: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.SceneManager)//update: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*blocks.TitleScene)//draw": {
		Doc:   "(*blocks.TitleScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.TitleScene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//draw: arg 1: " + "expected native of type *blocks.TitleScene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.TitleScene)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.TitleScene)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*blocks.TitleScene)//update": {
		Doc:   "(*blocks.TitleScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.TitleScene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//update: arg 1: " + "expected native of type *blocks.TitleScene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.TitleScene)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//update: arg 2: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*blocks.TitleScene)//update: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*blocks.TitleScene)//update: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*bytes.Buffer)//bytes": {
		Doc:   "(*bytes.Buffer).Bytes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//bytes: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//bytes: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//bytes: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bytes()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//cap": {
		Doc:   "(*bytes.Buffer).Cap",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//cap: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//cap: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//cap: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Cap()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//grow": {
		Doc:   "(*bytes.Buffer).Grow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//grow: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//grow: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//grow: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//grow: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.Grow(arg1Val)
			return arg0
		},
	},
	"Go(*bytes.Buffer)//len": {
		Doc:   "(*bytes.Buffer).Len",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//len: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//len: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//len: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Len()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//next": {
		Doc:   "(*bytes.Buffer).Next",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//next: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//next: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//next: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//next: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := arg0Val.Next(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//read": {
		Doc:   "(*bytes.Buffer).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*bytes.Buffer)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*bytes.Buffer)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//read-byte": {
		Doc:   "(*bytes.Buffer).ReadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-byte: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-byte: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.ReadByte()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(byte)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//read-bytes": {
		Doc:   "(*bytes.Buffer).ReadBytes",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-bytes: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-bytes: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-bytes: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-bytes: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-bytes: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.ReadBytes(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//read-from": {
		Doc:   "(*bytes.Buffer).ReadFrom",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-from: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-from: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-from: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-from: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-from: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-from: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-from: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.ReadFrom(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//read-rune": {
		Doc:   "(*bytes.Buffer).ReadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-rune: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-rune: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, resErr := arg0Val.ReadRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(rune)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*bytes.Buffer)//read-string": {
		Doc:   "(*bytes.Buffer).ReadString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-string: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//read-string: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//read-string: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.ReadString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//reset": {
		Doc:   "(*bytes.Buffer).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//reset: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//reset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//reset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*bytes.Buffer)//string": {
		Doc:   "(*bytes.Buffer).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//string: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//truncate": {
		Doc:   "(*bytes.Buffer).Truncate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//truncate: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//truncate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//truncate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//truncate: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.Truncate(arg1Val)
			return arg0
		},
	},
	"Go(*bytes.Buffer)//unread-byte": {
		Doc:   "(*bytes.Buffer).UnreadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//unread-byte: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//unread-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//unread-byte: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.UnreadByte()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*bytes.Buffer)//unread-rune": {
		Doc:   "(*bytes.Buffer).UnreadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//unread-rune: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//unread-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//unread-rune: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.UnreadRune()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*bytes.Buffer)//write": {
		Doc:   "(*bytes.Buffer).Write",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*bytes.Buffer)//write: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*bytes.Buffer)//write: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Write(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//write-byte": {
		Doc:   "(*bytes.Buffer).WriteByte",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-byte: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-byte: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-byte: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-byte: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.WriteByte(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*bytes.Buffer)//write-rune": {
		Doc:   "(*bytes.Buffer).WriteRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-rune: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-rune: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(rune); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-rune: arg 2: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-rune: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.WriteRune(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//write-string": {
		Doc:   "(*bytes.Buffer).WriteString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-string: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-string: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0, resErr := arg0Val.WriteString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Buffer)//write-to": {
		Doc:   "(*bytes.Buffer).WriteTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Buffer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-to: arg 1: " + "expected native of type *bytes.Buffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-to: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-to: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-to: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-to: arg 2: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Buffer)//write-to: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Buffer)//write-to: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.WriteTo(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//len": {
		Doc:   "(*bytes.Reader).Len",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//len: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//len: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//len: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Len()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//read": {
		Doc:   "(*bytes.Reader).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*bytes.Reader)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*bytes.Reader)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//read-at": {
		Doc:   "(*bytes.Reader).ReadAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-at: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*bytes.Reader)//read-at: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*bytes.Reader)//read-at: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-at: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read-at: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int64
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.ReadAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//read-byte": {
		Doc:   "(*bytes.Reader).ReadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-byte: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read-byte: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.ReadByte()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(byte)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//read-rune": {
		Doc:   "(*bytes.Reader).ReadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-rune: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//read-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//read-rune: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, resErr := arg0Val.ReadRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(rune)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*bytes.Reader)//reset": {
		Doc:   "(*bytes.Reader).Reset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//reset: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//reset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//reset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*bytes.Reader)//reset: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*bytes.Reader)//reset: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//reset: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//reset: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Reset(arg1Val)
			return arg0
		},
	},
	"Go(*bytes.Reader)//seek": {
		Doc:   "(*bytes.Reader).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//seek: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//seek: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//seek: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//size": {
		Doc:   "(*bytes.Reader).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//size: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//size: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//size: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*bytes.Reader)//unread-byte": {
		Doc:   "(*bytes.Reader).UnreadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//unread-byte: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//unread-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//unread-byte: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.UnreadByte()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*bytes.Reader)//unread-rune": {
		Doc:   "(*bytes.Reader).UnreadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//unread-rune: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//unread-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//unread-rune: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.UnreadRune()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*bytes.Reader)//write-to": {
		Doc:   "(*bytes.Reader).WriteTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*bytes.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//write-to: arg 1: " + "expected native of type *bytes.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//write-to: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//write-to: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//write-to: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//write-to: arg 2: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*bytes.Reader)//write-to: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*bytes.Reader)//write-to: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.WriteTo(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*color.Alpha)//a!": {
		Doc:   "Set *color.Alpha A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha)//a!: arg 1: " + "expected native of type *color.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.Alpha)//a?": {
		Doc:   "Get *color.Alpha A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha)//a?: arg 1: " + "expected native of type *color.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.Alpha)//rgba": {
		Doc:   "color.Alpha.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha)//rgba: arg 1: " + "expected native of type *color.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.Alpha16)//a!": {
		Doc:   "Set *color.Alpha16 A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha16)//a!: arg 1: " + "expected native of type *color.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha16)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha16)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha16)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.Alpha16)//a?": {
		Doc:   "Get *color.Alpha16 A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha16)//a?: arg 1: " + "expected native of type *color.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha16)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha16)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.Alpha16)//rgba": {
		Doc:   "color.Alpha16.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha16); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Alpha16)//rgba: arg 1: " + "expected native of type *color.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Alpha16)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.CMYK)//c!": {
		Doc:   "Set *color.CMYK C value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//c!: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//c!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//c!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//c!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.C = newVal
			return arg0
		},
	},
	"Go(*color.CMYK)//c?": {
		Doc:   "Get *color.CMYK C value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//c?: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//c?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//c?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.C))
			return resObj
		},
	},
	"Go(*color.CMYK)//k!": {
		Doc:   "Set *color.CMYK K value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//k!: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//k!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//k!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//k!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.K = newVal
			return arg0
		},
	},
	"Go(*color.CMYK)//k?": {
		Doc:   "Get *color.CMYK K value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//k?: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//k?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//k?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.K))
			return resObj
		},
	},
	"Go(*color.CMYK)//m!": {
		Doc:   "Set *color.CMYK M value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//m!: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//m!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.M = newVal
			return arg0
		},
	},
	"Go(*color.CMYK)//m?": {
		Doc:   "Get *color.CMYK M value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//m?: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.M))
			return resObj
		},
	},
	"Go(*color.CMYK)//rgba": {
		Doc:   "color.CMYK.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//rgba: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.CMYK)//y!": {
		Doc:   "Set *color.CMYK Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//y!: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//y!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*color.CMYK)//y?": {
		Doc:   "Get *color.CMYK Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//y?: arg 1: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.CMYK)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.CMYK)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*color.Gray)//rgba": {
		Doc:   "color.Gray.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray)//rgba: arg 1: " + "expected native of type *color.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.Gray)//y!": {
		Doc:   "Set *color.Gray Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray)//y!: arg 1: " + "expected native of type *color.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray)//y!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*color.Gray)//y?": {
		Doc:   "Get *color.Gray Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray)//y?: arg 1: " + "expected native of type *color.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*color.Gray16)//rgba": {
		Doc:   "color.Gray16.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray16); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray16)//rgba: arg 1: " + "expected native of type *color.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray16)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.Gray16)//y!": {
		Doc:   "Set *color.Gray16 Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray16)//y!: arg 1: " + "expected native of type *color.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray16)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray16)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray16)//y!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*color.Gray16)//y?": {
		Doc:   "Get *color.Gray16 Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray16)//y?: arg 1: " + "expected native of type *color.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.Gray16)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.Gray16)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*color.NRGBA)//a!": {
		Doc:   "Set *color.NRGBA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//a!: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA)//a?": {
		Doc:   "Get *color.NRGBA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//a?: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.NRGBA)//b!": {
		Doc:   "Set *color.NRGBA B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//b!: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//b!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//b!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//b!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.B = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA)//b?": {
		Doc:   "Get *color.NRGBA B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//b?: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//b?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//b?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"Go(*color.NRGBA)//g!": {
		Doc:   "Set *color.NRGBA G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//g!: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//g!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//g!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//g!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.G = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA)//g?": {
		Doc:   "Get *color.NRGBA G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//g?: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//g?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//g?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"Go(*color.NRGBA)//r!": {
		Doc:   "Set *color.NRGBA R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//r!: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//r!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//r!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//r!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.R = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA)//r?": {
		Doc:   "Get *color.NRGBA R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//r?: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//r?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//r?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"Go(*color.NRGBA)//rgba": {
		Doc:   "color.NRGBA.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA)//rgba: arg 1: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.NRGBA64)//a!": {
		Doc:   "Set *color.NRGBA64 A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//a!: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA64)//a?": {
		Doc:   "Get *color.NRGBA64 A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//a?: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.NRGBA64)//b!": {
		Doc:   "Set *color.NRGBA64 B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//b!: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//b!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//b!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//b!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.B = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA64)//b?": {
		Doc:   "Get *color.NRGBA64 B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//b?: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//b?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//b?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"Go(*color.NRGBA64)//g!": {
		Doc:   "Set *color.NRGBA64 G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//g!: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//g!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//g!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//g!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.G = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA64)//g?": {
		Doc:   "Get *color.NRGBA64 G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//g?: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//g?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//g?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"Go(*color.NRGBA64)//r!": {
		Doc:   "Set *color.NRGBA64 R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//r!: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//r!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//r!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//r!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.R = newVal
			return arg0
		},
	},
	"Go(*color.NRGBA64)//r?": {
		Doc:   "Get *color.NRGBA64 R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//r?: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//r?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//r?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"Go(*color.NRGBA64)//rgba": {
		Doc:   "color.NRGBA64.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NRGBA64)//rgba: arg 1: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NRGBA64)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.NYCbCrA)//a!": {
		Doc:   "Set *color.NYCbCrA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//a!: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.NYCbCrA)//a?": {
		Doc:   "Get *color.NYCbCrA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//a?: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.NYCbCrA)//cb!": {
		Doc:   "Set *color.NYCbCrA Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cb!: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//cb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//cb!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Cb = newVal
			return arg0
		},
	},
	"Go(*color.NYCbCrA)//cb?": {
		Doc:   "Get *color.NYCbCrA Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cb?: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//cb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cb))
			return resObj
		},
	},
	"Go(*color.NYCbCrA)//cr!": {
		Doc:   "Set *color.NYCbCrA Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cr!: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cr!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//cr!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//cr!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Cr = newVal
			return arg0
		},
	},
	"Go(*color.NYCbCrA)//cr?": {
		Doc:   "Get *color.NYCbCrA Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cr?: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//cr?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//cr?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cr))
			return resObj
		},
	},
	"Go(*color.NYCbCrA)//rgba": {
		Doc:   "color.NYCbCrA.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//rgba: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.NYCbCrA)//y!": {
		Doc:   "Set *color.NYCbCrA Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y!: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//y!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*color.NYCbCrA)//y-cb-cr!": {
		Doc:   "Set *color.NYCbCrA YCbCr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y-cb-cr!: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y-cb-cr!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//y-cb-cr!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *color.YCbCr
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y-cb-cr!: arg 2: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y-cb-cr!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//y-cb-cr!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.YCbCr = *newVal
			return arg0
		},
	},
	"Go(*color.NYCbCrA)//y-cb-cr?": {
		Doc:   "Get *color.NYCbCrA YCbCr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y-cb-cr?: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y-cb-cr?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//y-cb-cr?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.YCbCr, "Go(*color.YCbCr)")
			return resObj
		},
	},
	"Go(*color.NYCbCrA)//y?": {
		Doc:   "Get *color.NYCbCrA Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y?: arg 1: " + "expected native of type *color.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.NYCbCrA)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.NYCbCrA)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*color.RGBA)//a!": {
		Doc:   "Set *color.RGBA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//a!: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.RGBA)//a?": {
		Doc:   "Get *color.RGBA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//a?: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.RGBA)//b!": {
		Doc:   "Set *color.RGBA B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//b!: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//b!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//b!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//b!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.B = newVal
			return arg0
		},
	},
	"Go(*color.RGBA)//b?": {
		Doc:   "Get *color.RGBA B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//b?: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//b?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//b?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"Go(*color.RGBA)//g!": {
		Doc:   "Set *color.RGBA G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//g!: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//g!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//g!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//g!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.G = newVal
			return arg0
		},
	},
	"Go(*color.RGBA)//g?": {
		Doc:   "Get *color.RGBA G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//g?: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//g?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//g?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"Go(*color.RGBA)//r!": {
		Doc:   "Set *color.RGBA R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//r!: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//r!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//r!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//r!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.R = newVal
			return arg0
		},
	},
	"Go(*color.RGBA)//r?": {
		Doc:   "Get *color.RGBA R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//r?: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//r?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//r?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"Go(*color.RGBA)//rgba": {
		Doc:   "color.RGBA.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA)//rgba: arg 1: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.RGBA64)//a!": {
		Doc:   "Set *color.RGBA64 A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//a!: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//a!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*color.RGBA64)//a?": {
		Doc:   "Get *color.RGBA64 A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//a?: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"Go(*color.RGBA64)//b!": {
		Doc:   "Set *color.RGBA64 B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//b!: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//b!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//b!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//b!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.B = newVal
			return arg0
		},
	},
	"Go(*color.RGBA64)//b?": {
		Doc:   "Get *color.RGBA64 B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//b?: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//b?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//b?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"Go(*color.RGBA64)//g!": {
		Doc:   "Set *color.RGBA64 G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//g!: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//g!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//g!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//g!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.G = newVal
			return arg0
		},
	},
	"Go(*color.RGBA64)//g?": {
		Doc:   "Get *color.RGBA64 G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//g?: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//g?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//g?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"Go(*color.RGBA64)//r!": {
		Doc:   "Set *color.RGBA64 R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//r!: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//r!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//r!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint16
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint16(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//r!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.R = newVal
			return arg0
		},
	},
	"Go(*color.RGBA64)//r?": {
		Doc:   "Get *color.RGBA64 R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//r?: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//r?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//r?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"Go(*color.RGBA64)//rgba": {
		Doc:   "color.RGBA64.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.RGBA64)//rgba: arg 1: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.RGBA64)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.YCbCr)//cb!": {
		Doc:   "Set *color.YCbCr Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cb!: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//cb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//cb!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Cb = newVal
			return arg0
		},
	},
	"Go(*color.YCbCr)//cb?": {
		Doc:   "Get *color.YCbCr Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cb?: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//cb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cb))
			return resObj
		},
	},
	"Go(*color.YCbCr)//cr!": {
		Doc:   "Set *color.YCbCr Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cr!: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cr!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//cr!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//cr!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Cr = newVal
			return arg0
		},
	},
	"Go(*color.YCbCr)//cr?": {
		Doc:   "Get *color.YCbCr Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cr?: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//cr?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//cr?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cr))
			return resObj
		},
	},
	"Go(*color.YCbCr)//rgba": {
		Doc:   "color.YCbCr.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//rgba: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*color.YCbCr)//y!": {
		Doc:   "Set *color.YCbCr Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//y!: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint8
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//y!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*color.YCbCr)//y?": {
		Doc:   "Get *color.YCbCr Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//y?: arg 1: " + "expected native of type *color.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*color.YCbCr)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*color.YCbCr)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*colorm.ColorM)//apply": {
		Doc:   "(*colorm.ColorM).Apply",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//apply: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//apply: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//apply: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//apply: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//apply: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//apply: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//apply: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Apply(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*colorm.ColorM)//change-hsv": {
		Doc:   "(*colorm.ColorM).ChangeHSV",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//change-hsv: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//change-hsv: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//change-hsv: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//change-hsv: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//change-hsv: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//change-hsv: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.ChangeHSV(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//concat": {
		Doc:   "(*colorm.ColorM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//concat: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//concat: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//concat: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val colorm.ColorM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//concat: arg 2: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//concat: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//element": {
		Doc:   "(*colorm.ColorM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//element: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//element: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//element: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//element: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//element: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*colorm.ColorM)//invert": {
		Doc:   "(*colorm.ColorM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//invert: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//invert: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//invert: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"Go(*colorm.ColorM)//is-invertible": {
		Doc:   "(*colorm.ColorM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//is-invertible: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//is-invertible: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//is-invertible: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*colorm.ColorM)//read-elements": {
		Doc:   "(*colorm.ColorM).ReadElements",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//read-elements: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//read-elements: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//read-elements: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []float32
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]float32, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Decimal); ok {
						arg1Val[i] = float32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.ColorM)//read-elements: arg 2: " + "block item: " + "expected decimal, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//read-elements: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//read-elements: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []float32
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float32, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Decimal); ok {
						arg2Val[i] = float32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.ColorM)//read-elements: arg 3: " + "block item: " + "expected decimal, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//read-elements: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//read-elements: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ReadElements(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//reset": {
		Doc:   "(*colorm.ColorM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//reset: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//reset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//reset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*colorm.ColorM)//rotate-hue": {
		Doc:   "(*colorm.ColorM).RotateHue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//rotate-hue: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//rotate-hue: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//rotate-hue: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//rotate-hue: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.RotateHue(arg1Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//scale": {
		Doc:   "(*colorm.ColorM).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val float64
			if vc, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale: arg 5: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg4))
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//scale-with-color": {
		Doc:   "(*colorm.ColorM).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//scale-with-color: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//set-element": {
		Doc:   "(*colorm.ColorM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//set-element: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//set-element: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//set-element: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//set-element: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//set-element: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//set-element: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*colorm.ColorM)//string": {
		Doc:   "(*colorm.ColorM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//string: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*colorm.ColorM)//translate": {
		Doc:   "(*colorm.ColorM).Translate",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//translate: arg 1: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.ColorM)//translate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//translate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//translate: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//translate: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//translate: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val float64
			if vc, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.ColorM)//translate: arg 5: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg4))
			}
			arg0Val.Translate(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*colorm.DrawImageOptions)//blend!": {
		Doc:   "Set *colorm.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//blend!: arg 1: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//blend!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//blend!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Blend
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//blend!: arg 2: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//blend!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//blend!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Blend = *newVal
			return arg0
		},
	},
	"Go(*colorm.DrawImageOptions)//blend?": {
		Doc:   "Get *colorm.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//blend?: arg 1: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//blend?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//blend?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "Go(*ebiten.Blend)")
			return resObj
		},
	},
	"Go(*colorm.DrawImageOptions)//filter!": {
		Doc:   "Set *colorm.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//filter!: arg 1: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//filter!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//filter!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Filter
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.DrawImageOptions)//filter!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Filter(u)
				}
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*colorm.DrawImageOptions)//filter?": {
		Doc:   "Get *colorm.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//filter?: arg 1: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//filter?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//filter?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"Go(*colorm.DrawImageOptions)//geo-m!": {
		Doc:   "Set *colorm.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//geo-m!: arg 1: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//geo-m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//geo-m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//geo-m!: arg 2: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//geo-m!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//geo-m!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.GeoM = *newVal
			return arg0
		},
	},
	"Go(*colorm.DrawImageOptions)//geo-m?": {
		Doc:   "Get *colorm.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//geo-m?: arg 1: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawImageOptions)//geo-m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawImageOptions)//geo-m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.GeoM, "Go(*ebiten.GeoM)")
			return resObj
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//address!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//address!: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//address!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//address!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Address
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.DrawTrianglesOptions)//address!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Address(u)
				}
			}
			self.Address = newVal
			return arg0
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//address?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//address?: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//address?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//address?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//anti-alias!": {
		Doc:   "Set *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias!: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.AntiAlias = newVal
			return arg0
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//anti-alias?": {
		Doc:   "Get *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias?: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//anti-alias?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//blend!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend!: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Blend
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend!: arg 2: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Blend = *newVal
			return arg0
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//blend?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend?: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//blend?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "Go(*ebiten.Blend)")
			return resObj
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//color-scale-mode!": {
		Doc:   "Set *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode!: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.ColorScaleMode
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.ColorScaleMode(u)
				}
			}
			self.ColorScaleMode = newVal
			return arg0
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//color-scale-mode?": {
		Doc:   "Get *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode?: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//color-scale-mode?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//fill-rule!": {
		Doc:   "Set *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule!: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.FillRule
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.FillRule(u)
				}
			}
			self.FillRule = newVal
			return arg0
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//fill-rule?": {
		Doc:   "Get *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule?: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//fill-rule?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//filter!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter!: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Filter
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Filter(u)
				}
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*colorm.DrawTrianglesOptions)//filter?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter?: arg 1: " + "expected native of type *colorm.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*colorm.DrawTrianglesOptions)//filter?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"Go(*ebiten.Blend)//blend-factor-destination-alpha!": {
		Doc:   "Set *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha!: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.BlendFactor
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							u = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = ebiten.BlendFactor(u)
				}
			}
			self.BlendFactorDestinationAlpha = newVal
			return arg0
		},
	},
	"Go(*ebiten.Blend)//blend-factor-destination-alpha?": {
		Doc:   "Get *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha?: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-alpha?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationAlpha), "Go(byte)")
			return resObj
		},
	},
	"Go(*ebiten.Blend)//blend-factor-destination-rgb!": {
		Doc:   "Set *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb!: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.BlendFactor
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							u = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = ebiten.BlendFactor(u)
				}
			}
			self.BlendFactorDestinationRGB = newVal
			return arg0
		},
	},
	"Go(*ebiten.Blend)//blend-factor-destination-rgb?": {
		Doc:   "Get *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb?: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-destination-rgb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationRGB), "Go(byte)")
			return resObj
		},
	},
	"Go(*ebiten.Blend)//blend-factor-source-alpha!": {
		Doc:   "Set *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha!: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.BlendFactor
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							u = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = ebiten.BlendFactor(u)
				}
			}
			self.BlendFactorSourceAlpha = newVal
			return arg0
		},
	},
	"Go(*ebiten.Blend)//blend-factor-source-alpha?": {
		Doc:   "Get *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha?: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-source-alpha?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceAlpha), "Go(byte)")
			return resObj
		},
	},
	"Go(*ebiten.Blend)//blend-factor-source-rgb!": {
		Doc:   "Set *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb!: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.BlendFactor
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							u = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = ebiten.BlendFactor(u)
				}
			}
			self.BlendFactorSourceRGB = newVal
			return arg0
		},
	},
	"Go(*ebiten.Blend)//blend-factor-source-rgb?": {
		Doc:   "Get *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb?: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-factor-source-rgb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceRGB), "Go(byte)")
			return resObj
		},
	},
	"Go(*ebiten.Blend)//blend-operation-alpha!": {
		Doc:   "Set *ebiten.Blend BlendOperationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha!: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.BlendOperation
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							u = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = ebiten.BlendOperation(u)
				}
			}
			self.BlendOperationAlpha = newVal
			return arg0
		},
	},
	"Go(*ebiten.Blend)//blend-operation-alpha?": {
		Doc:   "Get *ebiten.Blend BlendOperationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha?: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-operation-alpha?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationAlpha), "Go(byte)")
			return resObj
		},
	},
	"Go(*ebiten.Blend)//blend-operation-rgb!": {
		Doc:   "Set *ebiten.Blend BlendOperationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb!: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.BlendOperation
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							u = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = ebiten.BlendOperation(u)
				}
			}
			self.BlendOperationRGB = newVal
			return arg0
		},
	},
	"Go(*ebiten.Blend)//blend-operation-rgb?": {
		Doc:   "Get *ebiten.Blend BlendOperationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb?: arg 1: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Blend)//blend-operation-rgb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationRGB), "Go(byte)")
			return resObj
		},
	},
	"Go(*ebiten.ColorM)//apply": {
		Doc:   "(*ebiten.ColorM).Apply",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//apply: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//apply: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//apply: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//apply: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//apply: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//apply: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//apply: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Apply(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*ebiten.ColorM)//change-hsv": {
		Doc:   "(*ebiten.ColorM).ChangeHSV",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//change-hsv: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//change-hsv: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//change-hsv: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//change-hsv: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//change-hsv: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//change-hsv: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.ChangeHSV(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//concat": {
		Doc:   "(*ebiten.ColorM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//concat: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//concat: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//concat: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.ColorM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//concat: arg 2: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//concat: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//element": {
		Doc:   "(*ebiten.ColorM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//element: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//element: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//element: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//element: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//element: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.ColorM)//invert": {
		Doc:   "(*ebiten.ColorM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//invert: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//invert: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//invert: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//is-invertible": {
		Doc:   "(*ebiten.ColorM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//is-invertible: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//is-invertible: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//is-invertible: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.ColorM)//reset": {
		Doc:   "(*ebiten.ColorM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//reset: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//reset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//reset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//rotate-hue": {
		Doc:   "(*ebiten.ColorM).RotateHue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//rotate-hue: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//rotate-hue: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//rotate-hue: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//rotate-hue: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.RotateHue(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//scale": {
		Doc:   "(*ebiten.ColorM).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val float64
			if vc, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale: arg 5: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg4))
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//scale-with-color": {
		Doc:   "(*ebiten.ColorM).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//scale-with-color: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//set-element": {
		Doc:   "(*ebiten.ColorM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//set-element: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//set-element: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//set-element: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//set-element: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//set-element: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//set-element: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorM)//string": {
		Doc:   "(*ebiten.ColorM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//string: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*ebiten.ColorM)//translate": {
		Doc:   "(*ebiten.ColorM).Translate",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//translate: arg 1: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorM)//translate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//translate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//translate: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//translate: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//translate: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val float64
			if vc, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorM)//translate: arg 5: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg4))
			}
			arg0Val.Translate(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//a": {
		Doc:   "(*ebiten.ColorScale).A",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//a: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//a: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//a: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.A()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.ColorScale)//b": {
		Doc:   "(*ebiten.ColorScale).B",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//b: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//b: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//b: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.B()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.ColorScale)//g": {
		Doc:   "(*ebiten.ColorScale).G",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//g: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//g: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//g: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.G()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.ColorScale)//r": {
		Doc:   "(*ebiten.ColorScale).R",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//r: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//r: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//r: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.R()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.ColorScale)//reset": {
		Doc:   "(*ebiten.ColorScale).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//reset: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//reset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//reset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//scale": {
		Doc:   "(*ebiten.ColorScale).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float32
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float32
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val float32
			if vc, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale: arg 5: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg4))
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//scale-alpha": {
		Doc:   "(*ebiten.ColorScale).ScaleAlpha",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-alpha: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-alpha: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale-alpha: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale-alpha: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.ScaleAlpha(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//scale-with-color": {
		Doc:   "(*ebiten.ColorScale).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale-with-color: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//scale-with-color-scale": {
		Doc:   "(*ebiten.ColorScale).ScaleWithColorScale",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color-scale: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color-scale: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale-with-color-scale: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.ColorScale
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//scale-with-color-scale: arg 2: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//scale-with-color-scale: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ScaleWithColorScale(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//set-a": {
		Doc:   "(*ebiten.ColorScale).SetA",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-a: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-a: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-a: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-a: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.SetA(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//set-b": {
		Doc:   "(*ebiten.ColorScale).SetB",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-b: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-b: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-b: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-b: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.SetB(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//set-g": {
		Doc:   "(*ebiten.ColorScale).SetG",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-g: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-g: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-g: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-g: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.SetG(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//set-r": {
		Doc:   "(*ebiten.ColorScale).SetR",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-r: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//set-r: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-r: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//set-r: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.SetR(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.ColorScale)//string": {
		Doc:   "(*ebiten.ColorScale).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//string: arg 1: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.ColorScale)//string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.ColorScale)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*ebiten.DebugInfo)//graphics-library!": {
		Doc:   "Set *ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DebugInfo); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DebugInfo)//graphics-library!: arg 1: " + "expected native of type *ebiten.DebugInfo, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DebugInfo)//graphics-library!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DebugInfo)//graphics-library!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.GraphicsLibrary
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DebugInfo)//graphics-library!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.GraphicsLibrary(u)
				}
			}
			self.GraphicsLibrary = newVal
			return arg0
		},
	},
	"Go(*ebiten.DebugInfo)//graphics-library?": {
		Doc:   "Get *ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DebugInfo); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DebugInfo)//graphics-library?: arg 1: " + "expected native of type *ebiten.DebugInfo, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DebugInfo)//graphics-library?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DebugInfo)//graphics-library?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"Go(*ebiten.DrawImageOptions)//blend!": {
		Doc:   "Set *ebiten.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//blend!: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//blend!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//blend!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Blend
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//blend!: arg 2: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//blend!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//blend!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Blend = *newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawImageOptions)//blend?": {
		Doc:   "Get *ebiten.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//blend?: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//blend?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//blend?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "Go(*ebiten.Blend)")
			return resObj
		},
	},
	"Go(*ebiten.DrawImageOptions)//color-m!": {
		Doc:   "Set *ebiten.DrawImageOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-m!: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//color-m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.ColorM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-m!: arg 2: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-m!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//color-m!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.ColorM = *newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawImageOptions)//color-m?": {
		Doc:   "Get *ebiten.DrawImageOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-m?: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//color-m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorM, "Go(*ebiten.ColorM)")
			return resObj
		},
	},
	"Go(*ebiten.DrawImageOptions)//color-scale!": {
		Doc:   "Set *ebiten.DrawImageOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale!: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.ColorScale
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale!: arg 2: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.ColorScale = *newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawImageOptions)//color-scale?": {
		Doc:   "Get *ebiten.DrawImageOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale?: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//color-scale?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorScale, "Go(*ebiten.ColorScale)")
			return resObj
		},
	},
	"Go(*ebiten.DrawImageOptions)//composite-mode!": {
		Doc:   "Set *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode!: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.CompositeMode
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.CompositeMode(u)
				}
			}
			self.CompositeMode = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawImageOptions)//composite-mode?": {
		Doc:   "Get *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode?: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//composite-mode?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"Go(*ebiten.DrawImageOptions)//filter!": {
		Doc:   "Set *ebiten.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//filter!: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//filter!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//filter!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Filter
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawImageOptions)//filter!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Filter(u)
				}
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawImageOptions)//filter?": {
		Doc:   "Get *ebiten.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//filter?: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//filter?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//filter?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"Go(*ebiten.DrawImageOptions)//geo-m!": {
		Doc:   "Set *ebiten.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m!: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m!: arg 2: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.GeoM = *newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawImageOptions)//geo-m?": {
		Doc:   "Get *ebiten.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m?: arg 1: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawImageOptions)//geo-m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.GeoM, "Go(*ebiten.GeoM)")
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//address!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Address
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Address(u)
				}
			}
			self.Address = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//address?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//address?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//anti-alias!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.AntiAlias = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//anti-alias?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//anti-alias?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//blend!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Blend
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend!: arg 2: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Blend = *newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//blend?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//blend?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "Go(*ebiten.Blend)")
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//color-m!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.ColorM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m!: arg 2: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.ColorM = *newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//color-m?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorM, "Go(*ebiten.ColorM)")
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//color-scale-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.ColorScaleMode
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.ColorScaleMode(u)
				}
			}
			self.ColorScaleMode = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//color-scale-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//color-scale-mode?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//composite-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.CompositeMode
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.CompositeMode(u)
				}
			}
			self.CompositeMode = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//composite-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//composite-mode?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//fill-rule!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.FillRule
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.FillRule(u)
				}
			}
			self.FillRule = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//fill-rule?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//fill-rule?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//filter!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter!: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Filter
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Filter(u)
				}
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*ebiten.DrawTrianglesOptions)//filter?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter?: arg 1: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.DrawTrianglesOptions)//filter?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"Go(*ebiten.GeoM)//apply": {
		Doc:   "(*ebiten.GeoM).Apply",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//apply: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//apply: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//apply: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//apply: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//apply: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1 := arg0Val.Apply(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*ebiten.GeoM)//concat": {
		Doc:   "(*ebiten.GeoM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//concat: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//concat: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//concat: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//concat: arg 2: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//concat: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//element": {
		Doc:   "(*ebiten.GeoM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//element: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//element: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//element: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//element: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//element: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.GeoM)//invert": {
		Doc:   "(*ebiten.GeoM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//invert: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//invert: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//invert: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//is-invertible": {
		Doc:   "(*ebiten.GeoM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//is-invertible: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//is-invertible: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//is-invertible: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.GeoM)//reset": {
		Doc:   "(*ebiten.GeoM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//reset: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//reset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//reset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//rotate": {
		Doc:   "(*ebiten.GeoM).Rotate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//rotate: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//rotate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//rotate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//rotate: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			arg0Val.Rotate(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//scale": {
		Doc:   "(*ebiten.GeoM).Scale",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//scale: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//scale: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//scale: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//scale: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//scale: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.Scale(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//set-element": {
		Doc:   "(*ebiten.GeoM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//set-element: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//set-element: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//set-element: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//set-element: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//set-element: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//set-element: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//skew": {
		Doc:   "(*ebiten.GeoM).Skew",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//skew: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//skew: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//skew: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//skew: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//skew: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.Skew(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*ebiten.GeoM)//string": {
		Doc:   "(*ebiten.GeoM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//string: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//string: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*ebiten.GeoM)//translate": {
		Doc:   "(*ebiten.GeoM).Translate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//translate: arg 1: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.GeoM)//translate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//translate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//translate: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.GeoM)//translate: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.Translate(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//at": {
		Doc:   "(*ebiten.Image).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//at: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*ebiten.Image)//bounds": {
		Doc:   "(*ebiten.Image).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//bounds: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*ebiten.Image)//clear": {
		Doc:   "(*ebiten.Image).Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//clear: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//clear: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//clear: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"Go(*ebiten.Image)//color-model": {
		Doc:   "(*ebiten.Image).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//color-model: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*ebiten.Image)//deallocate": {
		Doc:   "(*ebiten.Image).Deallocate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//deallocate: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//deallocate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//deallocate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Deallocate()
			return arg0
		},
	},
	"Go(*ebiten.Image)//dispose": {
		Doc:   "(*ebiten.Image).Dispose",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//dispose: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//dispose: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//dispose: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Dispose()
			return arg0
		},
	},
	"Go(*ebiten.Image)//draw-image": {
		Doc:   "(*ebiten.Image).DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-image: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-image: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-image: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-image: arg 3: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-image: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-image: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//draw-rect-shader": {
		Doc:   "(*ebiten.Image).DrawRectShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Shader); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 4: " + "expected native of type *ebiten.Shader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val *ebiten.DrawRectShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawRectShaderOptions); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 5: " + "expected native of type *ebiten.DrawRectShaderOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-rect-shader: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawRectShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//draw-triangles": {
		Doc:   "(*ebiten.Image).DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.Vertex); ok {
							arg1Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 2: " + "block item: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 3: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 4: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 5: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//draw-triangles-shader": {
		Doc:   "(*ebiten.Image).DrawTrianglesShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.Vertex); ok {
							arg1Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 2: " + "block item: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 3: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Shader); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 4: " + "expected native of type *ebiten.Shader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val *ebiten.DrawTrianglesShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesShaderOptions); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 5: " + "expected native of type *ebiten.DrawTrianglesShaderOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//draw-triangles-shader: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawTrianglesShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//fill": {
		Doc:   "(*ebiten.Image).Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//fill: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//fill: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//fill: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//fill: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//fill: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//fill: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//fill: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//read-pixels": {
		Doc:   "(*ebiten.Image).ReadPixels",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//read-pixels: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//read-pixels: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//read-pixels: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Image)//read-pixels: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//read-pixels: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//read-pixels: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//read-pixels: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ReadPixels(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//replace-pixels": {
		Doc:   "(*ebiten.Image).ReplacePixels",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//replace-pixels: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.ReplacePixels(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//rgba-64-at": {
		Doc:   "(*ebiten.Image).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//rgba-64-at: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*ebiten.Image)//set": {
		Doc:   "(*ebiten.Image).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//set: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*ebiten.Image)//size": {
		Doc:   "(*ebiten.Image).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//size: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//size: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//size: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*ebiten.Image)//sub-image": {
		Doc:   "(*ebiten.Image).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//sub-image: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*ebiten.Image)//write-pixels": {
		Doc:   "(*ebiten.Image).WritePixels",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//write-pixels: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//write-pixels: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//write-pixels: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Image)//write-pixels: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Image)//write-pixels: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Image)//write-pixels: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Image)//write-pixels: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.WritePixels(arg1Val)
			return arg0
		},
	},
	"Go(*ebiten.Key)//unmarshal-text": {
		Doc:   "(*ebiten.Key).UnmarshalText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Key
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Key); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 1: " + "expected native of type *ebiten.Key, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Key)//unmarshal-text: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.UnmarshalText(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*ebiten.MonitorType)//device-scale-factor": {
		Doc:   "(*ebiten.MonitorType).DeviceScaleFactor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.MonitorType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.MonitorType)//device-scale-factor: arg 1: " + "expected native of type *ebiten.MonitorType, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.MonitorType)//device-scale-factor: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.MonitorType)//device-scale-factor: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*ebiten.MonitorType)//name": {
		Doc:   "(*ebiten.MonitorType).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.MonitorType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.MonitorType)//name: arg 1: " + "expected native of type *ebiten.MonitorType, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.MonitorType)//name: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.MonitorType)//name: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*ebiten.MonitorType)//size": {
		Doc:   "(*ebiten.MonitorType).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.MonitorType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.MonitorType)//size: arg 1: " + "expected native of type *ebiten.MonitorType, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.MonitorType)//size: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.MonitorType)//size: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*ebiten.NewImageFromImageOptions)//preserve-bounds!": {
		Doc:   "Set *ebiten.NewImageFromImageOptions PreserveBounds value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageFromImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds!: arg 1: " + "expected native of type *ebiten.NewImageFromImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.PreserveBounds = newVal
			return arg0
		},
	},
	"Go(*ebiten.NewImageFromImageOptions)//preserve-bounds?": {
		Doc:   "Get *ebiten.NewImageFromImageOptions PreserveBounds value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageFromImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds?: arg 1: " + "expected native of type *ebiten.NewImageFromImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageFromImageOptions)//preserve-bounds?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.PreserveBounds))
			return resObj
		},
	},
	"Go(*ebiten.NewImageFromImageOptions)//unmanaged!": {
		Doc:   "Set *ebiten.NewImageFromImageOptions Unmanaged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageFromImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged!: arg 1: " + "expected native of type *ebiten.NewImageFromImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Unmanaged = newVal
			return arg0
		},
	},
	"Go(*ebiten.NewImageFromImageOptions)//unmanaged?": {
		Doc:   "Get *ebiten.NewImageFromImageOptions Unmanaged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageFromImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged?: arg 1: " + "expected native of type *ebiten.NewImageFromImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageFromImageOptions)//unmanaged?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Unmanaged))
			return resObj
		},
	},
	"Go(*ebiten.NewImageOptions)//unmanaged!": {
		Doc:   "Set *ebiten.NewImageOptions Unmanaged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged!: arg 1: " + "expected native of type *ebiten.NewImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Unmanaged = newVal
			return arg0
		},
	},
	"Go(*ebiten.NewImageOptions)//unmanaged?": {
		Doc:   "Get *ebiten.NewImageOptions Unmanaged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged?: arg 1: " + "expected native of type *ebiten.NewImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.NewImageOptions)//unmanaged?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Unmanaged))
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//graphics-library!": {
		Doc:   "Set *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.GraphicsLibrary
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.GraphicsLibrary(u)
				}
			}
			self.GraphicsLibrary = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//graphics-library?": {
		Doc:   "Get *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//graphics-library?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//init-unfocused!": {
		Doc:   "Set *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.InitUnfocused = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//init-unfocused?": {
		Doc:   "Get *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//init-unfocused?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.InitUnfocused))
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//screen-transparent!": {
		Doc:   "Set *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.ScreenTransparent = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//screen-transparent?": {
		Doc:   "Get *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//screen-transparent?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScreenTransparent))
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//single-thread!": {
		Doc:   "Set *ebiten.RunGameOptions SingleThread value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//single-thread!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//single-thread!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//single-thread!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//single-thread!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.SingleThread = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//single-thread?": {
		Doc:   "Get *ebiten.RunGameOptions SingleThread value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//single-thread?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//single-thread?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//single-thread?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleThread))
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//skip-taskbar!": {
		Doc:   "Set *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.SkipTaskbar = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//skip-taskbar?": {
		Doc:   "Get *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//skip-taskbar?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SkipTaskbar))
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//x-11-class-name!": {
		Doc:   "Set *ebiten.RunGameOptions X11ClassName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal string
			if vc, ok := arg1.(env.String); ok {
				newVal = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name!: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.X11ClassName = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//x-11-class-name?": {
		Doc:   "Get *ebiten.RunGameOptions X11ClassName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//x-11-class-name?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11ClassName)
			return resObj
		},
	},
	"Go(*ebiten.RunGameOptions)//x-11-instance-name!": {
		Doc:   "Set *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name!: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal string
			if vc, ok := arg1.(env.String); ok {
				newVal = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name!: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.X11InstanceName = newVal
			return arg0
		},
	},
	"Go(*ebiten.RunGameOptions)//x-11-instance-name?": {
		Doc:   "Get *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name?: arg 1: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.RunGameOptions)//x-11-instance-name?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11InstanceName)
			return resObj
		},
	},
	"Go(*ebiten.Shader)//deallocate": {
		Doc:   "(*ebiten.Shader).Deallocate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Shader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Shader)//deallocate: arg 1: " + "expected native of type *ebiten.Shader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Shader)//deallocate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Shader)//deallocate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Deallocate()
			return arg0
		},
	},
	"Go(*ebiten.Shader)//dispose": {
		Doc:   "(*ebiten.Shader).Dispose",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Shader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Shader)//dispose: arg 1: " + "expected native of type *ebiten.Shader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Shader)//dispose: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Shader)//dispose: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Dispose()
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//color-a!": {
		Doc:   "Set *ebiten.Vertex ColorA value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-a!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-a!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.ColorA = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//color-a?": {
		Doc:   "Get *ebiten.Vertex ColorA value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-a?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorA))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//color-b!": {
		Doc:   "Set *ebiten.Vertex ColorB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-b!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-b!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-b!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-b!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.ColorB = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//color-b?": {
		Doc:   "Get *ebiten.Vertex ColorB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-b?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-b?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-b?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorB))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//color-g!": {
		Doc:   "Set *ebiten.Vertex ColorG value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-g!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-g!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-g!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-g!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.ColorG = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//color-g?": {
		Doc:   "Get *ebiten.Vertex ColorG value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-g?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-g?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-g?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorG))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//color-r!": {
		Doc:   "Set *ebiten.Vertex ColorR value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-r!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-r!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-r!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-r!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.ColorR = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//color-r?": {
		Doc:   "Get *ebiten.Vertex ColorR value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-r?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//color-r?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//color-r?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorR))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//dst-x!": {
		Doc:   "Set *ebiten.Vertex DstX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-x!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-x!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//dst-x!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//dst-x!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.DstX = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//dst-x?": {
		Doc:   "Get *ebiten.Vertex DstX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-x?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-x?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//dst-x?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstX))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//dst-y!": {
		Doc:   "Set *ebiten.Vertex DstY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-y!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//dst-y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//dst-y!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.DstY = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//dst-y?": {
		Doc:   "Get *ebiten.Vertex DstY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-y?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//dst-y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//dst-y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstY))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//src-x!": {
		Doc:   "Set *ebiten.Vertex SrcX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-x!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-x!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//src-x!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//src-x!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.SrcX = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//src-x?": {
		Doc:   "Get *ebiten.Vertex SrcX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-x?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-x?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//src-x?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcX))
			return resObj
		},
	},
	"Go(*ebiten.Vertex)//src-y!": {
		Doc:   "Set *ebiten.Vertex SrcY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-y!: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//src-y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//src-y!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.SrcY = newVal
			return arg0
		},
	},
	"Go(*ebiten.Vertex)//src-y?": {
		Doc:   "Get *ebiten.Vertex SrcY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Vertex); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-y?: arg 1: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.Vertex)//src-y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.Vertex)//src-y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcY))
			return resObj
		},
	},
	"Go(*ebiten.VibrateGamepadOptions)//duration!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration!: arg 1: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal time.Duration
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(time.Duration); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration!: arg 2: " + "expected native of type time.Duration, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Duration = newVal
			return arg0
		},
	},
	"Go(*ebiten.VibrateGamepadOptions)//duration?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration?: arg 1: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//duration?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "Go(time.Duration)")
			return resObj
		},
	},
	"Go(*ebiten.VibrateGamepadOptions)//strong-magnitude!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude!: arg 1: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.StrongMagnitude = newVal
			return arg0
		},
	},
	"Go(*ebiten.VibrateGamepadOptions)//strong-magnitude?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude?: arg 1: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//strong-magnitude?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrongMagnitude))
			return resObj
		},
	},
	"Go(*ebiten.VibrateGamepadOptions)//weak-magnitude!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude!: arg 1: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.WeakMagnitude = newVal
			return arg0
		},
	},
	"Go(*ebiten.VibrateGamepadOptions)//weak-magnitude?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude?: arg 1: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateGamepadOptions)//weak-magnitude?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeakMagnitude))
			return resObj
		},
	},
	"Go(*ebiten.VibrateOptions)//duration!": {
		Doc:   "Set *ebiten.VibrateOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//duration!: arg 1: " + "expected native of type *ebiten.VibrateOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//duration!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateOptions)//duration!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal time.Duration
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(time.Duration); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//duration!: arg 2: " + "expected native of type time.Duration, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateOptions)//duration!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Duration = newVal
			return arg0
		},
	},
	"Go(*ebiten.VibrateOptions)//duration?": {
		Doc:   "Get *ebiten.VibrateOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//duration?: arg 1: " + "expected native of type *ebiten.VibrateOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//duration?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateOptions)//duration?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "Go(time.Duration)")
			return resObj
		},
	},
	"Go(*ebiten.VibrateOptions)//magnitude!": {
		Doc:   "Set *ebiten.VibrateOptions Magnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//magnitude!: arg 1: " + "expected native of type *ebiten.VibrateOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//magnitude!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateOptions)//magnitude!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateOptions)//magnitude!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Magnitude = newVal
			return arg0
		},
	},
	"Go(*ebiten.VibrateOptions)//magnitude?": {
		Doc:   "Get *ebiten.VibrateOptions Magnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//magnitude?: arg 1: " + "expected native of type *ebiten.VibrateOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten.VibrateOptions)//magnitude?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten.VibrateOptions)//magnitude?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Magnitude))
			return resObj
		},
	},
	"Go(*ebiten_text.Glyph)//image!": {
		Doc:   "Set *ebiten_text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//image!: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//image!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//image!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//image!: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//image!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//image!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Image = newVal
			return arg0
		},
	},
	"Go(*ebiten_text.Glyph)//image?": {
		Doc:   "Get *ebiten_text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//image?: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//image?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//image?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "Go(*ebiten.Image)")
			return resObj
		},
	},
	"Go(*ebiten_text.Glyph)//rune!": {
		Doc:   "Set *ebiten_text.Glyph Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//rune!: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//rune!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//rune!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal rune
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(rune); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//rune!: arg 2: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//rune!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rune = newVal
			return arg0
		},
	},
	"Go(*ebiten_text.Glyph)//rune?": {
		Doc:   "Get *ebiten_text.Glyph Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//rune?: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//rune?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//rune?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "Go(rune)")
			return resObj
		},
	},
	"Go(*ebiten_text.Glyph)//x!": {
		Doc:   "Set *ebiten_text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//x!: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//x!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//x!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//x!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.X = newVal
			return arg0
		},
	},
	"Go(*ebiten_text.Glyph)//x?": {
		Doc:   "Get *ebiten_text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//x?: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//x?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//x?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"Go(*ebiten_text.Glyph)//y!": {
		Doc:   "Set *ebiten_text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//y!: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//y!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*ebiten_text.Glyph)//y?": {
		Doc:   "Get *ebiten_text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//y?: arg 1: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*ebiten_text.Glyph)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*ebiten_text.Glyph)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"Go(*gif.GIF)//background-index!": {
		Doc:   "Set *gif.GIF BackgroundIndex value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//background-index!: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//background-index!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//background-index!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal byte
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//background-index!: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//background-index!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.BackgroundIndex = newVal
			return arg0
		},
	},
	"Go(*gif.GIF)//background-index?": {
		Doc:   "Get *gif.GIF BackgroundIndex value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//background-index?: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//background-index?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//background-index?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BackgroundIndex, "Go(byte)")
			return resObj
		},
	},
	"Go(*gif.GIF)//config!": {
		Doc:   "Set *gif.GIF Config value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//config!: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//config!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//config!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Config
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//config!: arg 2: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//config!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//config!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Config = *newVal
			return arg0
		},
	},
	"Go(*gif.GIF)//config?": {
		Doc:   "Get *gif.GIF Config value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//config?: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//config?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//config?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Config, "Go(*image.Config)")
			return resObj
		},
	},
	"Go(*gif.GIF)//delay!": {
		Doc:   "Set *gif.GIF Delay value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//delay!: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//delay!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//delay!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []int
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*gif.GIF)//delay!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//delay!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//delay!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Delay = newVal
			return arg0
		},
	},
	"Go(*gif.GIF)//delay?": {
		Doc:   "Get *gif.GIF Delay value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//delay?: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//delay?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//delay?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Delay))
				for i, it := range self.Delay {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*gif.GIF)//disposal!": {
		Doc:   "Set *gif.GIF Disposal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//disposal!: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//disposal!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//disposal!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []byte
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							newVal[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*gif.GIF)//disposal!: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*gif.GIF)//disposal!: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//disposal!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//disposal!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Disposal = newVal
			return arg0
		},
	},
	"Go(*gif.GIF)//disposal?": {
		Doc:   "Get *gif.GIF Disposal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//disposal?: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//disposal?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//disposal?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Disposal))
				for i, it := range self.Disposal {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*gif.GIF)//image!": {
		Doc:   "Set *gif.GIF Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//image!: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//image!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//image!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []*image.Paletted
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]*image.Paletted, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*image.Paletted); ok {
							newVal[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*gif.GIF)//image!: arg 2: " + "block item: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*gif.GIF)//image!: arg 2: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						newVal[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*gif.GIF)//image!: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//image!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//image!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Image = newVal
			return arg0
		},
	},
	"Go(*gif.GIF)//image?": {
		Doc:   "Get *gif.GIF Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//image?: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//image?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//image?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Image))
				for i, it := range self.Image {
					items[i] = *env.NewNative(ps.Idx, it, "Go(*image.Paletted)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*gif.GIF)//loop-count!": {
		Doc:   "Set *gif.GIF LoopCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//loop-count!: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//loop-count!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//loop-count!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//loop-count!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.LoopCount = newVal
			return arg0
		},
	},
	"Go(*gif.GIF)//loop-count?": {
		Doc:   "Get *gif.GIF LoopCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//loop-count?: arg 1: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.GIF)//loop-count?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.GIF)//loop-count?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.LoopCount))
			return resObj
		},
	},
	"Go(*gif.Options)//drawer!": {
		Doc:   "Set *gif.Options Drawer value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer!: arg 1: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//drawer!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal draw.Drawer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_draw_Drawer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer!: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Drawer); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer!: arg 2: " + "expected native of type draw.Drawer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//drawer!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Drawer = newVal
			return arg0
		},
	},
	"Go(*gif.Options)//drawer?": {
		Doc:   "Get *gif.Options Drawer value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer?: arg 1: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//drawer?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//drawer?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Drawer, "Go(draw.Drawer)")
			return resObj
		},
	},
	"Go(*gif.Options)//num-colors!": {
		Doc:   "Set *gif.Options NumColors value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//num-colors!: arg 1: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//num-colors!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//num-colors!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//num-colors!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.NumColors = newVal
			return arg0
		},
	},
	"Go(*gif.Options)//num-colors?": {
		Doc:   "Get *gif.Options NumColors value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//num-colors?: arg 1: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//num-colors?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//num-colors?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.NumColors))
			return resObj
		},
	},
	"Go(*gif.Options)//quantizer!": {
		Doc:   "Set *gif.Options Quantizer value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer!: arg 1: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//quantizer!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal draw.Quantizer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_draw_Quantizer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer!: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Quantizer); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer!: arg 2: " + "expected native of type draw.Quantizer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//quantizer!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Quantizer = newVal
			return arg0
		},
	},
	"Go(*gif.Options)//quantizer?": {
		Doc:   "Get *gif.Options Quantizer value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer?: arg 1: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gif.Options)//quantizer?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gif.Options)//quantizer?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Quantizer, "Go(draw.Quantizer)")
			return resObj
		},
	},
	"Go(*image.Alpha)//alpha-at": {
		Doc:   "(*image.Alpha).AlphaAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//alpha-at: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//alpha-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//alpha-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//alpha-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//alpha-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.AlphaAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.Alpha)")
			return res0Obj
		},
	},
	"Go(*image.Alpha)//at": {
		Doc:   "(*image.Alpha).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//at: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Alpha)//bounds": {
		Doc:   "(*image.Alpha).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//bounds: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Alpha)//color-model": {
		Doc:   "(*image.Alpha).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//color-model: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Alpha)//opaque": {
		Doc:   "(*image.Alpha).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//opaque: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Alpha)//pix!": {
		Doc:   "Set *image.Alpha Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix!: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.Alpha)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.Alpha)//pix-offset": {
		Doc:   "(*image.Alpha).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix-offset: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Alpha)//pix?": {
		Doc:   "Get *image.Alpha Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix?: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Alpha)//rect!": {
		Doc:   "Set *image.Alpha Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rect!: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.Alpha)//rect?": {
		Doc:   "Get *image.Alpha Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rect?: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.Alpha)//rgba-64-at": {
		Doc:   "(*image.Alpha).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rgba-64-at: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.Alpha)//set": {
		Doc:   "(*image.Alpha).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Alpha)//set-alpha": {
		Doc:   "(*image.Alpha).SetAlpha",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set-alpha: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set-alpha: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-alpha: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-alpha: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-alpha: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Alpha
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set-alpha: arg 4: " + "expected native of type *color.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-alpha: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetAlpha(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Alpha)//set-rgba-64": {
		Doc:   "(*image.Alpha).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Alpha)//stride!": {
		Doc:   "Set *image.Alpha Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//stride!: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.Alpha)//stride?": {
		Doc:   "Get *image.Alpha Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//stride?: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.Alpha)//sub-image": {
		Doc:   "(*image.Alpha).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//sub-image: arg 1: " + "expected native of type *image.Alpha, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//alpha-16-at": {
		Doc:   "(*image.Alpha16).Alpha16At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//alpha-16-at: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//alpha-16-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//alpha-16-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//alpha-16-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//alpha-16-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.Alpha16At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.Alpha16)")
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//at": {
		Doc:   "(*image.Alpha16).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//at: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//bounds": {
		Doc:   "(*image.Alpha16).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//bounds: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//color-model": {
		Doc:   "(*image.Alpha16).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//color-model: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//opaque": {
		Doc:   "(*image.Alpha16).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//opaque: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//pix!": {
		Doc:   "Set *image.Alpha16 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix!: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.Alpha16)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.Alpha16)//pix-offset": {
		Doc:   "(*image.Alpha16).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix-offset: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//pix?": {
		Doc:   "Get *image.Alpha16 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix?: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Alpha16)//rect!": {
		Doc:   "Set *image.Alpha16 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rect!: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.Alpha16)//rect?": {
		Doc:   "Get *image.Alpha16 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rect?: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.Alpha16)//rgba-64-at": {
		Doc:   "(*image.Alpha16).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rgba-64-at: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.Alpha16)//set": {
		Doc:   "(*image.Alpha16).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Alpha16)//set-alpha-16": {
		Doc:   "(*image.Alpha16).SetAlpha16",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Alpha16
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Alpha16); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 4: " + "expected native of type *color.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-alpha-16: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetAlpha16(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Alpha16)//set-rgba-64": {
		Doc:   "(*image.Alpha16).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Alpha16)//stride!": {
		Doc:   "Set *image.Alpha16 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//stride!: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.Alpha16)//stride?": {
		Doc:   "Get *image.Alpha16 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//stride?: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.Alpha16)//sub-image": {
		Doc:   "(*image.Alpha16).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Alpha16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//sub-image: arg 1: " + "expected native of type *image.Alpha16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Alpha16)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Alpha16)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.CMYK)//at": {
		Doc:   "(*image.CMYK).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//at: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.CMYK)//bounds": {
		Doc:   "(*image.CMYK).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//bounds: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.CMYK)//cmyk-at": {
		Doc:   "(*image.CMYK).CMYKAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//cmyk-at: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//cmyk-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//cmyk-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//cmyk-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//cmyk-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.CMYKAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.CMYK)")
			return res0Obj
		},
	},
	"Go(*image.CMYK)//color-model": {
		Doc:   "(*image.CMYK).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//color-model: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.CMYK)//opaque": {
		Doc:   "(*image.CMYK).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//opaque: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.CMYK)//pix!": {
		Doc:   "Set *image.CMYK Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix!: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.CMYK)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.CMYK)//pix-offset": {
		Doc:   "(*image.CMYK).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix-offset: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.CMYK)//pix?": {
		Doc:   "Get *image.CMYK Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix?: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.CMYK)//rect!": {
		Doc:   "Set *image.CMYK Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rect!: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.CMYK)//rect?": {
		Doc:   "Get *image.CMYK Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rect?: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.CMYK)//rgba-64-at": {
		Doc:   "(*image.CMYK).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rgba-64-at: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.CMYK)//set": {
		Doc:   "(*image.CMYK).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.CMYK)//set-cmyk": {
		Doc:   "(*image.CMYK).SetCMYK",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set-cmyk: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set-cmyk: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-cmyk: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-cmyk: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-cmyk: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.CMYK
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.CMYK); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set-cmyk: arg 4: " + "expected native of type *color.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-cmyk: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetCMYK(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.CMYK)//set-rgba-64": {
		Doc:   "(*image.CMYK).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.CMYK)//stride!": {
		Doc:   "Set *image.CMYK Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//stride!: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.CMYK)//stride?": {
		Doc:   "Get *image.CMYK Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//stride?: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.CMYK)//sub-image": {
		Doc:   "(*image.CMYK).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.CMYK); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//sub-image: arg 1: " + "expected native of type *image.CMYK, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.CMYK)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.CMYK)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.Config)//color-model!": {
		Doc:   "Set *image.Config ColorModel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model!: arg 1: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//color-model!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal color.Model
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model!: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model!: arg 2: " + "expected native of type color.Model, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//color-model!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.ColorModel = newVal
			return arg0
		},
	},
	"Go(*image.Config)//color-model?": {
		Doc:   "Get *image.Config ColorModel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model?: arg 1: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//color-model?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//color-model?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.ColorModel, "Go(color.Model)")
			return resObj
		},
	},
	"Go(*image.Config)//height!": {
		Doc:   "Set *image.Config Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//height!: arg 1: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//height!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//height!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//height!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Height = newVal
			return arg0
		},
	},
	"Go(*image.Config)//height?": {
		Doc:   "Get *image.Config Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//height?: arg 1: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//height?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//height?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Height))
			return resObj
		},
	},
	"Go(*image.Config)//width!": {
		Doc:   "Set *image.Config Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//width!: arg 1: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//width!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//width!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//width!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Width = newVal
			return arg0
		},
	},
	"Go(*image.Config)//width?": {
		Doc:   "Get *image.Config Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Config); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//width?: arg 1: " + "expected native of type *image.Config, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Config)//width?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Config)//width?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Width))
			return resObj
		},
	},
	"Go(*image.Gray)//at": {
		Doc:   "(*image.Gray).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//at: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Gray)//bounds": {
		Doc:   "(*image.Gray).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//bounds: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Gray)//color-model": {
		Doc:   "(*image.Gray).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//color-model: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Gray)//gray-at": {
		Doc:   "(*image.Gray).GrayAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//gray-at: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//gray-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//gray-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//gray-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//gray-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.GrayAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.Gray)")
			return res0Obj
		},
	},
	"Go(*image.Gray)//opaque": {
		Doc:   "(*image.Gray).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//opaque: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Gray)//pix!": {
		Doc:   "Set *image.Gray Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix!: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.Gray)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.Gray)//pix-offset": {
		Doc:   "(*image.Gray).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix-offset: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Gray)//pix?": {
		Doc:   "Get *image.Gray Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix?: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Gray)//rect!": {
		Doc:   "Set *image.Gray Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rect!: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.Gray)//rect?": {
		Doc:   "Get *image.Gray Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rect?: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.Gray)//rgba-64-at": {
		Doc:   "(*image.Gray).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rgba-64-at: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.Gray)//set": {
		Doc:   "(*image.Gray).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Gray)//set-gray": {
		Doc:   "(*image.Gray).SetGray",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set-gray: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set-gray: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-gray: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-gray: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-gray: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Gray
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set-gray: arg 4: " + "expected native of type *color.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-gray: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetGray(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Gray)//set-rgba-64": {
		Doc:   "(*image.Gray).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set-rgba-64: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Gray)//stride!": {
		Doc:   "Set *image.Gray Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//stride!: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.Gray)//stride?": {
		Doc:   "Get *image.Gray Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//stride?: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.Gray)//sub-image": {
		Doc:   "(*image.Gray).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//sub-image: arg 1: " + "expected native of type *image.Gray, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.Gray16)//at": {
		Doc:   "(*image.Gray16).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//at: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Gray16)//bounds": {
		Doc:   "(*image.Gray16).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//bounds: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Gray16)//color-model": {
		Doc:   "(*image.Gray16).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//color-model: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Gray16)//gray-16-at": {
		Doc:   "(*image.Gray16).Gray16At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//gray-16-at: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//gray-16-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//gray-16-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//gray-16-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//gray-16-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.Gray16At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.Gray16)")
			return res0Obj
		},
	},
	"Go(*image.Gray16)//opaque": {
		Doc:   "(*image.Gray16).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//opaque: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Gray16)//pix!": {
		Doc:   "Set *image.Gray16 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix!: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.Gray16)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.Gray16)//pix-offset": {
		Doc:   "(*image.Gray16).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix-offset: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Gray16)//pix?": {
		Doc:   "Get *image.Gray16 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix?: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Gray16)//rect!": {
		Doc:   "Set *image.Gray16 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rect!: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.Gray16)//rect?": {
		Doc:   "Get *image.Gray16 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rect?: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.Gray16)//rgba-64-at": {
		Doc:   "(*image.Gray16).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rgba-64-at: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.Gray16)//set": {
		Doc:   "(*image.Gray16).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Gray16)//set-gray-16": {
		Doc:   "(*image.Gray16).SetGray16",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set-gray-16: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set-gray-16: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-gray-16: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-gray-16: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-gray-16: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Gray16
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.Gray16); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set-gray-16: arg 4: " + "expected native of type *color.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-gray-16: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetGray16(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Gray16)//set-rgba-64": {
		Doc:   "(*image.Gray16).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Gray16)//stride!": {
		Doc:   "Set *image.Gray16 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//stride!: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.Gray16)//stride?": {
		Doc:   "Get *image.Gray16 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//stride?: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.Gray16)//sub-image": {
		Doc:   "(*image.Gray16).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Gray16); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//sub-image: arg 1: " + "expected native of type *image.Gray16, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Gray16)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Gray16)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//at": {
		Doc:   "(*image.NRGBA).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//at: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//bounds": {
		Doc:   "(*image.NRGBA).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//bounds: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//color-model": {
		Doc:   "(*image.NRGBA).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//color-model: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//nrgba-at": {
		Doc:   "(*image.NRGBA).NRGBAAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//nrgba-at: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//nrgba-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//nrgba-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//nrgba-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//nrgba-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.NRGBAAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.NRGBA)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//opaque": {
		Doc:   "(*image.NRGBA).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//opaque: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//pix!": {
		Doc:   "Set *image.NRGBA Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix!: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NRGBA)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.NRGBA)//pix-offset": {
		Doc:   "(*image.NRGBA).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix-offset: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//pix?": {
		Doc:   "Get *image.NRGBA Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix?: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.NRGBA)//rect!": {
		Doc:   "Set *image.NRGBA Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rect!: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.NRGBA)//rect?": {
		Doc:   "Get *image.NRGBA Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rect?: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.NRGBA)//rgba-64-at": {
		Doc:   "(*image.NRGBA).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rgba-64-at: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA)//set": {
		Doc:   "(*image.NRGBA).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.NRGBA)//set-nrgba": {
		Doc:   "(*image.NRGBA).SetNRGBA",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.NRGBA
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 4: " + "expected native of type *color.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-nrgba: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetNRGBA(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.NRGBA)//set-rgba-64": {
		Doc:   "(*image.NRGBA).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.NRGBA)//stride!": {
		Doc:   "Set *image.NRGBA Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//stride!: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.NRGBA)//stride?": {
		Doc:   "Get *image.NRGBA Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//stride?: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.NRGBA)//sub-image": {
		Doc:   "(*image.NRGBA).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//sub-image: arg 1: " + "expected native of type *image.NRGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//at": {
		Doc:   "(*image.NRGBA64).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//at: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//bounds": {
		Doc:   "(*image.NRGBA64).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//bounds: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//color-model": {
		Doc:   "(*image.NRGBA64).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//color-model: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//nrgba-64-at": {
		Doc:   "(*image.NRGBA64).NRGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//nrgba-64-at: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//nrgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//nrgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//nrgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//nrgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.NRGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.NRGBA64)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//opaque": {
		Doc:   "(*image.NRGBA64).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//opaque: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//pix!": {
		Doc:   "Set *image.NRGBA64 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix!: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NRGBA64)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.NRGBA64)//pix-offset": {
		Doc:   "(*image.NRGBA64).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix-offset: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//pix?": {
		Doc:   "Get *image.NRGBA64 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix?: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.NRGBA64)//rect!": {
		Doc:   "Set *image.NRGBA64 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rect!: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.NRGBA64)//rect?": {
		Doc:   "Get *image.NRGBA64 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rect?: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.NRGBA64)//rgba-64-at": {
		Doc:   "(*image.NRGBA64).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rgba-64-at: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.NRGBA64)//set": {
		Doc:   "(*image.NRGBA64).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.NRGBA64)//set-nrgba-64": {
		Doc:   "(*image.NRGBA64).SetNRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.NRGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.NRGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 4: " + "expected native of type *color.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-nrgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetNRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.NRGBA64)//set-rgba-64": {
		Doc:   "(*image.NRGBA64).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.NRGBA64)//stride!": {
		Doc:   "Set *image.NRGBA64 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//stride!: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.NRGBA64)//stride?": {
		Doc:   "Get *image.NRGBA64 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//stride?: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.NRGBA64)//sub-image": {
		Doc:   "(*image.NRGBA64).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NRGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//sub-image: arg 1: " + "expected native of type *image.NRGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NRGBA64)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NRGBA64)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//a!": {
		Doc:   "Set *image.NYCbCrA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NYCbCrA)//a!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.A = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//a-offset": {
		Doc:   "(*image.NYCbCrA).AOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a-offset: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.AOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//a-stride!": {
		Doc:   "Set *image.NYCbCrA AStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a-stride!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a-stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a-stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a-stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.AStride = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//a-stride?": {
		Doc:   "Get *image.NYCbCrA AStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a-stride?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a-stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a-stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.AStride))
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//a?": {
		Doc:   "Get *image.NYCbCrA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//a?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//a?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.A))
				for i, it := range self.A {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//at": {
		Doc:   "(*image.NYCbCrA).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//at: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//bounds": {
		Doc:   "(*image.NYCbCrA).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//bounds: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//c-offset": {
		Doc:   "(*image.NYCbCrA).COffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//c-offset: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//c-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//c-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//c-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//c-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.COffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//c-stride!": {
		Doc:   "Set *image.NYCbCrA CStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//c-stride!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//c-stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//c-stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//c-stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.CStride = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//c-stride?": {
		Doc:   "Get *image.NYCbCrA CStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//c-stride?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//c-stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//c-stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CStride))
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//cb!": {
		Doc:   "Set *image.NYCbCrA Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cb!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//cb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NYCbCrA)//cb!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cb!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//cb!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Cb = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//cb?": {
		Doc:   "Get *image.NYCbCrA Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cb?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//cb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cb))
				for i, it := range self.Cb {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//color-model": {
		Doc:   "(*image.NYCbCrA).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//color-model: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//cr!": {
		Doc:   "Set *image.NYCbCrA Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cr!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cr!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//cr!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NYCbCrA)//cr!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cr!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//cr!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Cr = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//cr?": {
		Doc:   "Get *image.NYCbCrA Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cr?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//cr?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//cr?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cr))
				for i, it := range self.Cr {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//ny-cb-cr-a-at": {
		Doc:   "(*image.NYCbCrA).NYCbCrAAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//ny-cb-cr-a-at: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//ny-cb-cr-a-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//ny-cb-cr-a-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//ny-cb-cr-a-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//ny-cb-cr-a-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.NYCbCrAAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.NYCbCrA)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//opaque": {
		Doc:   "(*image.NYCbCrA).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//opaque: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//rect!": {
		Doc:   "Set *image.NYCbCrA Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rect!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//rect?": {
		Doc:   "Get *image.NYCbCrA Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rect?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//rgba-64-at": {
		Doc:   "(*image.NYCbCrA).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rgba-64-at: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//sub-image": {
		Doc:   "(*image.NYCbCrA).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//sub-image: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//subsample-ratio!": {
		Doc:   "Set *image.NYCbCrA SubsampleRatio value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//subsample-ratio!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//subsample-ratio!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//subsample-ratio!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal image.YCbCrSubsampleRatio
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NYCbCrA)//subsample-ratio!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = image.YCbCrSubsampleRatio(u)
				}
			}
			self.SubsampleRatio = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//subsample-ratio?": {
		Doc:   "Get *image.NYCbCrA SubsampleRatio value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//subsample-ratio?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//subsample-ratio?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//subsample-ratio?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SubsampleRatio)))
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//y!": {
		Doc:   "Set *image.NYCbCrA Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.NYCbCrA)//y!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//y-cb-cr!": {
		Doc:   "Set *image.NYCbCrA YCbCr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-cb-cr!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.YCbCr
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr!: arg 2: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-cb-cr!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.YCbCr = *newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//y-cb-cr-at": {
		Doc:   "(*image.NYCbCrA).YCbCrAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr-at: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-cb-cr-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-cb-cr-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-cb-cr-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.YCbCrAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.YCbCr)")
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//y-cb-cr?": {
		Doc:   "Get *image.NYCbCrA YCbCr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-cb-cr?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-cb-cr?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.YCbCr, "Go(*image.YCbCr)")
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//y-offset": {
		Doc:   "(*image.NYCbCrA).YOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-offset: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.YOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.NYCbCrA)//y-stride!": {
		Doc:   "Set *image.NYCbCrA YStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-stride!: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.YStride = newVal
			return arg0
		},
	},
	"Go(*image.NYCbCrA)//y-stride?": {
		Doc:   "Get *image.NYCbCrA YStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-stride?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y-stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y-stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.YStride))
			return resObj
		},
	},
	"Go(*image.NYCbCrA)//y?": {
		Doc:   "Get *image.NYCbCrA Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.NYCbCrA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y?: arg 1: " + "expected native of type *image.NYCbCrA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.NYCbCrA)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.NYCbCrA)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Y))
				for i, it := range self.Y {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Paletted)//at": {
		Doc:   "(*image.Paletted).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//at: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Paletted)//bounds": {
		Doc:   "(*image.Paletted).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//bounds: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Paletted)//color-index-at": {
		Doc:   "(*image.Paletted).ColorIndexAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//color-index-at: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//color-index-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//color-index-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//color-index-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//color-index-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.ColorIndexAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Paletted)//color-model": {
		Doc:   "(*image.Paletted).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//color-model: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Paletted)//opaque": {
		Doc:   "(*image.Paletted).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//opaque: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Paletted)//palette!": {
		Doc:   "Set *image.Paletted Palette value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//palette!: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//palette!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//palette!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal color.Palette
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u []color.Color
					switch v := arg1.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("Go(*image.Paletted)//palette!: arg 2: " + "block item: " + err.Error())
								}
							case env.Native:
								if vc, ok := v.Value.(color.Color); ok {
									u[i] = vc
								} else {
									ps.FailureFlag = true
									return env.NewError("Go(*image.Paletted)//palette!: arg 2: " + "block item: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("Go(*image.Paletted)//palette!: arg 2: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("Go(*image.Paletted)//palette!: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*image.Paletted)//palette!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*image.Paletted)//palette!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
					}
					newVal = color.Palette(u)
				}
			}
			self.Palette = newVal
			return arg0
		},
	},
	"Go(*image.Paletted)//palette?": {
		Doc:   "Get *image.Paletted Palette value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//palette?: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//palette?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//palette?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len([]color.Color(self.Palette)))
				for i, it := range []color.Color(self.Palette) {
					items[i] = ifaceToNative(ps.Idx, it, "Go(color.Color)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Paletted)//pix!": {
		Doc:   "Set *image.Paletted Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix!: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.Paletted)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.Paletted)//pix-offset": {
		Doc:   "(*image.Paletted).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix-offset: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Paletted)//pix?": {
		Doc:   "Get *image.Paletted Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix?: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.Paletted)//rect!": {
		Doc:   "Set *image.Paletted Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rect!: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.Paletted)//rect?": {
		Doc:   "Get *image.Paletted Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rect?: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.Paletted)//rgba-64-at": {
		Doc:   "(*image.Paletted).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rgba-64-at: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.Paletted)//set": {
		Doc:   "(*image.Paletted).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Paletted)//set-color-index": {
		Doc:   "(*image.Paletted).SetColorIndex",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set-color-index: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set-color-index: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-color-index: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-color-index: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-color-index: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val uint8
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-color-index: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.SetColorIndex(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Paletted)//set-rgba-64": {
		Doc:   "(*image.Paletted).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.Paletted)//stride!": {
		Doc:   "Set *image.Paletted Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//stride!: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.Paletted)//stride?": {
		Doc:   "Get *image.Paletted Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//stride?: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.Paletted)//sub-image": {
		Doc:   "(*image.Paletted).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Paletted); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//sub-image: arg 1: " + "expected native of type *image.Paletted, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Paletted)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Paletted)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.Point)//add": {
		Doc:   "image.Point.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//add: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//add: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//add: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//add: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"Go(*image.Point)//div": {
		Doc:   "image.Point.Div",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//div: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//div: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//div: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := arg0Val.Div(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"Go(*image.Point)//eq": {
		Doc:   "image.Point.Eq",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//eq: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//eq: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//eq: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//eq: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Eq(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Point)//in": {
		Doc:   "image.Point.In",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//in: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//in: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//in: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//in: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.In(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Point)//mod": {
		Doc:   "image.Point.Mod",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//mod: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//mod: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//mod: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//mod: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Mod(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"Go(*image.Point)//mul": {
		Doc:   "image.Point.Mul",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//mul: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//mul: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//mul: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := arg0Val.Mul(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"Go(*image.Point)//string": {
		Doc:   "image.Point.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//string: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*image.Point)//sub": {
		Doc:   "image.Point.Sub",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//sub: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//sub: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//sub: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//sub: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Sub(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"Go(*image.Point)//x!": {
		Doc:   "Set *image.Point X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//x!: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//x!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//x!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//x!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.X = newVal
			return arg0
		},
	},
	"Go(*image.Point)//x?": {
		Doc:   "Get *image.Point X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//x?: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//x?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//x?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.X))
			return resObj
		},
	},
	"Go(*image.Point)//y!": {
		Doc:   "Set *image.Point Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//y!: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//y!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*image.Point)//y?": {
		Doc:   "Get *image.Point Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//y?: arg 1: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Point)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Point)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*image.RGBA)//at": {
		Doc:   "(*image.RGBA).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//at: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.RGBA)//bounds": {
		Doc:   "(*image.RGBA).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//bounds: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.RGBA)//color-model": {
		Doc:   "(*image.RGBA).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//color-model: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.RGBA)//opaque": {
		Doc:   "(*image.RGBA).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//opaque: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.RGBA)//pix!": {
		Doc:   "Set *image.RGBA Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix!: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.RGBA)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.RGBA)//pix-offset": {
		Doc:   "(*image.RGBA).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix-offset: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.RGBA)//pix?": {
		Doc:   "Get *image.RGBA Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix?: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.RGBA)//rect!": {
		Doc:   "Set *image.RGBA Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rect!: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.RGBA)//rect?": {
		Doc:   "Get *image.RGBA Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rect?: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.RGBA)//rgba-64-at": {
		Doc:   "(*image.RGBA).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rgba-64-at: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.RGBA)//rgba-at": {
		Doc:   "(*image.RGBA).RGBAAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rgba-at: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//rgba-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rgba-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rgba-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//rgba-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBAAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA)")
			return res0Obj
		},
	},
	"Go(*image.RGBA)//set": {
		Doc:   "(*image.RGBA).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.RGBA)//set-rgba": {
		Doc:   "(*image.RGBA).SetRGBA",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set-rgba: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set-rgba: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set-rgba: arg 4: " + "expected native of type *color.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.RGBA)//set-rgba-64": {
		Doc:   "(*image.RGBA).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.RGBA)//stride!": {
		Doc:   "Set *image.RGBA Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//stride!: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.RGBA)//stride?": {
		Doc:   "Get *image.RGBA Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//stride?: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.RGBA)//sub-image": {
		Doc:   "(*image.RGBA).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//sub-image: arg 1: " + "expected native of type *image.RGBA, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//at": {
		Doc:   "(*image.RGBA64).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//at: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//bounds": {
		Doc:   "(*image.RGBA64).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//bounds: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//color-model": {
		Doc:   "(*image.RGBA64).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//color-model: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//opaque": {
		Doc:   "(*image.RGBA64).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//opaque: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//pix!": {
		Doc:   "Set *image.RGBA64 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix!: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//pix!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.RGBA64)//pix!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//pix!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Pix = newVal
			return arg0
		},
	},
	"Go(*image.RGBA64)//pix-offset": {
		Doc:   "(*image.RGBA64).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix-offset: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//pix-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//pix-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//pix-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//pix?": {
		Doc:   "Get *image.RGBA64 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix?: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//pix?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//pix?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.RGBA64)//rect!": {
		Doc:   "Set *image.RGBA64 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rect!: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.RGBA64)//rect?": {
		Doc:   "Get *image.RGBA64 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rect?: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.RGBA64)//rgba-64-at": {
		Doc:   "(*image.RGBA64).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rgba-64-at: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.RGBA64)//set": {
		Doc:   "(*image.RGBA64).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.RGBA64)//set-rgba-64": {
		Doc:   "(*image.RGBA64).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*image.RGBA64)//stride!": {
		Doc:   "Set *image.RGBA64 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//stride!: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Stride = newVal
			return arg0
		},
	},
	"Go(*image.RGBA64)//stride?": {
		Doc:   "Get *image.RGBA64 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//stride?: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"Go(*image.RGBA64)//sub-image": {
		Doc:   "(*image.RGBA64).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.RGBA64); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//sub-image: arg 1: " + "expected native of type *image.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.RGBA64)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.RGBA64)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//add": {
		Doc:   "image.Rectangle.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//add: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//add: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//add: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//add: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//at": {
		Doc:   "image.Rectangle.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//at: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//bounds": {
		Doc:   "image.Rectangle.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//bounds: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//canon": {
		Doc:   "image.Rectangle.Canon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//canon: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//canon: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Canon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//color-model": {
		Doc:   "image.Rectangle.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//color-model: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//dx": {
		Doc:   "image.Rectangle.Dx",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//dx: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//dx: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Dx()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//dy": {
		Doc:   "image.Rectangle.Dy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//dy: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//dy: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Dy()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//empty": {
		Doc:   "image.Rectangle.Empty",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//empty: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//empty: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Empty()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//eq": {
		Doc:   "image.Rectangle.Eq",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//eq: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//eq: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//eq: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//eq: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Eq(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//in": {
		Doc:   "image.Rectangle.In",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//in: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//in: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//in: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//in: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.In(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//inset": {
		Doc:   "image.Rectangle.Inset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//inset: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//inset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//inset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := arg0Val.Inset(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//intersect": {
		Doc:   "image.Rectangle.Intersect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//intersect: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//intersect: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//intersect: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//intersect: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Intersect(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//max!": {
		Doc:   "Set *image.Rectangle Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//max!: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//max!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//max!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//max!: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//max!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//max!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Max = *newVal
			return arg0
		},
	},
	"Go(*image.Rectangle)//max?": {
		Doc:   "Get *image.Rectangle Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//max?: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//max?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//max?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Max, "Go(*image.Point)")
			return resObj
		},
	},
	"Go(*image.Rectangle)//min!": {
		Doc:   "Set *image.Rectangle Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//min!: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//min!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//min!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//min!: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//min!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//min!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Min = *newVal
			return arg0
		},
	},
	"Go(*image.Rectangle)//min?": {
		Doc:   "Get *image.Rectangle Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//min?: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//min?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//min?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Min, "Go(*image.Point)")
			return resObj
		},
	},
	"Go(*image.Rectangle)//overlaps": {
		Doc:   "image.Rectangle.Overlaps",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//overlaps: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//overlaps: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//overlaps: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//overlaps: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Overlaps(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//rgba-64-at": {
		Doc:   "image.Rectangle.RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//rgba-64-at: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//size": {
		Doc:   "image.Rectangle.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//size: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//size: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//string": {
		Doc:   "image.Rectangle.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//string: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//sub": {
		Doc:   "image.Rectangle.Sub",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//sub: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//sub: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//sub: arg 2: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//sub: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Sub(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Rectangle)//union": {
		Doc:   "image.Rectangle.Union",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//union: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//union: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Rectangle)//union: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Rectangle)//union: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Union(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Uniform)//at": {
		Doc:   "(*image.Uniform).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//at: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Uniform)//bounds": {
		Doc:   "(*image.Uniform).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//bounds: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.Uniform)//c!": {
		Doc:   "Set *image.Uniform C value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c!: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//c!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c!: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c!: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//c!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.C = newVal
			return arg0
		},
	},
	"Go(*image.Uniform)//c?": {
		Doc:   "Get *image.Uniform C value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c?: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//c?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//c?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.C, "Go(color.Color)")
			return resObj
		},
	},
	"Go(*image.Uniform)//color-model": {
		Doc:   "(*image.Uniform).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//color-model: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.Uniform)//convert": {
		Doc:   "(*image.Uniform).Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//convert: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//convert: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//convert: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//convert: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//convert: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//convert: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//convert: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.Uniform)//opaque": {
		Doc:   "(*image.Uniform).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//opaque: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.Uniform)//rgba": {
		Doc:   "(*image.Uniform).RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//rgba: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//rgba: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(*image.Uniform)//rgba-64-at": {
		Doc:   "(*image.Uniform).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Uniform); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//rgba-64-at: arg 1: " + "expected native of type *image.Uniform, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.Uniform)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.Uniform)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//at": {
		Doc:   "(*image.YCbCr).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//at: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//bounds": {
		Doc:   "(*image.YCbCr).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//bounds: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//c-offset": {
		Doc:   "(*image.YCbCr).COffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//c-offset: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//c-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//c-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//c-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//c-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.COffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//c-stride!": {
		Doc:   "Set *image.YCbCr CStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//c-stride!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//c-stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//c-stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//c-stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.CStride = newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//c-stride?": {
		Doc:   "Get *image.YCbCr CStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//c-stride?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//c-stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//c-stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CStride))
			return resObj
		},
	},
	"Go(*image.YCbCr)//cb!": {
		Doc:   "Set *image.YCbCr Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cb!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cb!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//cb!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.YCbCr)//cb!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cb!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//cb!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Cb = newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//cb?": {
		Doc:   "Get *image.YCbCr Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cb?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cb?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//cb?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cb))
				for i, it := range self.Cb {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.YCbCr)//color-model": {
		Doc:   "(*image.YCbCr).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//color-model: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//cr!": {
		Doc:   "Set *image.YCbCr Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cr!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cr!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//cr!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.YCbCr)//cr!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cr!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//cr!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Cr = newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//cr?": {
		Doc:   "Get *image.YCbCr Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cr?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//cr?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//cr?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cr))
				for i, it := range self.Cr {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*image.YCbCr)//opaque": {
		Doc:   "(*image.YCbCr).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//opaque: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//opaque: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//opaque: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//rect!": {
		Doc:   "Set *image.YCbCr Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rect!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rect!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//rect!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rect!: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rect!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//rect!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Rect = *newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//rect?": {
		Doc:   "Get *image.YCbCr Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rect?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rect?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//rect?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"Go(*image.YCbCr)//rgba-64-at": {
		Doc:   "(*image.YCbCr).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rgba-64-at: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//sub-image": {
		Doc:   "(*image.YCbCr).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//sub-image: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//sub-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//sub-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//sub-image: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//sub-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.SubImage(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//subsample-ratio!": {
		Doc:   "Set *image.YCbCr SubsampleRatio value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//subsample-ratio!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//subsample-ratio!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//subsample-ratio!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal image.YCbCrSubsampleRatio
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.YCbCr)//subsample-ratio!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = image.YCbCrSubsampleRatio(u)
				}
			}
			self.SubsampleRatio = newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//subsample-ratio?": {
		Doc:   "Get *image.YCbCr SubsampleRatio value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//subsample-ratio?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//subsample-ratio?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//subsample-ratio?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SubsampleRatio)))
			return resObj
		},
	},
	"Go(*image.YCbCr)//y!": {
		Doc:   "Set *image.YCbCr Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal []uint8
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						newVal[i] = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*image.YCbCr)//y!: arg 2: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y!: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//y-cb-cr-at": {
		Doc:   "(*image.YCbCr).YCbCrAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-cb-cr-at: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-cb-cr-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-cb-cr-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-cb-cr-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-cb-cr-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.YCbCrAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.YCbCr)")
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//y-offset": {
		Doc:   "(*image.YCbCr).YOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-offset: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-offset: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-offset: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-offset: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-offset: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.YOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*image.YCbCr)//y-stride!": {
		Doc:   "Set *image.YCbCr YStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-stride!: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-stride!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-stride!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-stride!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.YStride = newVal
			return arg0
		},
	},
	"Go(*image.YCbCr)//y-stride?": {
		Doc:   "Get *image.YCbCr YStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-stride?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y-stride?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y-stride?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.YStride))
			return resObj
		},
	},
	"Go(*image.YCbCr)//y?": {
		Doc:   "Get *image.YCbCr Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.YCbCr); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y?: arg 1: " + "expected native of type *image.YCbCr, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*image.YCbCr)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*image.YCbCr)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Y))
				for i, it := range self.Y {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*jpeg.Options)//quality!": {
		Doc:   "Set *jpeg.Options Quality value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *jpeg.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*jpeg.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*jpeg.Options)//quality!: arg 1: " + "expected native of type *jpeg.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*jpeg.Options)//quality!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*jpeg.Options)//quality!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*jpeg.Options)//quality!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Quality = newVal
			return arg0
		},
	},
	"Go(*jpeg.Options)//quality?": {
		Doc:   "Get *jpeg.Options Quality value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *jpeg.Options
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*jpeg.Options); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*jpeg.Options)//quality?: arg 1: " + "expected native of type *jpeg.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*jpeg.Options)//quality?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*jpeg.Options)//quality?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Quality))
			return resObj
		},
	},
	"Go(*mp3.Stream)//length": {
		Doc:   "(*mp3.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*mp3.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//length: arg 1: " + "expected native of type *mp3.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//length: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*mp3.Stream)//length: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*mp3.Stream)//read": {
		Doc:   "(*mp3.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*mp3.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//read: arg 1: " + "expected native of type *mp3.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*mp3.Stream)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*mp3.Stream)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*mp3.Stream)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*mp3.Stream)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*mp3.Stream)//seek": {
		Doc:   "(*mp3.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*mp3.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//seek: arg 1: " + "expected native of type *mp3.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*mp3.Stream)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*mp3.Stream)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*mp3.Stream)//seek: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*mp3.Stream)//seek: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*png.Encoder)//buffer-pool!": {
		Doc:   "Set *png.Encoder BufferPool value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.Encoder); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 1: " + "expected native of type *png.Encoder, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal png.EncoderBufferPool
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_png_EncoderBufferPool(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(png.EncoderBufferPool); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 2: " + "expected native of type png.EncoderBufferPool, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//buffer-pool!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.BufferPool = newVal
			return arg0
		},
	},
	"Go(*png.Encoder)//buffer-pool?": {
		Doc:   "Get *png.Encoder BufferPool value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.Encoder); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool?: arg 1: " + "expected native of type *png.Encoder, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//buffer-pool?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//buffer-pool?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.BufferPool, "Go(png.EncoderBufferPool)")
			return resObj
		},
	},
	"Go(*png.Encoder)//compression-level!": {
		Doc:   "Set *png.Encoder CompressionLevel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.Encoder); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//compression-level!: arg 1: " + "expected native of type *png.Encoder, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//compression-level!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//compression-level!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal png.CompressionLevel
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal png.CompressionLevel
				if natOk {
					natVal, natValOk = nat.Value.(png.CompressionLevel)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*png.Encoder)//compression-level!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = png.CompressionLevel(u)
				}
			}
			self.CompressionLevel = newVal
			return arg0
		},
	},
	"Go(*png.Encoder)//compression-level?": {
		Doc:   "Get *png.Encoder CompressionLevel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.Encoder); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//compression-level?: arg 1: " + "expected native of type *png.Encoder, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//compression-level?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//compression-level?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompressionLevel)))
			return resObj
		},
	},
	"Go(*png.Encoder)//encode": {
		Doc:   "(*png.Encoder).Encode",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.Encoder); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 1: " + "expected native of type *png.Encoder, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//encode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 2: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//encode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val image.Image
			switch v := arg2.(type) {
			case env.RyeCtx:
				var err error
				arg2Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 3: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 3: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*png.Encoder)//encode: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*png.Encoder)//encode: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Encode(arg1Val, arg2Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*text.DrawOptions)//blend!": {
		Doc:   "Set *text.DrawOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//blend!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//blend!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//blend!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Blend
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Blend); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//blend!: arg 2: " + "expected native of type *ebiten.Blend, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//blend!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//blend!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Blend = *newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//blend?": {
		Doc:   "Get *text.DrawOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//blend?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//blend?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//blend?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "Go(*ebiten.Blend)")
			return resObj
		},
	},
	"Go(*text.DrawOptions)//color-m!": {
		Doc:   "Set *text.DrawOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-m!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//color-m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.ColorM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorM); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-m!: arg 2: " + "expected native of type *ebiten.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-m!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//color-m!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.ColorM = *newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//color-m?": {
		Doc:   "Get *text.DrawOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-m?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//color-m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorM, "Go(*ebiten.ColorM)")
			return resObj
		},
	},
	"Go(*text.DrawOptions)//color-scale!": {
		Doc:   "Set *text.DrawOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-scale!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-scale!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//color-scale!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.ColorScale
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.ColorScale); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-scale!: arg 2: " + "expected native of type *ebiten.ColorScale, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-scale!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//color-scale!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.ColorScale = *newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//color-scale?": {
		Doc:   "Get *text.DrawOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-scale?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//color-scale?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//color-scale?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorScale, "Go(*ebiten.ColorScale)")
			return resObj
		},
	},
	"Go(*text.DrawOptions)//composite-mode!": {
		Doc:   "Set *text.DrawOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//composite-mode!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//composite-mode!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//composite-mode!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.CompositeMode
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.DrawOptions)//composite-mode!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.CompositeMode(u)
				}
			}
			self.CompositeMode = newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//composite-mode?": {
		Doc:   "Get *text.DrawOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//composite-mode?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//composite-mode?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//composite-mode?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"Go(*text.DrawOptions)//draw-image-options!": {
		Doc:   "Set *text.DrawOptions DrawImageOptions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//draw-image-options!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//draw-image-options!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//draw-image-options!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.DrawImageOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//draw-image-options!: arg 2: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//draw-image-options!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//draw-image-options!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.DrawImageOptions = *newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//draw-image-options?": {
		Doc:   "Get *text.DrawOptions DrawImageOptions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//draw-image-options?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//draw-image-options?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//draw-image-options?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.DrawImageOptions, "Go(*ebiten.DrawImageOptions)")
			return resObj
		},
	},
	"Go(*text.DrawOptions)//filter!": {
		Doc:   "Set *text.DrawOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//filter!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//filter!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//filter!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal ebiten.Filter
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.DrawOptions)//filter!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = ebiten.Filter(u)
				}
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//filter?": {
		Doc:   "Get *text.DrawOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//filter?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//filter?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//filter?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"Go(*text.DrawOptions)//geo-m!": {
		Doc:   "Set *text.DrawOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//geo-m!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//geo-m!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//geo-m!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//geo-m!: arg 2: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//geo-m!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//geo-m!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.GeoM = *newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//geo-m?": {
		Doc:   "Get *text.DrawOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//geo-m?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//geo-m?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//geo-m?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.GeoM, "Go(*ebiten.GeoM)")
			return resObj
		},
	},
	"Go(*text.DrawOptions)//layout-options!": {
		Doc:   "Set *text.DrawOptions LayoutOptions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//layout-options!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//layout-options!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//layout-options!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *text.LayoutOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//layout-options!: arg 2: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//layout-options!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//layout-options!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.LayoutOptions = *newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//layout-options?": {
		Doc:   "Get *text.DrawOptions LayoutOptions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//layout-options?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//layout-options?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//layout-options?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.LayoutOptions, "Go(*text.LayoutOptions)")
			return resObj
		},
	},
	"Go(*text.DrawOptions)//line-spacing!": {
		Doc:   "Set *text.DrawOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//line-spacing!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//line-spacing!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//line-spacing!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//line-spacing!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.LineSpacing = newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//line-spacing?": {
		Doc:   "Get *text.DrawOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//line-spacing?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//line-spacing?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//line-spacing?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"Go(*text.DrawOptions)//primary-align!": {
		Doc:   "Set *text.DrawOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//primary-align!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//primary-align!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//primary-align!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Align
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.DrawOptions)//primary-align!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Align(u)
				}
			}
			self.PrimaryAlign = newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//primary-align?": {
		Doc:   "Get *text.DrawOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//primary-align?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//primary-align?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//primary-align?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"Go(*text.DrawOptions)//secondary-align!": {
		Doc:   "Set *text.DrawOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//secondary-align!: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//secondary-align!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//secondary-align!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Align
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.DrawOptions)//secondary-align!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Align(u)
				}
			}
			self.SecondaryAlign = newVal
			return arg0
		},
	},
	"Go(*text.DrawOptions)//secondary-align?": {
		Doc:   "Get *text.DrawOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//secondary-align?: arg 1: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.DrawOptions)//secondary-align?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.DrawOptions)//secondary-align?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"Go(*text.Glyph)//end-index-in-bytes!": {
		Doc:   "Set *text.Glyph EndIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//end-index-in-bytes!: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//end-index-in-bytes!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//end-index-in-bytes!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//end-index-in-bytes!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.EndIndexInBytes = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//end-index-in-bytes?": {
		Doc:   "Get *text.Glyph EndIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//end-index-in-bytes?: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//end-index-in-bytes?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//end-index-in-bytes?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.EndIndexInBytes))
			return resObj
		},
	},
	"Go(*text.Glyph)//gid!": {
		Doc:   "Set *text.Glyph GID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//gid!: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//gid!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//gid!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal uint32
			if vc, ok := arg1.(env.Integer); ok {
				newVal = uint32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//gid!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.GID = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//gid?": {
		Doc:   "Get *text.Glyph GID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//gid?: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//gid?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//gid?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.GID))
			return resObj
		},
	},
	"Go(*text.Glyph)//image!": {
		Doc:   "Set *text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//image!: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//image!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//image!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//image!: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//image!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//image!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Image = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//image?": {
		Doc:   "Get *text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//image?: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//image?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//image?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "Go(*ebiten.Image)")
			return resObj
		},
	},
	"Go(*text.Glyph)//start-index-in-bytes!": {
		Doc:   "Set *text.Glyph StartIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//start-index-in-bytes!: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//start-index-in-bytes!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//start-index-in-bytes!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//start-index-in-bytes!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.StartIndexInBytes = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//start-index-in-bytes?": {
		Doc:   "Get *text.Glyph StartIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//start-index-in-bytes?: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//start-index-in-bytes?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//start-index-in-bytes?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StartIndexInBytes))
			return resObj
		},
	},
	"Go(*text.Glyph)//x!": {
		Doc:   "Set *text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x!: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//x!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//x!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.X = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//x?": {
		Doc:   "Get *text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x?: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//x?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"Go(*text.Glyph)//y!": {
		Doc:   "Set *text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y!: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//y!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//y!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//y?": {
		Doc:   "Get *text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Glyph); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y?: arg 1: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//y?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"Go(*text.GoTextFace)//direction!": {
		Doc:   "Set *text.GoTextFace Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//direction!: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//direction!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//direction!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Direction
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Direction
				if natOk {
					natVal, natValOk = nat.Value.(text.Direction)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.GoTextFace)//direction!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Direction(u)
				}
			}
			self.Direction = newVal
			return arg0
		},
	},
	"Go(*text.GoTextFace)//direction?": {
		Doc:   "Get *text.GoTextFace Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//direction?: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//direction?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//direction?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Direction)))
			return resObj
		},
	},
	"Go(*text.GoTextFace)//language!": {
		Doc:   "Set *text.GoTextFace Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//language!: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//language!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//language!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal language.Tag
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(language.Tag); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//language!: arg 2: " + "expected native of type language.Tag, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//language!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Language = newVal
			return arg0
		},
	},
	"Go(*text.GoTextFace)//language?": {
		Doc:   "Get *text.GoTextFace Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//language?: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//language?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//language?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Language, "Go(language.Tag)")
			return resObj
		},
	},
	"Go(*text.GoTextFace)//metrics": {
		Doc:   "(*text.GoTextFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//metrics: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//metrics: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//metrics: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Metrics)")
			return res0Obj
		},
	},
	"Go(*text.GoTextFace)//remove-feature": {
		Doc:   "(*text.GoTextFace).RemoveFeature",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//remove-feature: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//remove-feature: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//remove-feature: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if vc, ok := arg1.(env.Integer); ok {
						u = uint32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.GoTextFace)//remove-feature: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = text.Tag(u)
				}
			}
			arg0Val.RemoveFeature(arg1Val)
			return arg0
		},
	},
	"Go(*text.GoTextFace)//remove-variation": {
		Doc:   "(*text.GoTextFace).RemoveVariation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//remove-variation: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//remove-variation: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//remove-variation: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if vc, ok := arg1.(env.Integer); ok {
						u = uint32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.GoTextFace)//remove-variation: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = text.Tag(u)
				}
			}
			arg0Val.RemoveVariation(arg1Val)
			return arg0
		},
	},
	"Go(*text.GoTextFace)//script!": {
		Doc:   "Set *text.GoTextFace Script value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//script!: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//script!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//script!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal language.Script
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(language.Script); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//script!: arg 2: " + "expected native of type language.Script, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//script!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Script = newVal
			return arg0
		},
	},
	"Go(*text.GoTextFace)//script?": {
		Doc:   "Get *text.GoTextFace Script value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//script?: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//script?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//script?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Script, "Go(language.Script)")
			return resObj
		},
	},
	"Go(*text.GoTextFace)//set-feature": {
		Doc:   "(*text.GoTextFace).SetFeature",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//set-feature: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//set-feature: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//set-feature: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if vc, ok := arg1.(env.Integer); ok {
						u = uint32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.GoTextFace)//set-feature: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = text.Tag(u)
				}
			}
			var arg2Val uint32
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = uint32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//set-feature: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.SetFeature(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*text.GoTextFace)//set-variation": {
		Doc:   "(*text.GoTextFace).SetVariation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//set-variation: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//set-variation: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//set-variation: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if vc, ok := arg1.(env.Integer); ok {
						u = uint32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.GoTextFace)//set-variation: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = text.Tag(u)
				}
			}
			var arg2Val float32
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//set-variation: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.SetVariation(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*text.GoTextFace)//size!": {
		Doc:   "Set *text.GoTextFace Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//size!: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//size!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//size!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//size!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Size = newVal
			return arg0
		},
	},
	"Go(*text.GoTextFace)//size?": {
		Doc:   "Get *text.GoTextFace Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//size?: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//size?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//size?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Size))
			return resObj
		},
	},
	"Go(*text.GoTextFace)//source!": {
		Doc:   "Set *text.GoTextFace Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//source!: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//source!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//source!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal *text.GoTextFaceSource
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFaceSource); ok {
					newVal = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//source!: arg 2: " + "expected native of type *text.GoTextFaceSource, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//source!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//source!: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			self.Source = newVal
			return arg0
		},
	},
	"Go(*text.GoTextFace)//source?": {
		Doc:   "Get *text.GoTextFace Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFace); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//source?: arg 1: " + "expected native of type *text.GoTextFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFace)//source?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFace)//source?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "Go(*text.GoTextFaceSource)")
			return resObj
		},
	},
	"Go(*text.GoTextFaceSource)//metadata": {
		Doc:   "(*text.GoTextFaceSource).Metadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFaceSource
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFaceSource); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFaceSource)//metadata: arg 1: " + "expected native of type *text.GoTextFaceSource, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFaceSource)//metadata: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFaceSource)//metadata: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Metadata()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Metadata)")
			return res0Obj
		},
	},
	"Go(*text.GoTextFaceSource)//unsafe-internal": {
		Doc:   "(*text.GoTextFaceSource).UnsafeInternal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFaceSource
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoTextFaceSource); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFaceSource)//unsafe-internal: arg 1: " + "expected native of type *text.GoTextFaceSource, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoTextFaceSource)//unsafe-internal: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoTextFaceSource)//unsafe-internal: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.UnsafeInternal()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(typesetting_font.Face)")
			return res0Obj
		},
	},
	"Go(*text.GoXFace)//metrics": {
		Doc:   "(*text.GoXFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoXFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoXFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoXFace)//metrics: arg 1: " + "expected native of type *text.GoXFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoXFace)//metrics: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoXFace)//metrics: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Metrics)")
			return res0Obj
		},
	},
	"Go(*text.GoXFace)//unsafe-internal": {
		Doc:   "(*text.GoXFace).UnsafeInternal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoXFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.GoXFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoXFace)//unsafe-internal: arg 1: " + "expected native of type *text.GoXFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.GoXFace)//unsafe-internal: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.GoXFace)//unsafe-internal: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.UnsafeInternal()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(font.Face)")
			return res0Obj
		},
	},
	"Go(*text.LayoutOptions)//line-spacing!": {
		Doc:   "Set *text.LayoutOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//line-spacing!: arg 1: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//line-spacing!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//line-spacing!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//line-spacing!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.LineSpacing = newVal
			return arg0
		},
	},
	"Go(*text.LayoutOptions)//line-spacing?": {
		Doc:   "Get *text.LayoutOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//line-spacing?: arg 1: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//line-spacing?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//line-spacing?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"Go(*text.LayoutOptions)//primary-align!": {
		Doc:   "Set *text.LayoutOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//primary-align!: arg 1: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//primary-align!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//primary-align!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Align
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.LayoutOptions)//primary-align!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Align(u)
				}
			}
			self.PrimaryAlign = newVal
			return arg0
		},
	},
	"Go(*text.LayoutOptions)//primary-align?": {
		Doc:   "Get *text.LayoutOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//primary-align?: arg 1: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//primary-align?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//primary-align?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"Go(*text.LayoutOptions)//secondary-align!": {
		Doc:   "Set *text.LayoutOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//secondary-align!: arg 1: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//secondary-align!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//secondary-align!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Align
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.LayoutOptions)//secondary-align!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Align(u)
				}
			}
			self.SecondaryAlign = newVal
			return arg0
		},
	},
	"Go(*text.LayoutOptions)//secondary-align?": {
		Doc:   "Get *text.LayoutOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//secondary-align?: arg 1: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LayoutOptions)//secondary-align?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LayoutOptions)//secondary-align?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"Go(*text.LimitedFace)//add-unicode-range": {
		Doc:   "(*text.LimitedFace).AddUnicodeRange",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LimitedFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 1: " + "expected native of type *text.LimitedFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(rune); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 2: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(rune); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 3: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LimitedFace)//add-unicode-range: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.AddUnicodeRange(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*text.LimitedFace)//metrics": {
		Doc:   "(*text.LimitedFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LimitedFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LimitedFace)//metrics: arg 1: " + "expected native of type *text.LimitedFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.LimitedFace)//metrics: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.LimitedFace)//metrics: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Metrics)")
			return res0Obj
		},
	},
	"Go(*text.Metadata)//family!": {
		Doc:   "Set *text.Metadata Family value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//family!: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//family!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//family!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal string
			if vc, ok := arg1.(env.String); ok {
				newVal = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//family!: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Family = newVal
			return arg0
		},
	},
	"Go(*text.Metadata)//family?": {
		Doc:   "Get *text.Metadata Family value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//family?: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//family?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//family?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewString(self.Family)
			return resObj
		},
	},
	"Go(*text.Metadata)//stretch!": {
		Doc:   "Set *text.Metadata Stretch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//stretch!: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//stretch!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//stretch!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Stretch
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Stretch
				if natOk {
					natVal, natValOk = nat.Value.(text.Stretch)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if vc, ok := arg1.(env.Decimal); ok {
						u = float32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Metadata)//stretch!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Stretch(u)
				}
			}
			self.Stretch = newVal
			return arg0
		},
	},
	"Go(*text.Metadata)//stretch?": {
		Doc:   "Get *text.Metadata Stretch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//stretch?: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//stretch?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//stretch?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Stretch)))
			return resObj
		},
	},
	"Go(*text.Metadata)//style!": {
		Doc:   "Set *text.Metadata Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//style!: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//style!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//style!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Style
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Style
				if natOk {
					natVal, natValOk = nat.Value.(text.Style)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if vc, ok := arg1.(env.Integer); ok {
						u = uint8(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Metadata)//style!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Style(u)
				}
			}
			self.Style = newVal
			return arg0
		},
	},
	"Go(*text.Metadata)//style?": {
		Doc:   "Get *text.Metadata Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//style?: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//style?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//style?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Style)))
			return resObj
		},
	},
	"Go(*text.Metadata)//weight!": {
		Doc:   "Set *text.Metadata Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//weight!: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//weight!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//weight!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal text.Weight
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Weight
				if natOk {
					natVal, natValOk = nat.Value.(text.Weight)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if vc, ok := arg1.(env.Decimal); ok {
						u = float32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Metadata)//weight!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = text.Weight(u)
				}
			}
			self.Weight = newVal
			return arg0
		},
	},
	"Go(*text.Metadata)//weight?": {
		Doc:   "Get *text.Metadata Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metadata); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//weight?: arg 1: " + "expected native of type *text.Metadata, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metadata)//weight?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metadata)//weight?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Weight)))
			return resObj
		},
	},
	"Go(*text.Metrics)//h-ascent!": {
		Doc:   "Set *text.Metrics HAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-ascent!: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-ascent!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-ascent!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-ascent!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.HAscent = newVal
			return arg0
		},
	},
	"Go(*text.Metrics)//h-ascent?": {
		Doc:   "Get *text.Metrics HAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-ascent?: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-ascent?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-ascent?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HAscent))
			return resObj
		},
	},
	"Go(*text.Metrics)//h-descent!": {
		Doc:   "Set *text.Metrics HDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-descent!: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-descent!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-descent!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-descent!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.HDescent = newVal
			return arg0
		},
	},
	"Go(*text.Metrics)//h-descent?": {
		Doc:   "Get *text.Metrics HDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-descent?: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-descent?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-descent?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HDescent))
			return resObj
		},
	},
	"Go(*text.Metrics)//h-line-gap!": {
		Doc:   "Set *text.Metrics HLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-line-gap!: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-line-gap!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-line-gap!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-line-gap!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.HLineGap = newVal
			return arg0
		},
	},
	"Go(*text.Metrics)//h-line-gap?": {
		Doc:   "Get *text.Metrics HLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-line-gap?: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//h-line-gap?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//h-line-gap?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HLineGap))
			return resObj
		},
	},
	"Go(*text.Metrics)//v-ascent!": {
		Doc:   "Set *text.Metrics VAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-ascent!: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-ascent!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-ascent!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-ascent!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.VAscent = newVal
			return arg0
		},
	},
	"Go(*text.Metrics)//v-ascent?": {
		Doc:   "Get *text.Metrics VAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-ascent?: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-ascent?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-ascent?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VAscent))
			return resObj
		},
	},
	"Go(*text.Metrics)//v-descent!": {
		Doc:   "Set *text.Metrics VDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-descent!: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-descent!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-descent!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-descent!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.VDescent = newVal
			return arg0
		},
	},
	"Go(*text.Metrics)//v-descent?": {
		Doc:   "Get *text.Metrics VDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-descent?: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-descent?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-descent?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VDescent))
			return resObj
		},
	},
	"Go(*text.Metrics)//v-line-gap!": {
		Doc:   "Set *text.Metrics VLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-line-gap!: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-line-gap!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-line-gap!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float64
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-line-gap!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.VLineGap = newVal
			return arg0
		},
	},
	"Go(*text.Metrics)//v-line-gap?": {
		Doc:   "Get *text.Metrics VLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.Metrics); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-line-gap?: arg 1: " + "expected native of type *text.Metrics, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Metrics)//v-line-gap?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Metrics)//v-line-gap?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VLineGap))
			return resObj
		},
	},
	"Go(*text.MultiFace)//metrics": {
		Doc:   "(*text.MultiFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.MultiFace
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.MultiFace); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*text.MultiFace)//metrics: arg 1: " + "expected native of type *text.MultiFace, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.MultiFace)//metrics: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.MultiFace)//metrics: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Metrics)")
			return res0Obj
		},
	},
	"Go(*textinput.Field)//blur": {
		Doc:   "(*textinput.Field).Blur",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//blur: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//blur: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//blur: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Blur()
			return arg0
		},
	},
	"Go(*textinput.Field)//composition-selection": {
		Doc:   "(*textinput.Field).CompositionSelection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//composition-selection: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//composition-selection: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//composition-selection: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2 := arg0Val.CompositionSelection()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(boolToInt64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"Go(*textinput.Field)//focus": {
		Doc:   "(*textinput.Field).Focus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//focus: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//focus: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//focus: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Focus()
			return arg0
		},
	},
	"Go(*textinput.Field)//handle-input": {
		Doc:   "(*textinput.Field).HandleInput",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//handle-input: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//handle-input: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//handle-input: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//handle-input: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//handle-input: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.HandleInput(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*textinput.Field)//is-focused": {
		Doc:   "(*textinput.Field).IsFocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//is-focused: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//is-focused: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//is-focused: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsFocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*textinput.Field)//selection": {
		Doc:   "(*textinput.Field).Selection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//selection: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//selection: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//selection: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.Selection()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*textinput.Field)//set-selection": {
		Doc:   "(*textinput.Field).SetSelection",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//set-selection: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//set-selection: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-selection: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-selection: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-selection: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.SetSelection(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*textinput.Field)//set-text-and-selection": {
		Doc:   "(*textinput.Field).SetTextAndSelection",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//set-text-and-selection: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//set-text-and-selection: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-text-and-selection: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-text-and-selection: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-text-and-selection: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//set-text-and-selection: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			arg0Val.SetTextAndSelection(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*textinput.Field)//text": {
		Doc:   "(*textinput.Field).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//text: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//text: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//text: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*textinput.Field)//text-for-rendering": {
		Doc:   "(*textinput.Field).TextForRendering",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.Field); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//text-for-rendering: arg 1: " + "expected native of type *textinput.Field, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.Field)//text-for-rendering: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.Field)//text-for-rendering: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.TextForRendering()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*textinput.State)//committed!": {
		Doc:   "Set *textinput.State Committed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//committed!: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//committed!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//committed!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal bool
			if vc, ok := arg1.(env.Integer); ok {
				newVal = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//committed!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Committed = newVal
			return arg0
		},
	},
	"Go(*textinput.State)//committed?": {
		Doc:   "Get *textinput.State Committed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//committed?: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//committed?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//committed?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Committed))
			return resObj
		},
	},
	"Go(*textinput.State)//composition-selection-end-in-bytes!": {
		Doc:   "Set *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes!: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.CompositionSelectionEndInBytes = newVal
			return arg0
		},
	},
	"Go(*textinput.State)//composition-selection-end-in-bytes?": {
		Doc:   "Get *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes?: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//composition-selection-end-in-bytes?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionEndInBytes))
			return resObj
		},
	},
	"Go(*textinput.State)//composition-selection-start-in-bytes!": {
		Doc:   "Set *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes!: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal int
			if vc, ok := arg1.(env.Integer); ok {
				newVal = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.CompositionSelectionStartInBytes = newVal
			return arg0
		},
	},
	"Go(*textinput.State)//composition-selection-start-in-bytes?": {
		Doc:   "Get *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes?: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//composition-selection-start-in-bytes?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionStartInBytes))
			return resObj
		},
	},
	"Go(*textinput.State)//error!": {
		Doc:   "Set *textinput.State Error value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//error!: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//error!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//error!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal error
			switch v := arg1.(type) {
			case env.String:
				newVal = errors.New(v.Value)
			case env.Error:
				newVal = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//error!: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//error!: arg 2: " + "expected error, string or nil, but got " + objectDebugString(ps.Idx, v))
			}
			self.Error = newVal
			return arg0
		},
	},
	"Go(*textinput.State)//error?": {
		Doc:   "Get *textinput.State Error value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//error?: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//error?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//error?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			if self.Error != nil {
				resObj = env.NewError(self.Error.Error())
			}
			return resObj
		},
	},
	"Go(*textinput.State)//text!": {
		Doc:   "Set *textinput.State Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//text!: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//text!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//text!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal string
			if vc, ok := arg1.(env.String); ok {
				newVal = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//text!: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*textinput.State)//text?": {
		Doc:   "Get *textinput.State Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*textinput.State); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//text?: arg 1: " + "expected native of type *textinput.State, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*textinput.State)//text?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*textinput.State)//text?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*twenty48.Board)//draw": {
		Doc:   "(*twenty48.Board).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Board); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//draw: arg 1: " + "expected native of type *twenty48.Board, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Board)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Board)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*twenty48.Board)//move": {
		Doc:   "(*twenty48.Board).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Board); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//move: arg 1: " + "expected native of type *twenty48.Board, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//move: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Board)//move: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val twenty48.Dir
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*twenty48.Board)//move: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = twenty48.Dir(u)
				}
			}
			resErr := arg0Val.Move(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*twenty48.Board)//size": {
		Doc:   "(*twenty48.Board).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Board); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//size: arg 1: " + "expected native of type *twenty48.Board, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//size: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Board)//size: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*twenty48.Board)//update": {
		Doc:   "(*twenty48.Board).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Board); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//update: arg 1: " + "expected native of type *twenty48.Board, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Board)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *twenty48.Input
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Input); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//update: arg 2: " + "expected native of type *twenty48.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Board)//update: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Board)//update: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*twenty48.Game)//draw": {
		Doc:   "(*twenty48.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//draw: arg 1: " + "expected native of type *twenty48.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Game)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Game)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*twenty48.Game)//layout": {
		Doc:   "(*twenty48.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//layout: arg 1: " + "expected native of type *twenty48.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//layout: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Game)//layout: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Game)//layout: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Game)//layout: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*twenty48.Game)//update": {
		Doc:   "(*twenty48.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//update: arg 1: " + "expected native of type *twenty48.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Game)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Game)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*twenty48.Input)//dir": {
		Doc:   "(*twenty48.Input).Dir",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Input)//dir: arg 1: " + "expected native of type *twenty48.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Input)//dir: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Input)//dir: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.Dir()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*twenty48.Input)//update": {
		Doc:   "(*twenty48.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Input); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Input)//update: arg 1: " + "expected native of type *twenty48.Input, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Input)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Input)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Update()
			return arg0
		},
	},
	"Go(*twenty48.Tile)//draw": {
		Doc:   "(*twenty48.Tile).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//draw: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(*twenty48.Tile)//is-moving": {
		Doc:   "(*twenty48.Tile).IsMoving",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//is-moving: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//is-moving: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//is-moving: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.IsMoving()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*twenty48.Tile)//next-pos": {
		Doc:   "(*twenty48.Tile).NextPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//next-pos: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//next-pos: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//next-pos: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.NextPos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*twenty48.Tile)//next-value": {
		Doc:   "(*twenty48.Tile).NextValue",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//next-value: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//next-value: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//next-value: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.NextValue()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*twenty48.Tile)//pos": {
		Doc:   "(*twenty48.Tile).Pos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//pos: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//pos: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//pos: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.Pos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*twenty48.Tile)//update": {
		Doc:   "(*twenty48.Tile).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//update: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*twenty48.Tile)//value": {
		Doc:   "(*twenty48.Tile).Value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*twenty48.Tile); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//value: arg 1: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*twenty48.Tile)//value: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*twenty48.Tile)//value: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Value()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*vector.Path)//append-vertices-and-indices-for-filling": {
		Doc:   "(*vector.Path).AppendVerticesAndIndicesForFilling",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.Vertex); ok {
							arg1Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 2: " + "block item: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 3: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-filling: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForFilling(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, &it, "Go(*ebiten.Vertex)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*vector.Path)//append-vertices-and-indices-for-stroke": {
		Doc:   "(*vector.Path).AppendVerticesAndIndicesForStroke",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.Vertex); ok {
							arg1Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 2: " + "block item: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 3: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *vector.StrokeOptions
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 4: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//append-vertices-and-indices-for-stroke: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForStroke(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, &it, "Go(*ebiten.Vertex)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*vector.Path)//close": {
		Doc:   "(*vector.Path).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//close: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//close: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//close: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Close()
			return arg0
		},
	},
	"Go(*vector.Path)//line-to": {
		Doc:   "(*vector.Path).LineTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//line-to: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//line-to: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//line-to: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//line-to: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float32
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//line-to: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.LineTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*vector.Path)//move-to": {
		Doc:   "(*vector.Path).MoveTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//move-to: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//move-to: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//move-to: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//move-to: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float32
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//move-to: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			arg0Val.MoveTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*vector.Path)//quad-to": {
		Doc:   "(*vector.Path).QuadTo",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//quad-to: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.Path)//quad-to: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//quad-to: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float32
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//quad-to: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float32
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//quad-to: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float32
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//quad-to: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val float32
			if vc, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.Path)//quad-to: arg 5: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg4))
			}
			arg0Val.QuadTo(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*vector.StrokeOptions)//line-cap!": {
		Doc:   "Set *vector.StrokeOptions LineCap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-cap!: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-cap!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//line-cap!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal vector.LineCap
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineCap
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineCap)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*vector.StrokeOptions)//line-cap!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = vector.LineCap(u)
				}
			}
			self.LineCap = newVal
			return arg0
		},
	},
	"Go(*vector.StrokeOptions)//line-cap?": {
		Doc:   "Get *vector.StrokeOptions LineCap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-cap?: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-cap?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//line-cap?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineCap)))
			return resObj
		},
	},
	"Go(*vector.StrokeOptions)//line-join!": {
		Doc:   "Set *vector.StrokeOptions LineJoin value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-join!: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-join!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//line-join!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal vector.LineJoin
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineJoin
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineJoin)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*vector.StrokeOptions)//line-join!: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					newVal = vector.LineJoin(u)
				}
			}
			self.LineJoin = newVal
			return arg0
		},
	},
	"Go(*vector.StrokeOptions)//line-join?": {
		Doc:   "Get *vector.StrokeOptions LineJoin value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-join?: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//line-join?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//line-join?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineJoin)))
			return resObj
		},
	},
	"Go(*vector.StrokeOptions)//miter-limit!": {
		Doc:   "Set *vector.StrokeOptions MiterLimit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//miter-limit!: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//miter-limit!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//miter-limit!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//miter-limit!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.MiterLimit = newVal
			return arg0
		},
	},
	"Go(*vector.StrokeOptions)//miter-limit?": {
		Doc:   "Get *vector.StrokeOptions MiterLimit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//miter-limit?: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//miter-limit?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//miter-limit?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.MiterLimit))
			return resObj
		},
	},
	"Go(*vector.StrokeOptions)//width!": {
		Doc:   "Set *vector.StrokeOptions Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//width!: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//width!: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//width!: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var newVal float32
			if vc, ok := arg1.(env.Decimal); ok {
				newVal = float32(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//width!: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			self.Width = newVal
			return arg0
		},
	},
	"Go(*vector.StrokeOptions)//width?": {
		Doc:   "Get *vector.StrokeOptions Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.StrokeOptions); ok {
					self = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//width?: arg 1: " + "expected native of type *vector.StrokeOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vector.StrokeOptions)//width?: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vector.StrokeOptions)//width?: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"Go(*vorbis.Stream)//length": {
		Doc:   "(*vorbis.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vorbis.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//length: arg 1: " + "expected native of type *vorbis.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//length: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vorbis.Stream)//length: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*vorbis.Stream)//read": {
		Doc:   "(*vorbis.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vorbis.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//read: arg 1: " + "expected native of type *vorbis.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vorbis.Stream)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*vorbis.Stream)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*vorbis.Stream)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vorbis.Stream)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*vorbis.Stream)//seek": {
		Doc:   "(*vorbis.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vorbis.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//seek: arg 1: " + "expected native of type *vorbis.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*vorbis.Stream)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*vorbis.Stream)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vorbis.Stream)//seek: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*vorbis.Stream)//seek: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*wav.Stream)//length": {
		Doc:   "(*wav.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*wav.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//length: arg 1: " + "expected native of type *wav.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//length: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*wav.Stream)//length: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*wav.Stream)//read": {
		Doc:   "(*wav.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*wav.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//read: arg 1: " + "expected native of type *wav.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*wav.Stream)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(*wav.Stream)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*wav.Stream)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*wav.Stream)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*wav.Stream)//seek": {
		Doc:   "(*wav.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*wav.Stream); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//seek: arg 1: " + "expected native of type *wav.Stream, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*wav.Stream)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*wav.Stream)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*wav.Stream)//seek: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*wav.Stream)//seek: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(blocks.Angle)//rotate-left": {
		Doc:   "blocks.Angle.RotateLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(blocks.Angle)//rotate-left: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"Go(blocks.Angle)//rotate-right": {
		Doc:   "blocks.Angle.RotateRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(blocks.Angle)//rotate-right: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"Go(blocks.Scene)//draw": {
		Doc:   "blocks.Scene.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_blocks_Scene(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//draw: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(blocks.Scene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//draw: arg 1: " + "expected native of type blocks.Scene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(blocks.Scene)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(blocks.Scene)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(blocks.Scene)//update": {
		Doc:   "blocks.Scene.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_blocks_Scene(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//update: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(blocks.Scene); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//update: arg 1: " + "expected native of type blocks.Scene, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(blocks.Scene)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*blocks.GameState); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//update: arg 2: " + "expected native of type *blocks.GameState, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(blocks.Scene)//update: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(blocks.Scene)//update: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(color.Color)//rgba": {
		Doc:   "color.Color.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(color.Color)//rgba: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(color.Color)//rgba: arg 1: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(color.Color)//rgba: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(color.Color)//rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"Go(color.Model)//convert": {
		Doc:   "color.Model.Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Model
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(color.Model)//convert: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Model); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(color.Model)//convert: arg 1: " + "expected native of type color.Model, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(color.Model)//convert: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(color.Model)//convert: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(color.Model)//convert: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(color.Model)//convert: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(color.Model)//convert: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(color.Model)//convert: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(color.Palette)//convert": {
		Doc:   "color.Palette.Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Palette
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u []color.Color
					switch v := arg0.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("Go(color.Palette)//convert: arg 1: " + "block item: " + err.Error())
								}
							case env.Native:
								if vc, ok := v.Value.(color.Color); ok {
									u[i] = vc
								} else {
									ps.FailureFlag = true
									return env.NewError("Go(color.Palette)//convert: arg 1: " + "block item: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("Go(color.Palette)//convert: arg 1: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("Go(color.Palette)//convert: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(color.Palette)//convert: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(color.Palette)//convert: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
					}
					arg0Val = color.Palette(u)
				}
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(color.Palette)//convert: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(color.Palette)//convert: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(color.Palette)//convert: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(color.Palette)//convert: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(color.Palette)//index": {
		Doc:   "color.Palette.Index",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Palette
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u []color.Color
					switch v := arg0.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("Go(color.Palette)//index: arg 1: " + "block item: " + err.Error())
								}
							case env.Native:
								if vc, ok := v.Value.(color.Color); ok {
									u[i] = vc
								} else {
									ps.FailureFlag = true
									return env.NewError("Go(color.Palette)//index: arg 1: " + "block item: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("Go(color.Palette)//index: arg 1: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("Go(color.Palette)//index: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(color.Palette)//index: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(color.Palette)//index: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
					}
					arg0Val = color.Palette(u)
				}
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(color.Palette)//index: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(color.Palette)//index: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(color.Palette)//index: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(color.Palette)//index: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Index(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(draw.Drawer)//draw": {
		Doc:   "draw.Drawer.Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Drawer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Drawer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Drawer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 1: " + "expected native of type draw.Drawer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Drawer)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val draw.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 2: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Drawer)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val image.Rectangle
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg2Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 3: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Drawer)//draw: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val image.Image
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 4: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Drawer)//draw: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val image.Point
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg4Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Drawer)//draw: arg 5: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Drawer)//draw: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(draw.Image)//at": {
		Doc:   "draw.Image.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//at: arg 1: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(draw.Image)//bounds": {
		Doc:   "draw.Image.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//bounds: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//bounds: arg 1: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(draw.Image)//color-model": {
		Doc:   "draw.Image.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//color-model: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//color-model: arg 1: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(draw.Image)//set": {
		Doc:   "draw.Image.Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//set: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//set: arg 1: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Image)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Image)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(draw.Op)//draw": {
		Doc:   "draw.Op.Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Op
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal draw.Op
				if natOk {
					natVal, natValOk = nat.Value.(draw.Op)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(draw.Op)//draw: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = draw.Op(u)
				}
			}
			var arg1Val draw.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 2: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Op)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val image.Rectangle
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg2Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 3: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Op)//draw: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val image.Image
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 4: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Op)//draw: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val image.Point
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg4Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Op)//draw: arg 5: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Op)//draw: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(draw.Quantizer)//quantize": {
		Doc:   "draw.Quantizer.Quantize",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Quantizer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Quantizer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Quantizer)//quantize: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Quantizer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Quantizer)//quantize: arg 1: " + "expected native of type draw.Quantizer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Quantizer)//quantize: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Quantizer)//quantize: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Palette
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u []color.Color
					switch v := arg1.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("Go(draw.Quantizer)//quantize: arg 2: " + "block item: " + err.Error())
								}
							case env.Native:
								if vc, ok := v.Value.(color.Color); ok {
									u[i] = vc
								} else {
									ps.FailureFlag = true
									return env.NewError("Go(draw.Quantizer)//quantize: arg 2: " + "block item: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("Go(draw.Quantizer)//quantize: arg 2: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("Go(draw.Quantizer)//quantize: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(draw.Quantizer)//quantize: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(draw.Quantizer)//quantize: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
					}
					arg1Val = color.Palette(u)
				}
			}
			var arg2Val image.Image
			switch v := arg2.(type) {
			case env.RyeCtx:
				var err error
				arg2Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Quantizer)//quantize: arg 3: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Quantizer)//quantize: arg 3: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.Quantizer)//quantize: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.Quantizer)//quantize: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Quantize(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len([]color.Color(res0)))
				for i, it := range []color.Color(res0) {
					items[i] = ifaceToNative(ps.Idx, it, "Go(color.Color)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(draw.RGBA64Image)//at": {
		Doc:   "draw.RGBA64Image.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//at: arg 1: " + "expected native of type draw.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(draw.RGBA64Image)//bounds": {
		Doc:   "draw.RGBA64Image.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//bounds: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//bounds: arg 1: " + "expected native of type draw.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(draw.RGBA64Image)//color-model": {
		Doc:   "draw.RGBA64Image.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//color-model: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//color-model: arg 1: " + "expected native of type draw.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(draw.RGBA64Image)//rgba-64-at": {
		Doc:   "draw.RGBA64Image.RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//rgba-64-at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//rgba-64-at: arg 1: " + "expected native of type draw.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(draw.RGBA64Image)//set": {
		Doc:   "draw.RGBA64Image.Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set: arg 1: " + "expected native of type draw.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set: arg 4: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set: arg 4: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(draw.RGBA64Image)//set-rgba-64": {
		Doc:   "draw.RGBA64Image.SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 1: " + "expected native of type draw.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*color.RGBA64); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 4: " + "expected native of type *color.RGBA64, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(draw.RGBA64Image)//set-rgba-64: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(ebiten.FinalScreen)//bounds": {
		Doc:   "ebiten.FinalScreen.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//bounds: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(ebiten.FinalScreen)//clear": {
		Doc:   "ebiten.FinalScreen.Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//clear: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//clear: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//clear: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"Go(ebiten.FinalScreen)//draw-image": {
		Doc:   "ebiten.FinalScreen.DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 3: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-image: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(ebiten.FinalScreen)//draw-rect-shader": {
		Doc:   "ebiten.FinalScreen.DrawRectShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Shader); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 4: " + "expected native of type *ebiten.Shader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val *ebiten.DrawRectShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawRectShaderOptions); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 5: " + "expected native of type *ebiten.DrawRectShaderOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-rect-shader: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawRectShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(ebiten.FinalScreen)//draw-triangles": {
		Doc:   "ebiten.FinalScreen.DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.Vertex); ok {
							arg1Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 2: " + "block item: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 3: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 4: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesOptions); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 5: " + "expected native of type *ebiten.DrawTrianglesOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(ebiten.FinalScreen)//draw-triangles-shader": {
		Doc:   "ebiten.FinalScreen.DrawTrianglesShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.Vertex); ok {
							arg1Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 2: " + "block item: " + "expected native of type *ebiten.Vertex, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if vc, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 3: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Shader); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 4: " + "expected native of type *ebiten.Shader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val *ebiten.DrawTrianglesShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawTrianglesShaderOptions); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 5: " + "expected native of type *ebiten.DrawTrianglesShaderOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//draw-triangles-shader: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawTrianglesShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(ebiten.FinalScreen)//fill": {
		Doc:   "ebiten.FinalScreen.Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//fill: arg 1: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//fill: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//fill: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//fill: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//fill: arg 2: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreen)//fill: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreen)//fill: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"Go(ebiten.FinalScreenDrawer)//draw-final-screen": {
		Doc:   "ebiten.FinalScreenDrawer.DrawFinalScreen",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreenDrawer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_FinalScreenDrawer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreenDrawer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 1: " + "expected native of type ebiten.FinalScreenDrawer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.FinalScreen
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FinalScreen); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 2: " + "expected native of type ebiten.FinalScreen, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val *ebiten.Image
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 3: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val ebiten.GeoM
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.GeoM); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 4: " + "expected native of type *ebiten.GeoM, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.FinalScreenDrawer)//draw-final-screen: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.DrawFinalScreen(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(ebiten.Game)//draw": {
		Doc:   "ebiten.Game.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//draw: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//draw: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.Game)//draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//draw: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//draw: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.Game)//draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"Go(ebiten.Game)//layout": {
		Doc:   "ebiten.Game.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//layout: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//layout: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//layout: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.Game)//layout: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.Game)//layout: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.Game)//layout: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(ebiten.Game)//update": {
		Doc:   "ebiten.Game.Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//update: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//update: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.Game)//update: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.Game)//update: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(ebiten.GraphicsLibrary)//string": {
		Doc:   "ebiten.GraphicsLibrary.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GraphicsLibrary
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.GraphicsLibrary)//string: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.GraphicsLibrary(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(ebiten.Key)//marshal-text": {
		Doc:   "ebiten.Key.MarshalText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.Key)//marshal-text: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, resErr := arg0Val.MarshalText()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(ebiten.Key)//string": {
		Doc:   "ebiten.Key.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(ebiten.Key)//string: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(ebiten.LayoutFer)//layout-f": {
		Doc:   "ebiten.LayoutFer.LayoutF",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.LayoutFer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_LayoutFer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.LayoutFer)//layout-f: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.LayoutFer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.LayoutFer)//layout-f: arg 1: " + "expected native of type ebiten.LayoutFer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebiten.LayoutFer)//layout-f: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.LayoutFer)//layout-f: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.LayoutFer)//layout-f: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebiten.LayoutFer)//layout-f: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1 := arg0Val.LayoutF(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(ebitenutil.ReadSeekCloser)//close": {
		Doc:   "ebitenutil.ReadSeekCloser.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebitenutil.ReadSeekCloser
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebitenutil_ReadSeekCloser(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//close: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebitenutil.ReadSeekCloser); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//close: arg 1: " + "expected native of type ebitenutil.ReadSeekCloser, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//close: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebitenutil.ReadSeekCloser)//close: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := arg0Val.Close()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(ebitenutil.ReadSeekCloser)//read": {
		Doc:   "ebitenutil.ReadSeekCloser.Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebitenutil.ReadSeekCloser
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebitenutil_ReadSeekCloser(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebitenutil.ReadSeekCloser); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 1: " + "expected native of type ebitenutil.ReadSeekCloser, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebitenutil.ReadSeekCloser)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(ebitenutil.ReadSeekCloser)//seek": {
		Doc:   "ebitenutil.ReadSeekCloser.Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebitenutil.ReadSeekCloser
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebitenutil_ReadSeekCloser(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//seek: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebitenutil.ReadSeekCloser); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//seek: arg 1: " + "expected native of type ebitenutil.ReadSeekCloser, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(ebitenutil.ReadSeekCloser)//seek: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(ebitenutil.ReadSeekCloser)//seek: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebitenutil.ReadSeekCloser)//seek: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(ebitenutil.ReadSeekCloser)//seek: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(image.Image)//at": {
		Doc:   "image.Image.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//at: arg 1: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.Image)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.Image)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.Image)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(image.Image)//bounds": {
		Doc:   "image.Image.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//bounds: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//bounds: arg 1: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.Image)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(image.Image)//color-model": {
		Doc:   "image.Image.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//color-model: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//color-model: arg 1: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.Image)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.Image)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(image.PalettedImage)//at": {
		Doc:   "image.PalettedImage.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.PalettedImage
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_PalettedImage(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.PalettedImage); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//at: arg 1: " + "expected native of type image.PalettedImage, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(image.PalettedImage)//bounds": {
		Doc:   "image.PalettedImage.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.PalettedImage
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_PalettedImage(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//bounds: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.PalettedImage); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//bounds: arg 1: " + "expected native of type image.PalettedImage, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(image.PalettedImage)//color-index-at": {
		Doc:   "image.PalettedImage.ColorIndexAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.PalettedImage
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_PalettedImage(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//color-index-at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.PalettedImage); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//color-index-at: arg 1: " + "expected native of type image.PalettedImage, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//color-index-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//color-index-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//color-index-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//color-index-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.ColorIndexAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(image.PalettedImage)//color-model": {
		Doc:   "image.PalettedImage.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.PalettedImage
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_PalettedImage(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//color-model: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.PalettedImage); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//color-model: arg 1: " + "expected native of type image.PalettedImage, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.PalettedImage)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.PalettedImage)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(image.RGBA64Image)//at": {
		Doc:   "image.RGBA64Image.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//at: arg 1: " + "expected native of type image.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Color)")
			return res0Obj
		},
	},
	"Go(image.RGBA64Image)//bounds": {
		Doc:   "image.RGBA64Image.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//bounds: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//bounds: arg 1: " + "expected native of type image.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//bounds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//bounds: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"Go(image.RGBA64Image)//color-model": {
		Doc:   "image.RGBA64Image.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//color-model: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//color-model: arg 1: " + "expected native of type image.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//color-model: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//color-model: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"Go(image.RGBA64Image)//rgba-64-at": {
		Doc:   "image.RGBA64Image.RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//rgba-64-at: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.RGBA64Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//rgba-64-at: arg 1: " + "expected native of type image.RGBA64Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(image.RGBA64Image)//rgba-64-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//rgba-64-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//rgba-64-at: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(image.RGBA64Image)//rgba-64-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*color.RGBA64)")
			return res0Obj
		},
	},
	"Go(image.YCbCrSubsampleRatio)//string": {
		Doc:   "image.YCbCrSubsampleRatio.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.YCbCrSubsampleRatio
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(image.YCbCrSubsampleRatio)//string: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = image.YCbCrSubsampleRatio(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(jpeg.FormatError)//error": {
		Doc:   "jpeg.FormatError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val jpeg.FormatError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal jpeg.FormatError
				if natOk {
					natVal, natValOk = nat.Value.(jpeg.FormatError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if vc, ok := arg0.(env.String); ok {
						u = string(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(jpeg.FormatError)//error: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = jpeg.FormatError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(jpeg.Reader)//read": {
		Doc:   "jpeg.Reader.Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val jpeg.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_jpeg_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(jpeg.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read: arg 1: " + "expected native of type jpeg.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(jpeg.Reader)//read: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("Go(jpeg.Reader)//read: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(jpeg.Reader)//read: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(jpeg.Reader)//read: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(jpeg.Reader)//read-byte": {
		Doc:   "jpeg.Reader.ReadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val jpeg.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_jpeg_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read-byte: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(jpeg.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read-byte: arg 1: " + "expected native of type jpeg.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(jpeg.Reader)//read-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(jpeg.Reader)//read-byte: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := arg0Val.ReadByte()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(byte)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(jpeg.UnsupportedError)//error": {
		Doc:   "jpeg.UnsupportedError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val jpeg.UnsupportedError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal jpeg.UnsupportedError
				if natOk {
					natVal, natValOk = nat.Value.(jpeg.UnsupportedError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if vc, ok := arg0.(env.String); ok {
						u = string(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(jpeg.UnsupportedError)//error: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = jpeg.UnsupportedError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(png.EncoderBufferPool)//get": {
		Doc:   "png.EncoderBufferPool.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.EncoderBufferPool
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_png_EncoderBufferPool(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//get: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(png.EncoderBufferPool); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//get: arg 1: " + "expected native of type png.EncoderBufferPool, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//get: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(png.EncoderBufferPool)//get: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*png.EncoderBuffer)")
			return res0Obj
		},
	},
	"Go(png.EncoderBufferPool)//put": {
		Doc:   "png.EncoderBufferPool.Put",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.EncoderBufferPool
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_png_EncoderBufferPool(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//put: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(png.EncoderBufferPool); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//put: arg 1: " + "expected native of type png.EncoderBufferPool, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//put: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(png.EncoderBufferPool)//put: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *png.EncoderBuffer
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*png.EncoderBuffer); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//put: arg 2: " + "expected native of type *png.EncoderBuffer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(png.EncoderBufferPool)//put: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(png.EncoderBufferPool)//put: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			arg0Val.Put(arg1Val)
			return arg0
		},
	},
	"Go(png.FormatError)//error": {
		Doc:   "png.FormatError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.FormatError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal png.FormatError
				if natOk {
					natVal, natValOk = nat.Value.(png.FormatError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if vc, ok := arg0.(env.String); ok {
						u = string(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(png.FormatError)//error: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = png.FormatError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(png.UnsupportedError)//error": {
		Doc:   "png.UnsupportedError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.UnsupportedError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal png.UnsupportedError
				if natOk {
					natVal, natValOk = nat.Value.(png.UnsupportedError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if vc, ok := arg0.(env.String); ok {
						u = string(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(png.UnsupportedError)//error: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = png.UnsupportedError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(text.Face)//metrics": {
		Doc:   "text.Face.Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Face
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("Go(text.Face)//metrics: arg 1: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(text.Face)//metrics: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(text.Face)//metrics: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Metrics)")
			return res0Obj
		},
	},
	"Go(text.Tag)//string": {
		Doc:   "text.Tag.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Tag
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint32
					if vc, ok := arg0.(env.Integer); ok {
						u = uint32(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(text.Tag)//string: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = text.Tag(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(twenty48.Dir)//string": {
		Doc:   "twenty48.Dir.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(twenty48.Dir)//string: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(twenty48.Dir)//vector": {
		Doc:   "twenty48.Dir.Vector",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(twenty48.Dir)//vector: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0, res1 := arg0Val.Vector()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"audio-current-context": {
		Doc:   "audio.CurrentContext",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := audio.CurrentContext()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.Context)")
			return res0Obj
		},
	},
	"audio-context": {
		Doc:   "audio.NewContext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-context: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0 := audio.NewContext(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.Context)")
			return res0Obj
		},
	},
	"audio-infinite-loop": {
		Doc:   "audio.NewInfiniteLoop",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ReadSeeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.ReadSeeker); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: " + "expected native of type io.ReadSeeker, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := audio.NewInfiniteLoop(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.InfiniteLoop)")
			return res0Obj
		},
	},
	"audio-infinite-loop-with-intro": {
		Doc:   "audio.NewInfiniteLoopWithIntro",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ReadSeeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.ReadSeeker); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: " + "expected native of type io.ReadSeeker, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int64
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := audio.NewInfiniteLoopWithIntro(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.InfiniteLoop)")
			return res0Obj
		},
	},
	"audio-player": {
		Doc:   "audio.NewPlayer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := audio.NewPlayer(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.Player)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"audio-player-from-bytes": {
		Doc:   "audio.NewPlayerFromBytes",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player-from-bytes: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("audio-player-from-bytes: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("audio-player-from-bytes: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player-from-bytes: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := audio.NewPlayerFromBytes(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*audio.Player)")
			return res0Obj
		},
	},
	"audio-resample": {
		Doc:   "audio.Resample",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ReadSeeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-resample: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.ReadSeeker); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("audio-resample: arg 1: " + "expected native of type io.ReadSeeker, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-resample: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int64
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			res0 := audio.Resample(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(io.ReadSeeker)")
			return res0Obj
		},
	},
	"blend-dest-png": {
		Doc:   "Get blend.Dest_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Dest_png))
				for i, it := range blend.Dest_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blend-source-png": {
		Doc:   "Get blend.Source_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Source_png))
				for i, it := range blend.Source_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-angle-0": {
		Doc:   "Get blocks.Angle0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle0)))
			return resObj
		},
	},
	"blocks-angle-180": {
		Doc:   "Get blocks.Angle180 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle180)))
			return resObj
		},
	},
	"blocks-angle-270": {
		Doc:   "Get blocks.Angle270 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle270)))
			return resObj
		},
	},
	"blocks-angle-90": {
		Doc:   "Get blocks.Angle90 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle90)))
			return resObj
		},
	},
	"blocks-block-type-1": {
		Doc:   "Get blocks.BlockType1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType1)))
			return resObj
		},
	},
	"blocks-block-type-2": {
		Doc:   "Get blocks.BlockType2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType2)))
			return resObj
		},
	},
	"blocks-block-type-3": {
		Doc:   "Get blocks.BlockType3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType3)))
			return resObj
		},
	},
	"blocks-block-type-4": {
		Doc:   "Get blocks.BlockType4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType4)))
			return resObj
		},
	},
	"blocks-block-type-5": {
		Doc:   "Get blocks.BlockType5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType5)))
			return resObj
		},
	},
	"blocks-block-type-6": {
		Doc:   "Get blocks.BlockType6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType6)))
			return resObj
		},
	},
	"blocks-block-type-7": {
		Doc:   "Get blocks.BlockType7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType7)))
			return resObj
		},
	},
	"blocks-block-type-max": {
		Doc:   "Get blocks.BlockTypeMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeMax)))
			return resObj
		},
	},
	"blocks-block-type-none": {
		Doc:   "Get blocks.BlockTypeNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeNone)))
			return resObj
		},
	},
	"blocks-field": {
		Doc:   "Create a new blocks.Field struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Field{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.Field)")
			return resObj
		},
	},
	"blocks-game": {
		Doc:   "Create a new blocks.Game struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Game{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.Game)")
			return resObj
		},
	},
	"blocks-game-scene": {
		Doc:   "blocks.NewGameScene",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := blocks.NewGameScene()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*blocks.GameScene)")
			return res0Obj
		},
	},
	"blocks-game-state": {
		Doc:   "Create a new blocks.GameState struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.GameState{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.GameState)")
			return resObj
		},
	},
	"blocks-gamepad-scene": {
		Doc:   "Create a new blocks.GamepadScene struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.GamepadScene{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.GamepadScene)")
			return resObj
		},
	},
	"blocks-input": {
		Doc:   "Create a new blocks.Input struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Input{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.Input)")
			return resObj
		},
	},
	"blocks-piece": {
		Doc:   "Create a new blocks.Piece struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Piece{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.Piece)")
			return resObj
		},
	},
	"blocks-scene-manager": {
		Doc:   "Create a new blocks.SceneManager struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.SceneManager{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.SceneManager)")
			return resObj
		},
	},
	"blocks-title-scene": {
		Doc:   "Create a new blocks.TitleScene struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.TitleScene{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*blocks.TitleScene)")
			return resObj
		},
	},
	"blocks-pieces": {
		Doc:   "Get blocks.Pieces value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, blocks.Pieces, "Go(map[blocks.BlockType]*blocks.Piece)")
			return resObj
		},
	},
	"bytes-compare": {
		Doc:   "bytes.Compare",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-compare: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-compare: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-compare: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-compare: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-compare: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-compare: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-compare: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-compare: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Compare(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-contains": {
		Doc:   "bytes.Contains",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-contains: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-contains: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Contains(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-contains-any": {
		Doc:   "bytes.ContainsAny",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-contains-any: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains-any: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-any: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains-any: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-contains-any: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.ContainsAny(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-contains-rune": {
		Doc:   "bytes.ContainsRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-contains-rune: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains-rune: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains-rune: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(rune); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-rune: arg 2: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains-rune: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ContainsRune(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-count": {
		Doc:   "bytes.Count",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-count: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-count: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-count: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-count: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-count: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-count: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-count: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-count: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Count(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-cut": {
		Doc:   "bytes.Cut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-cut: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-cut: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-cut: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-cut: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-cut: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-cut: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-cut: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-cut: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, res2 := bytes.Cut(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res2Obj env.Object
			res2Obj = *env.NewInteger(boolToInt64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"bytes-equal": {
		Doc:   "bytes.Equal",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-equal: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-equal: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Equal(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-equal-fold": {
		Doc:   "bytes.EqualFold",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-equal-fold: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal-fold: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal-fold: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal-fold: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-equal-fold: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal-fold: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal-fold: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal-fold: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.EqualFold(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-fields": {
		Doc:   "bytes.Fields",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-fields: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-fields: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-fields: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Fields(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-fields-func": {
		Doc:   "bytes.FieldsFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-fields-func: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-fields-func: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-fields-func: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 rune) bool {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res bool
					if vc, ok := ps.Res.(env.Integer); ok {
						res = vc.Value != 0
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-fields-func: arg 2: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-fields-func: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := bytes.FieldsFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-has-prefix": {
		Doc:   "bytes.HasPrefix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-has-prefix: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-prefix: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-prefix: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-prefix: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-has-prefix: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-prefix: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-prefix: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-prefix: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.HasPrefix(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-has-suffix": {
		Doc:   "bytes.HasSuffix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-has-suffix: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-suffix: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-suffix: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-suffix: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-has-suffix: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-suffix: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-suffix: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-suffix: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.HasSuffix(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-index": {
		Doc:   "bytes.Index",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-index: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-index: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Index(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-any": {
		Doc:   "bytes.IndexAny",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-index-any: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-any: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-any: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-any: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-index-any: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.IndexAny(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-byte": {
		Doc:   "bytes.IndexByte",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-index-byte: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-byte: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-byte: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-index-byte: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-byte: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.IndexByte(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-func": {
		Doc:   "bytes.IndexFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-index-func: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-func: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-func: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 rune) bool {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res bool
					if vc, ok := ps.Res.(env.Integer); ok {
						res = vc.Value != 0
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-index-func: arg 2: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-func: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := bytes.IndexFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-rune": {
		Doc:   "bytes.IndexRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-index-rune: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-rune: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-rune: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-rune: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(rune); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-index-rune: arg 2: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-rune: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.IndexRune(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-join": {
		Doc:   "bytes.Join",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val [][]byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([][]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Block:
						arg0Val[i] = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								if vc, ok := v.Value.(byte); ok {
									arg0Val[i][i] = vc
								} else {
									ps.FailureFlag = true
									return env.NewError("bytes-join: arg 1: " + "block item: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
								}
							default:
								ps.FailureFlag = true
								return env.NewError("bytes-join: arg 1: " + "block item: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("bytes-join: arg 1: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-join: arg 1: " + "block item: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-join: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-join: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-join: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-join: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-join: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-join: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Join(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-last-index": {
		Doc:   "bytes.LastIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.LastIndex(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-last-index-any": {
		Doc:   "bytes.LastIndexAny",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index-any: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index-any: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-any: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-any: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-any: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.LastIndexAny(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-last-index-byte": {
		Doc:   "bytes.LastIndexByte",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index-byte: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index-byte: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-byte: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-byte: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(byte); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-byte: arg 2: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-byte: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.LastIndexByte(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-last-index-func": {
		Doc:   "bytes.LastIndexFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index-func: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index-func: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-func: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 rune) bool {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res bool
					if vc, ok := ps.Res.(env.Integer); ok {
						res = vc.Value != 0
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-last-index-func: arg 2: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-func: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := bytes.LastIndexFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-map": {
		Doc:   "bytes.Map",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val func(rune) rune
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 1: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg0Val = func(farg0 rune) rune {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res rune
					switch v := ps.Res.(type) {
					case env.Native:
						if vc, ok := v.Value.(rune); ok {
							res = vc
						} else {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"bytes-map: arg 1: callback result: "+"expected native of type rune, but got "+objectDebugString(ps.Idx, v),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-map: arg 1: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-map: arg 1: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-map: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-map: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-map: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Map(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-buffer": {
		Doc:   "bytes.NewBuffer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-buffer: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-buffer: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-buffer: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-buffer: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.NewBuffer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*bytes.Buffer)")
			return res0Obj
		},
	},
	"bytes-buffer-string": {
		Doc:   "bytes.NewBufferString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-buffer-string: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0 := bytes.NewBufferString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*bytes.Buffer)")
			return res0Obj
		},
	},
	"bytes-reader": {
		Doc:   "bytes.NewReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-reader: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-reader: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-reader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-reader: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.NewReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*bytes.Reader)")
			return res0Obj
		},
	},
	"bytes-repeat": {
		Doc:   "bytes.Repeat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-repeat: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-repeat: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-repeat: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-repeat: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-repeat: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.Repeat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-replace": {
		Doc:   "bytes.Replace",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-replace: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-replace: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg2Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-replace: arg 3: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace: arg 3: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			res0 := bytes.Replace(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-replace-all": {
		Doc:   "bytes.ReplaceAll",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-replace-all: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace-all: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace-all: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-replace-all: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace-all: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace-all: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg2Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-replace-all: arg 3: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace-all: arg 3: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace-all: arg 3: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ReplaceAll(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-runes": {
		Doc:   "bytes.Runes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-runes: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-runes: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-runes: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-runes: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Runes(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(rune)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split": {
		Doc:   "bytes.Split",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Split(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split-after": {
		Doc:   "bytes.SplitAfter",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.SplitAfter(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split-after-n": {
		Doc:   "bytes.SplitAfterN",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after-n: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after-n: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after-n: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after-n: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after-n: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after-n: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after-n: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after-n: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-split-after-n: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := bytes.SplitAfterN(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split-n": {
		Doc:   "bytes.SplitN",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split-n: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-n: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-n: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-n: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-split-n: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-n: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-n: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-n: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-split-n: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := bytes.SplitN(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-title": {
		Doc:   "bytes.Title",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-title: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-title: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-title: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-title: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.Title(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-lower": {
		Doc:   "bytes.ToLower",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-lower: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-lower: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-lower: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToLower(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-lower-special": {
		Doc:   "bytes.ToLowerSpecial",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unicode.SpecialCase
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(unicode.SpecialCase); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower-special: arg 1: " + "expected native of type unicode.SpecialCase, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-lower-special: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-lower-special: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-lower-special: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower-special: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-lower-special: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToLowerSpecial(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-title": {
		Doc:   "bytes.ToTitle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-title: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-title: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-title: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToTitle(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-title-special": {
		Doc:   "bytes.ToTitleSpecial",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unicode.SpecialCase
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(unicode.SpecialCase); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title-special: arg 1: " + "expected native of type unicode.SpecialCase, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-title-special: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-title-special: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-title-special: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title-special: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-title-special: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToTitleSpecial(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-upper": {
		Doc:   "bytes.ToUpper",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-upper: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-upper: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-upper: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToUpper(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-upper-special": {
		Doc:   "bytes.ToUpperSpecial",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unicode.SpecialCase
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(unicode.SpecialCase); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper-special: arg 1: " + "expected native of type unicode.SpecialCase, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-upper-special: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-upper-special: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-upper-special: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper-special: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-upper-special: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToUpperSpecial(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-valid-utf-8": {
		Doc:   "bytes.ToValidUTF8",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-valid-utf-8: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-valid-utf-8: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-valid-utf-8: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-valid-utf-8: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-to-valid-utf-8: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-valid-utf-8: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-valid-utf-8: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-valid-utf-8: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.ToValidUTF8(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim": {
		Doc:   "bytes.Trim",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-trim: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.Trim(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-func": {
		Doc:   "bytes.TrimFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-func: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-func: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-func: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 rune) bool {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res bool
					if vc, ok := ps.Res.(env.Integer); ok {
						res = vc.Value != 0
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-trim-func: arg 2: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-func: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := bytes.TrimFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-left": {
		Doc:   "bytes.TrimLeft",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-left: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-left: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.TrimLeft(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-left-func": {
		Doc:   "bytes.TrimLeftFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-left-func: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-left-func: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left-func: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 rune) bool {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res bool
					if vc, ok := ps.Res.(env.Integer); ok {
						res = vc.Value != 0
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-trim-left-func: arg 2: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left-func: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := bytes.TrimLeftFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-prefix": {
		Doc:   "bytes.TrimPrefix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-prefix: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-prefix: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-prefix: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-prefix: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-prefix: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-prefix: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-prefix: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-prefix: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.TrimPrefix(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-right": {
		Doc:   "bytes.TrimRight",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-right: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-right: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := bytes.TrimRight(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-right-func": {
		Doc:   "bytes.TrimRightFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-right-func: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-right-func: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right-func: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 2: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg1Val = func(farg0 rune) bool {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(rune)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res bool
					if vc, ok := ps.Res.(env.Integer); ok {
						res = vc.Value != 0
					} else {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-trim-right-func: arg 2: callback result: "+"expected integer, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right-func: arg 2: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := bytes.TrimRightFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-space": {
		Doc:   "bytes.TrimSpace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-space: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-space: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-space: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-space: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.TrimSpace(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-suffix": {
		Doc:   "bytes.TrimSuffix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-suffix: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-suffix: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-suffix: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-suffix: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-suffix: arg 2: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-suffix: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-suffix: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-suffix: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := bytes.TrimSuffix(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"color-alpha-16-model": {
		Doc:   "Get color.Alpha16Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.Alpha16Model, "Go(color.Model)")
			return resObj
		},
	},
	"color-alpha-model": {
		Doc:   "Get color.AlphaModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.AlphaModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-cmyk-model": {
		Doc:   "Get color.CMYKModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.CMYKModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-cmyk-to-rgb": {
		Doc:   "color.CMYKToRGB",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val uint8
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val uint8
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val uint8
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			res0, res1, res2 := color.CMYKToRGB(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"color-gray-16-model": {
		Doc:   "Get color.Gray16Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.Gray16Model, "Go(color.Model)")
			return resObj
		},
	},
	"color-gray-model": {
		Doc:   "Get color.GrayModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.GrayModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-model-func": {
		Doc:   "color.ModelFunc",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val func(color.Color) color.Color
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("color-model-func: arg 1: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg0Val = func(farg0 color.Color) color.Color {
					var farg0Val env.Object
					farg0Val = ifaceToNative(ps.Idx, farg0, "Go(color.Color)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res color.Color
					switch v := ps.Res.(type) {
					case env.RyeCtx:
						var err error
						res, err = ctxTo_color_Color(ps, v)
						if err != nil {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"color-model-func: arg 1: callback result: "+err.Error(),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					case env.Native:
						if vc, ok := v.Value.(color.Color); ok {
							res = vc
						} else {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"color-model-func: arg 1: callback result: "+"expected native of type color.Color, but got "+objectDebugString(ps.Idx, v),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"color-model-func: arg 1: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
						res = nil
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"color-model-func: arg 1: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-model-func: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-model-func: arg 1: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			res0 := color.ModelFunc(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(color.Model)")
			return res0Obj
		},
	},
	"color-alpha": {
		Doc:   "Create a new color.Alpha struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Alpha{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.Alpha)")
			return resObj
		},
	},
	"color-alpha-16": {
		Doc:   "Create a new color.Alpha16 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Alpha16{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.Alpha16)")
			return resObj
		},
	},
	"color-cmyk": {
		Doc:   "Create a new color.CMYK struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.CMYK{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.CMYK)")
			return resObj
		},
	},
	"color-gray": {
		Doc:   "Create a new color.Gray struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Gray{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.Gray)")
			return resObj
		},
	},
	"color-gray-16": {
		Doc:   "Create a new color.Gray16 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Gray16{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.Gray16)")
			return resObj
		},
	},
	"color-nrgba": {
		Doc:   "Create a new color.NRGBA struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.NRGBA{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.NRGBA)")
			return resObj
		},
	},
	"color-nrgba-64": {
		Doc:   "Create a new color.NRGBA64 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.NRGBA64{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.NRGBA64)")
			return resObj
		},
	},
	"color-ny-cb-cr-a": {
		Doc:   "Create a new color.NYCbCrA struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.NYCbCrA{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.NYCbCrA)")
			return resObj
		},
	},
	"color-rgba": {
		Doc:   "Create a new color.RGBA struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.RGBA{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.RGBA)")
			return resObj
		},
	},
	"color-rgba-64": {
		Doc:   "Create a new color.RGBA64 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.RGBA64{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.RGBA64)")
			return resObj
		},
	},
	"color-y-cb-cr": {
		Doc:   "Create a new color.YCbCr struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.YCbCr{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*color.YCbCr)")
			return resObj
		},
	},
	"color-nrgba-64-model": {
		Doc:   "Get color.NRGBA64Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.NRGBA64Model, "Go(color.Model)")
			return resObj
		},
	},
	"color-nrgba-model": {
		Doc:   "Get color.NRGBAModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.NRGBAModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-ny-cb-cr-a-model": {
		Doc:   "Get color.NYCbCrAModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.NYCbCrAModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-rgb-to-cmyk": {
		Doc:   "color.RGBToCMYK",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-cmyk: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val uint8
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-cmyk: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val uint8
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-cmyk: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1, res2, res3 := color.RGBToCMYK(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-rgb-to-y-cb-cr": {
		Doc:   "color.RGBToYCbCr",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-y-cb-cr: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val uint8
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-y-cb-cr: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val uint8
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-y-cb-cr: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1, res2 := color.RGBToYCbCr(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"color-rgba-64-model": {
		Doc:   "Get color.RGBA64Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.RGBA64Model, "Go(color.Model)")
			return resObj
		},
	},
	"color-rgba-model": {
		Doc:   "Get color.RGBAModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.RGBAModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-y-cb-cr-model": {
		Doc:   "Get color.YCbCrModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, color.YCbCrModel, "Go(color.Model)")
			return resObj
		},
	},
	"color-y-cb-cr-to-rgb": {
		Doc:   "color.YCbCrToRGB",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr-to-rgb: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val uint8
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr-to-rgb: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val uint8
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr-to-rgb: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1, res2 := color.YCbCrToRGB(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"colorm-draw-image": {
		Doc:   "colorm.DrawImage",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 2: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val colorm.ColorM
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.ColorM); ok {
					arg2Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 3: " + "expected native of type *colorm.ColorM, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *colorm.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*colorm.DrawImageOptions); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 4: " + "expected native of type *colorm.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			colorm.DrawImage(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"colorm-color-m": {
		Doc:   "Create a new colorm.ColorM struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &colorm.ColorM{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*colorm.ColorM)")
			return resObj
		},
	},
	"colorm-draw-image-options": {
		Doc:   "Create a new colorm.DrawImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &colorm.DrawImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*colorm.DrawImageOptions)")
			return resObj
		},
	},
	"colorm-draw-triangles-options": {
		Doc:   "Create a new colorm.DrawTrianglesOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &colorm.DrawTrianglesOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*colorm.DrawTrianglesOptions)")
			return resObj
		},
	},
	"draw-draw": {
		Doc:   "draw.Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(draw.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 1: " + "expected native of type draw.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg1Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 2: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val image.Image
			switch v := arg2.(type) {
			case env.RyeCtx:
				var err error
				arg2Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 3: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 3: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val image.Point
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Point); ok {
					arg3Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 4: " + "expected native of type *image.Point, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg4Val draw.Op
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal draw.Op
				if natOk {
					natVal, natValOk = nat.Value.(draw.Op)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if vc, ok := arg4.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("draw-draw: arg 5: " + "expected integer, but got " + objectDebugString(ps.Idx, arg4))
					}
					arg4Val = draw.Op(u)
				}
			}
			draw.Draw(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val)
			return nil
		},
	},
	"draw-floyd-steinberg": {
		Doc:   "Get draw.FloydSteinberg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, draw.FloydSteinberg, "Go(draw.Drawer)")
			return resObj
		},
	},
	"draw-over": {
		Doc:   "Get draw.Over value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(draw.Over)))
			return resObj
		},
	},
	"draw-src": {
		Doc:   "Get draw.Src value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(draw.Src)))
			return resObj
		},
	},
	"actual-fps": {
		Doc:   "ebiten.ActualFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.ActualFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"actual-tps": {
		Doc:   "ebiten.ActualTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.ActualTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"address-clamp-to-zero": {
		Doc:   "Get ebiten.AddressClampToZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressClampToZero)))
			return resObj
		},
	},
	"address-repeat": {
		Doc:   "Get ebiten.AddressRepeat value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressRepeat)))
			return resObj
		},
	},
	"address-unsafe": {
		Doc:   "Get ebiten.AddressUnsafe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressUnsafe)))
			return resObj
		},
	},
	"append-gamepad-i-ds": {
		Doc:   "ebiten.AppendGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.GamepadID); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("append-gamepad-i-ds: arg 1: " + "block item: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("append-gamepad-i-ds: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-gamepad-i-ds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-gamepad-i-ds: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.AppendGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-input-chars": {
		Doc:   "ebiten.AppendInputChars",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []rune
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(rune); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("append-input-chars: arg 1: " + "block item: " + "expected native of type rune, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("append-input-chars: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-input-chars: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-input-chars: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.AppendInputChars(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(rune)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-monitors": {
		Doc:   "ebiten.AppendMonitors",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []*ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*ebiten.MonitorType, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten.MonitorType); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("append-monitors: arg 1: " + "block item: " + "expected native of type *ebiten.MonitorType, but got " + objectDebugString(ps.Idx, v))
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("append-monitors: arg 1: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("append-monitors: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-monitors: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-monitors: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.AppendMonitors(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(*ebiten.MonitorType)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-touch-i-ds": {
		Doc:   "ebiten.AppendTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.TouchID); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("append-touch-i-ds: arg 1: " + "block item: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("append-touch-i-ds: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-touch-i-ds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-touch-i-ds: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.AppendTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.TouchID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"blend-factor-default": {
		Doc:   "Get ebiten.BlendFactorDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDefault), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-destination-alpha": {
		Doc:   "Get ebiten.BlendFactorDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationAlpha), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-destination-color": {
		Doc:   "Get ebiten.BlendFactorDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationColor), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-one": {
		Doc:   "Get ebiten.BlendFactorOne value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOne), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-alpha": {
		Doc:   "Get ebiten.BlendFactorOneMinusDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationAlpha), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-color": {
		Doc:   "Get ebiten.BlendFactorOneMinusDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationColor), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-one-minus-source-alpha": {
		Doc:   "Get ebiten.BlendFactorOneMinusSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceAlpha), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-one-minus-source-color": {
		Doc:   "Get ebiten.BlendFactorOneMinusSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceColor), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-source-alpha": {
		Doc:   "Get ebiten.BlendFactorSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceAlpha), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-source-color": {
		Doc:   "Get ebiten.BlendFactorSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceColor), "Go(byte)")
			return resObj
		},
	},
	"blend-factor-zero": {
		Doc:   "Get ebiten.BlendFactorZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorZero), "Go(byte)")
			return resObj
		},
	},
	"blend-operation-add": {
		Doc:   "Get ebiten.BlendOperationAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationAdd), "Go(byte)")
			return resObj
		},
	},
	"blend-operation-max": {
		Doc:   "Get ebiten.BlendOperationMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMax), "Go(byte)")
			return resObj
		},
	},
	"blend-operation-min": {
		Doc:   "Get ebiten.BlendOperationMin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMin), "Go(byte)")
			return resObj
		},
	},
	"blend-operation-reverse-subtract": {
		Doc:   "Get ebiten.BlendOperationReverseSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationReverseSubtract), "Go(byte)")
			return resObj
		},
	},
	"blend-operation-subtract": {
		Doc:   "Get ebiten.BlendOperationSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationSubtract), "Go(byte)")
			return resObj
		},
	},
	"color-scale-mode-premultiplied-alpha": {
		Doc:   "Get ebiten.ColorScaleModePremultipliedAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModePremultipliedAlpha)))
			return resObj
		},
	},
	"color-scale-mode-straight-alpha": {
		Doc:   "Get ebiten.ColorScaleModeStraightAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModeStraightAlpha)))
			return resObj
		},
	},
	"composite-mode-clear": {
		Doc:   "Get ebiten.CompositeModeClear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeClear)))
			return resObj
		},
	},
	"composite-mode-copy": {
		Doc:   "Get ebiten.CompositeModeCopy value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCopy)))
			return resObj
		},
	},
	"composite-mode-custom": {
		Doc:   "Get ebiten.CompositeModeCustom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCustom)))
			return resObj
		},
	},
	"composite-mode-destination": {
		Doc:   "Get ebiten.CompositeModeDestination value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestination)))
			return resObj
		},
	},
	"composite-mode-destination-atop": {
		Doc:   "Get ebiten.CompositeModeDestinationAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationAtop)))
			return resObj
		},
	},
	"composite-mode-destination-in": {
		Doc:   "Get ebiten.CompositeModeDestinationIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationIn)))
			return resObj
		},
	},
	"composite-mode-destination-out": {
		Doc:   "Get ebiten.CompositeModeDestinationOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOut)))
			return resObj
		},
	},
	"composite-mode-destination-over": {
		Doc:   "Get ebiten.CompositeModeDestinationOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOver)))
			return resObj
		},
	},
	"composite-mode-lighter": {
		Doc:   "Get ebiten.CompositeModeLighter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeLighter)))
			return resObj
		},
	},
	"composite-mode-multiply": {
		Doc:   "Get ebiten.CompositeModeMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeMultiply)))
			return resObj
		},
	},
	"composite-mode-source-atop": {
		Doc:   "Get ebiten.CompositeModeSourceAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceAtop)))
			return resObj
		},
	},
	"composite-mode-source-in": {
		Doc:   "Get ebiten.CompositeModeSourceIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceIn)))
			return resObj
		},
	},
	"composite-mode-source-out": {
		Doc:   "Get ebiten.CompositeModeSourceOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOut)))
			return resObj
		},
	},
	"composite-mode-source-over": {
		Doc:   "Get ebiten.CompositeModeSourceOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOver)))
			return resObj
		},
	},
	"composite-mode-xor": {
		Doc:   "Get ebiten.CompositeModeXor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeXor)))
			return resObj
		},
	},
	"current-fps": {
		Doc:   "ebiten.CurrentFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"current-tps": {
		Doc:   "ebiten.CurrentTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"cursor-mode": {
		Doc:   "ebiten.CursorMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CursorMode()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(ebiten.CursorModeType)")
			return res0Obj
		},
	},
	"cursor-mode-captured": {
		Doc:   "Get ebiten.CursorModeCaptured value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorModeCaptured, "Go(ebiten.CursorModeType)")
			return resObj
		},
	},
	"cursor-mode-hidden": {
		Doc:   "Get ebiten.CursorModeHidden value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorModeHidden, "Go(ebiten.CursorModeType)")
			return resObj
		},
	},
	"cursor-mode-visible": {
		Doc:   "Get ebiten.CursorModeVisible value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorModeVisible, "Go(ebiten.CursorModeType)")
			return resObj
		},
	},
	"cursor-position": {
		Doc:   "ebiten.CursorPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.CursorPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"cursor-shape": {
		Doc:   "ebiten.CursorShape",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CursorShape()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(ebiten.CursorShapeType)")
			return res0Obj
		},
	},
	"cursor-shape-crosshair": {
		Doc:   "Get ebiten.CursorShapeCrosshair value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeCrosshair, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-default": {
		Doc:   "Get ebiten.CursorShapeDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeDefault, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-ew-resize": {
		Doc:   "Get ebiten.CursorShapeEWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeEWResize, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-move": {
		Doc:   "Get ebiten.CursorShapeMove value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeMove, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-nesw-resize": {
		Doc:   "Get ebiten.CursorShapeNESWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeNESWResize, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-not-allowed": {
		Doc:   "Get ebiten.CursorShapeNotAllowed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeNotAllowed, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-ns-resize": {
		Doc:   "Get ebiten.CursorShapeNSResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeNSResize, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-nwse-resize": {
		Doc:   "Get ebiten.CursorShapeNWSEResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeNWSEResize, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-pointer": {
		Doc:   "Get ebiten.CursorShapePointer value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapePointer, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"cursor-shape-text": {
		Doc:   "Get ebiten.CursorShapeText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.CursorShapeText, "Go(ebiten.CursorShapeType)")
			return resObj
		},
	},
	"device-scale-factor": {
		Doc:   "ebiten.DeviceScaleFactor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"dropped-files": {
		Doc:   "ebiten.DroppedFiles",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.DroppedFiles()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(fs.FS)")
			return res0Obj
		},
	},
	"even-odd": {
		Doc:   "Get ebiten.EvenOdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.EvenOdd)))
			return resObj
		},
	},
	"fill-all": {
		Doc:   "Get ebiten.FillAll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FillAll)))
			return resObj
		},
	},
	"filter-linear": {
		Doc:   "Get ebiten.FilterLinear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterLinear)))
			return resObj
		},
	},
	"filter-nearest": {
		Doc:   "Get ebiten.FilterNearest value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterNearest)))
			return resObj
		},
	},
	"fps-mode": {
		Doc:   "ebiten.FPSMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.FPSMode()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(ebiten.FPSModeType)")
			return res0Obj
		},
	},
	"fps-mode-vsync-off-maximum": {
		Doc:   "Get ebiten.FPSModeVsyncOffMaximum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.FPSModeVsyncOffMaximum, "Go(ebiten.FPSModeType)")
			return resObj
		},
	},
	"fps-mode-vsync-off-minimum": {
		Doc:   "Get ebiten.FPSModeVsyncOffMinimum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.FPSModeVsyncOffMinimum, "Go(ebiten.FPSModeType)")
			return resObj
		},
	},
	"fps-mode-vsync-on": {
		Doc:   "Get ebiten.FPSModeVsyncOn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.FPSModeVsyncOn, "Go(ebiten.FPSModeType)")
			return resObj
		},
	},
	"gamepad-axis": {
		Doc:   "ebiten.GamepadAxis",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-axis: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-axis: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxis(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-count": {
		Doc:   "ebiten.GamepadAxisCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-axis-count: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-axis-count: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.GamepadAxisCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-num": {
		Doc:   "ebiten.GamepadAxisNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-axis-num: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-axis-num: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.GamepadAxisNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-value": {
		Doc:   "ebiten.GamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-axis-value: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-axis-value: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-value: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-button-0": {
		Doc:   "Get ebiten.GamepadButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton0, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-1": {
		Doc:   "Get ebiten.GamepadButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton1, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-10": {
		Doc:   "Get ebiten.GamepadButton10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton10, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-11": {
		Doc:   "Get ebiten.GamepadButton11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton11, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-12": {
		Doc:   "Get ebiten.GamepadButton12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton12, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-13": {
		Doc:   "Get ebiten.GamepadButton13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton13, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-14": {
		Doc:   "Get ebiten.GamepadButton14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton14, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-15": {
		Doc:   "Get ebiten.GamepadButton15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton15, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-16": {
		Doc:   "Get ebiten.GamepadButton16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton16, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-17": {
		Doc:   "Get ebiten.GamepadButton17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton17, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-18": {
		Doc:   "Get ebiten.GamepadButton18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton18, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-19": {
		Doc:   "Get ebiten.GamepadButton19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton19, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-2": {
		Doc:   "Get ebiten.GamepadButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton2, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-20": {
		Doc:   "Get ebiten.GamepadButton20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton20, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-21": {
		Doc:   "Get ebiten.GamepadButton21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton21, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-22": {
		Doc:   "Get ebiten.GamepadButton22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton22, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-23": {
		Doc:   "Get ebiten.GamepadButton23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton23, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-24": {
		Doc:   "Get ebiten.GamepadButton24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton24, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-25": {
		Doc:   "Get ebiten.GamepadButton25 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton25, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-26": {
		Doc:   "Get ebiten.GamepadButton26 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton26, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-27": {
		Doc:   "Get ebiten.GamepadButton27 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton27, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-28": {
		Doc:   "Get ebiten.GamepadButton28 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton28, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-29": {
		Doc:   "Get ebiten.GamepadButton29 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton29, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-3": {
		Doc:   "Get ebiten.GamepadButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton3, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-30": {
		Doc:   "Get ebiten.GamepadButton30 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton30, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-31": {
		Doc:   "Get ebiten.GamepadButton31 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton31, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-4": {
		Doc:   "Get ebiten.GamepadButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton4, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-5": {
		Doc:   "Get ebiten.GamepadButton5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton5, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-6": {
		Doc:   "Get ebiten.GamepadButton6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton6, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-7": {
		Doc:   "Get ebiten.GamepadButton7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton7, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-8": {
		Doc:   "Get ebiten.GamepadButton8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton8, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-9": {
		Doc:   "Get ebiten.GamepadButton9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButton9, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-count": {
		Doc:   "ebiten.GamepadButtonCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-button-count: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-button-count: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.GamepadButtonCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-button-max": {
		Doc:   "Get ebiten.GamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.GamepadButtonMax, "Go(ebiten.GamepadButton)")
			return resObj
		},
	},
	"gamepad-button-num": {
		Doc:   "ebiten.GamepadButtonNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-button-num: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-button-num: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.GamepadButtonNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-i-ds": {
		Doc:   "ebiten.GamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.GamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"gamepad-name": {
		Doc:   "ebiten.GamepadName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-name: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-name: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.GamepadName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"gamepad-sdlid": {
		Doc:   "ebiten.GamepadSDLID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gamepad-sdlid: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gamepad-sdlid: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.GamepadSDLID(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"graphics-library-auto": {
		Doc:   "Get ebiten.GraphicsLibraryAuto value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryAuto)))
			return resObj
		},
	},
	"graphics-library-direct-x": {
		Doc:   "Get ebiten.GraphicsLibraryDirectX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryDirectX)))
			return resObj
		},
	},
	"graphics-library-metal": {
		Doc:   "Get ebiten.GraphicsLibraryMetal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryMetal)))
			return resObj
		},
	},
	"graphics-library-open-gl": {
		Doc:   "Get ebiten.GraphicsLibraryOpenGL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryOpenGL)))
			return resObj
		},
	},
	"graphics-library-play-station-5": {
		Doc:   "Get ebiten.GraphicsLibraryPlayStation5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryPlayStation5)))
			return resObj
		},
	},
	"graphics-library-unknown": {
		Doc:   "Get ebiten.GraphicsLibraryUnknown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryUnknown)))
			return resObj
		},
	},
	"input-chars": {
		Doc:   "ebiten.InputChars",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.InputChars()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(rune)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"is-focused": {
		Doc:   "ebiten.IsFocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsFocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-fullscreen": {
		Doc:   "ebiten.IsFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-gamepad-button-pressed": {
		Doc:   "ebiten.IsGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-gamepad-button-pressed: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-gamepad-button-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-gamepad-button-pressed: arg 2: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-gamepad-button-pressed: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.IsGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-key-pressed": {
		Doc:   "ebiten.IsKeyPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-key-pressed: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.IsKeyPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-mouse-button-pressed": {
		Doc:   "ebiten.IsMouseButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.MouseButton); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-mouse-button-pressed: arg 1: " + "expected native of type ebiten.MouseButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-mouse-button-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.IsMouseButtonPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-runnable-on-unfocused": {
		Doc:   "ebiten.IsRunnableOnUnfocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsRunnableOnUnfocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-cleared-every-frame": {
		Doc:   "ebiten.IsScreenClearedEveryFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenClearedEveryFrame()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-filter-enabled": {
		Doc:   "ebiten.IsScreenFilterEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenFilterEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-transparent": {
		Doc:   "ebiten.IsScreenTransparent",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenTransparent()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-axis-available": {
		Doc:   "ebiten.IsStandardGamepadAxisAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-axis-available: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-axis-available: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadAxis
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadAxis); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-axis-available: arg 2: " + "expected native of type ebiten.StandardGamepadAxis, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-axis-available: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.IsStandardGamepadAxisAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-available": {
		Doc:   "ebiten.IsStandardGamepadButtonAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-button-available: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-button-available: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-button-available: arg 2: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-button-available: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.IsStandardGamepadButtonAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-pressed": {
		Doc:   "ebiten.IsStandardGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-button-pressed: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-button-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-button-pressed: arg 2: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-button-pressed: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.IsStandardGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-layout-available": {
		Doc:   "ebiten.IsStandardGamepadLayoutAvailable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("is-standard-gamepad-layout-available: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("is-standard-gamepad-layout-available: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.IsStandardGamepadLayoutAvailable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-vsync-enabled": {
		Doc:   "ebiten.IsVsyncEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsVsyncEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-being-closed": {
		Doc:   "ebiten.IsWindowBeingClosed",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowBeingClosed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-closing-handled": {
		Doc:   "ebiten.IsWindowClosingHandled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowClosingHandled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-decorated": {
		Doc:   "ebiten.IsWindowDecorated",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowDecorated()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-floating": {
		Doc:   "ebiten.IsWindowFloating",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowFloating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-maximized": {
		Doc:   "ebiten.IsWindowMaximized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMaximized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-minimized": {
		Doc:   "ebiten.IsWindowMinimized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMinimized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-mouse-passthrough": {
		Doc:   "ebiten.IsWindowMousePassthrough",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMousePassthrough()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-resizable": {
		Doc:   "ebiten.IsWindowResizable",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowResizable()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"key-0": {
		Doc:   "Get ebiten.Key0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key0)))
			return resObj
		},
	},
	"key-1": {
		Doc:   "Get ebiten.Key1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key1)))
			return resObj
		},
	},
	"key-2": {
		Doc:   "Get ebiten.Key2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key2)))
			return resObj
		},
	},
	"key-3": {
		Doc:   "Get ebiten.Key3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key3)))
			return resObj
		},
	},
	"key-4": {
		Doc:   "Get ebiten.Key4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key4)))
			return resObj
		},
	},
	"key-5": {
		Doc:   "Get ebiten.Key5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key5)))
			return resObj
		},
	},
	"key-6": {
		Doc:   "Get ebiten.Key6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key6)))
			return resObj
		},
	},
	"key-7": {
		Doc:   "Get ebiten.Key7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key7)))
			return resObj
		},
	},
	"key-8": {
		Doc:   "Get ebiten.Key8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key8)))
			return resObj
		},
	},
	"key-9": {
		Doc:   "Get ebiten.Key9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key9)))
			return resObj
		},
	},
	"key-a": {
		Doc:   "Get ebiten.KeyA value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyA)))
			return resObj
		},
	},
	"key-alt": {
		Doc:   "Get ebiten.KeyAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAlt)))
			return resObj
		},
	},
	"key-alt-left": {
		Doc:   "Get ebiten.KeyAltLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltLeft)))
			return resObj
		},
	},
	"key-alt-right": {
		Doc:   "Get ebiten.KeyAltRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltRight)))
			return resObj
		},
	},
	"key-apostrophe": {
		Doc:   "Get ebiten.KeyApostrophe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyApostrophe)))
			return resObj
		},
	},
	"key-arrow-down": {
		Doc:   "Get ebiten.KeyArrowDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowDown)))
			return resObj
		},
	},
	"key-arrow-left": {
		Doc:   "Get ebiten.KeyArrowLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowLeft)))
			return resObj
		},
	},
	"key-arrow-right": {
		Doc:   "Get ebiten.KeyArrowRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowRight)))
			return resObj
		},
	},
	"key-arrow-up": {
		Doc:   "Get ebiten.KeyArrowUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowUp)))
			return resObj
		},
	},
	"key-b": {
		Doc:   "Get ebiten.KeyB value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyB)))
			return resObj
		},
	},
	"key-backquote": {
		Doc:   "Get ebiten.KeyBackquote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackquote)))
			return resObj
		},
	},
	"key-backslash": {
		Doc:   "Get ebiten.KeyBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackslash)))
			return resObj
		},
	},
	"key-backspace": {
		Doc:   "Get ebiten.KeyBackspace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackspace)))
			return resObj
		},
	},
	"key-bracket-left": {
		Doc:   "Get ebiten.KeyBracketLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketLeft)))
			return resObj
		},
	},
	"key-bracket-right": {
		Doc:   "Get ebiten.KeyBracketRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketRight)))
			return resObj
		},
	},
	"key-c": {
		Doc:   "Get ebiten.KeyC value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyC)))
			return resObj
		},
	},
	"key-caps-lock": {
		Doc:   "Get ebiten.KeyCapsLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyCapsLock)))
			return resObj
		},
	},
	"key-comma": {
		Doc:   "Get ebiten.KeyComma value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyComma)))
			return resObj
		},
	},
	"key-context-menu": {
		Doc:   "Get ebiten.KeyContextMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyContextMenu)))
			return resObj
		},
	},
	"key-control": {
		Doc:   "Get ebiten.KeyControl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControl)))
			return resObj
		},
	},
	"key-control-left": {
		Doc:   "Get ebiten.KeyControlLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlLeft)))
			return resObj
		},
	},
	"key-control-right": {
		Doc:   "Get ebiten.KeyControlRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlRight)))
			return resObj
		},
	},
	"key-d": {
		Doc:   "Get ebiten.KeyD value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyD)))
			return resObj
		},
	},
	"key-delete": {
		Doc:   "Get ebiten.KeyDelete value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDelete)))
			return resObj
		},
	},
	"key-digit-0": {
		Doc:   "Get ebiten.KeyDigit0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit0)))
			return resObj
		},
	},
	"key-digit-1": {
		Doc:   "Get ebiten.KeyDigit1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit1)))
			return resObj
		},
	},
	"key-digit-2": {
		Doc:   "Get ebiten.KeyDigit2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit2)))
			return resObj
		},
	},
	"key-digit-3": {
		Doc:   "Get ebiten.KeyDigit3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit3)))
			return resObj
		},
	},
	"key-digit-4": {
		Doc:   "Get ebiten.KeyDigit4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit4)))
			return resObj
		},
	},
	"key-digit-5": {
		Doc:   "Get ebiten.KeyDigit5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit5)))
			return resObj
		},
	},
	"key-digit-6": {
		Doc:   "Get ebiten.KeyDigit6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit6)))
			return resObj
		},
	},
	"key-digit-7": {
		Doc:   "Get ebiten.KeyDigit7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit7)))
			return resObj
		},
	},
	"key-digit-8": {
		Doc:   "Get ebiten.KeyDigit8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit8)))
			return resObj
		},
	},
	"key-digit-9": {
		Doc:   "Get ebiten.KeyDigit9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit9)))
			return resObj
		},
	},
	"key-down": {
		Doc:   "Get ebiten.KeyDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDown)))
			return resObj
		},
	},
	"key-e": {
		Doc:   "Get ebiten.KeyE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyE)))
			return resObj
		},
	},
	"key-end": {
		Doc:   "Get ebiten.KeyEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnd)))
			return resObj
		},
	},
	"key-enter": {
		Doc:   "Get ebiten.KeyEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnter)))
			return resObj
		},
	},
	"key-equal": {
		Doc:   "Get ebiten.KeyEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEqual)))
			return resObj
		},
	},
	"key-escape": {
		Doc:   "Get ebiten.KeyEscape value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEscape)))
			return resObj
		},
	},
	"key-f": {
		Doc:   "Get ebiten.KeyF value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF)))
			return resObj
		},
	},
	"key-f-1": {
		Doc:   "Get ebiten.KeyF1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF1)))
			return resObj
		},
	},
	"key-f-10": {
		Doc:   "Get ebiten.KeyF10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF10)))
			return resObj
		},
	},
	"key-f-11": {
		Doc:   "Get ebiten.KeyF11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF11)))
			return resObj
		},
	},
	"key-f-12": {
		Doc:   "Get ebiten.KeyF12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF12)))
			return resObj
		},
	},
	"key-f-13": {
		Doc:   "Get ebiten.KeyF13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF13)))
			return resObj
		},
	},
	"key-f-14": {
		Doc:   "Get ebiten.KeyF14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF14)))
			return resObj
		},
	},
	"key-f-15": {
		Doc:   "Get ebiten.KeyF15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF15)))
			return resObj
		},
	},
	"key-f-16": {
		Doc:   "Get ebiten.KeyF16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF16)))
			return resObj
		},
	},
	"key-f-17": {
		Doc:   "Get ebiten.KeyF17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF17)))
			return resObj
		},
	},
	"key-f-18": {
		Doc:   "Get ebiten.KeyF18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF18)))
			return resObj
		},
	},
	"key-f-19": {
		Doc:   "Get ebiten.KeyF19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF19)))
			return resObj
		},
	},
	"key-f-2": {
		Doc:   "Get ebiten.KeyF2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF2)))
			return resObj
		},
	},
	"key-f-20": {
		Doc:   "Get ebiten.KeyF20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF20)))
			return resObj
		},
	},
	"key-f-21": {
		Doc:   "Get ebiten.KeyF21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF21)))
			return resObj
		},
	},
	"key-f-22": {
		Doc:   "Get ebiten.KeyF22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF22)))
			return resObj
		},
	},
	"key-f-23": {
		Doc:   "Get ebiten.KeyF23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF23)))
			return resObj
		},
	},
	"key-f-24": {
		Doc:   "Get ebiten.KeyF24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF24)))
			return resObj
		},
	},
	"key-f-3": {
		Doc:   "Get ebiten.KeyF3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF3)))
			return resObj
		},
	},
	"key-f-4": {
		Doc:   "Get ebiten.KeyF4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF4)))
			return resObj
		},
	},
	"key-f-5": {
		Doc:   "Get ebiten.KeyF5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF5)))
			return resObj
		},
	},
	"key-f-6": {
		Doc:   "Get ebiten.KeyF6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF6)))
			return resObj
		},
	},
	"key-f-7": {
		Doc:   "Get ebiten.KeyF7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF7)))
			return resObj
		},
	},
	"key-f-8": {
		Doc:   "Get ebiten.KeyF8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF8)))
			return resObj
		},
	},
	"key-f-9": {
		Doc:   "Get ebiten.KeyF9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF9)))
			return resObj
		},
	},
	"key-g": {
		Doc:   "Get ebiten.KeyG value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyG)))
			return resObj
		},
	},
	"key-grave-accent": {
		Doc:   "Get ebiten.KeyGraveAccent value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyGraveAccent)))
			return resObj
		},
	},
	"key-h": {
		Doc:   "Get ebiten.KeyH value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyH)))
			return resObj
		},
	},
	"key-home": {
		Doc:   "Get ebiten.KeyHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyHome)))
			return resObj
		},
	},
	"key-i": {
		Doc:   "Get ebiten.KeyI value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyI)))
			return resObj
		},
	},
	"key-insert": {
		Doc:   "Get ebiten.KeyInsert value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyInsert)))
			return resObj
		},
	},
	"key-intl-backslash": {
		Doc:   "Get ebiten.KeyIntlBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyIntlBackslash)))
			return resObj
		},
	},
	"key-j": {
		Doc:   "Get ebiten.KeyJ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyJ)))
			return resObj
		},
	},
	"key-k": {
		Doc:   "Get ebiten.KeyK value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyK)))
			return resObj
		},
	},
	"key-kp-0": {
		Doc:   "Get ebiten.KeyKP0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP0)))
			return resObj
		},
	},
	"key-kp-1": {
		Doc:   "Get ebiten.KeyKP1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP1)))
			return resObj
		},
	},
	"key-kp-2": {
		Doc:   "Get ebiten.KeyKP2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP2)))
			return resObj
		},
	},
	"key-kp-3": {
		Doc:   "Get ebiten.KeyKP3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP3)))
			return resObj
		},
	},
	"key-kp-4": {
		Doc:   "Get ebiten.KeyKP4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP4)))
			return resObj
		},
	},
	"key-kp-5": {
		Doc:   "Get ebiten.KeyKP5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP5)))
			return resObj
		},
	},
	"key-kp-6": {
		Doc:   "Get ebiten.KeyKP6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP6)))
			return resObj
		},
	},
	"key-kp-7": {
		Doc:   "Get ebiten.KeyKP7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP7)))
			return resObj
		},
	},
	"key-kp-8": {
		Doc:   "Get ebiten.KeyKP8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP8)))
			return resObj
		},
	},
	"key-kp-9": {
		Doc:   "Get ebiten.KeyKP9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP9)))
			return resObj
		},
	},
	"key-kp-add": {
		Doc:   "Get ebiten.KeyKPAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPAdd)))
			return resObj
		},
	},
	"key-kp-decimal": {
		Doc:   "Get ebiten.KeyKPDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDecimal)))
			return resObj
		},
	},
	"key-kp-divide": {
		Doc:   "Get ebiten.KeyKPDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDivide)))
			return resObj
		},
	},
	"key-kp-enter": {
		Doc:   "Get ebiten.KeyKPEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEnter)))
			return resObj
		},
	},
	"key-kp-equal": {
		Doc:   "Get ebiten.KeyKPEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEqual)))
			return resObj
		},
	},
	"key-kp-multiply": {
		Doc:   "Get ebiten.KeyKPMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPMultiply)))
			return resObj
		},
	},
	"key-kp-subtract": {
		Doc:   "Get ebiten.KeyKPSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPSubtract)))
			return resObj
		},
	},
	"key-l": {
		Doc:   "Get ebiten.KeyL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyL)))
			return resObj
		},
	},
	"key-left": {
		Doc:   "Get ebiten.KeyLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeft)))
			return resObj
		},
	},
	"key-left-bracket": {
		Doc:   "Get ebiten.KeyLeftBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeftBracket)))
			return resObj
		},
	},
	"key-m": {
		Doc:   "Get ebiten.KeyM value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyM)))
			return resObj
		},
	},
	"key-max": {
		Doc:   "Get ebiten.KeyMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMax)))
			return resObj
		},
	},
	"key-menu": {
		Doc:   "Get ebiten.KeyMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMenu)))
			return resObj
		},
	},
	"key-meta": {
		Doc:   "Get ebiten.KeyMeta value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMeta)))
			return resObj
		},
	},
	"key-meta-left": {
		Doc:   "Get ebiten.KeyMetaLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaLeft)))
			return resObj
		},
	},
	"key-meta-right": {
		Doc:   "Get ebiten.KeyMetaRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaRight)))
			return resObj
		},
	},
	"key-minus": {
		Doc:   "Get ebiten.KeyMinus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMinus)))
			return resObj
		},
	},
	"key-n": {
		Doc:   "Get ebiten.KeyN value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyN)))
			return resObj
		},
	},
	"key-name": {
		Doc:   "ebiten.KeyName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("key-name: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.KeyName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"key-num-lock": {
		Doc:   "Get ebiten.KeyNumLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumLock)))
			return resObj
		},
	},
	"key-numpad-0": {
		Doc:   "Get ebiten.KeyNumpad0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad0)))
			return resObj
		},
	},
	"key-numpad-1": {
		Doc:   "Get ebiten.KeyNumpad1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad1)))
			return resObj
		},
	},
	"key-numpad-2": {
		Doc:   "Get ebiten.KeyNumpad2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad2)))
			return resObj
		},
	},
	"key-numpad-3": {
		Doc:   "Get ebiten.KeyNumpad3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad3)))
			return resObj
		},
	},
	"key-numpad-4": {
		Doc:   "Get ebiten.KeyNumpad4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad4)))
			return resObj
		},
	},
	"key-numpad-5": {
		Doc:   "Get ebiten.KeyNumpad5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad5)))
			return resObj
		},
	},
	"key-numpad-6": {
		Doc:   "Get ebiten.KeyNumpad6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad6)))
			return resObj
		},
	},
	"key-numpad-7": {
		Doc:   "Get ebiten.KeyNumpad7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad7)))
			return resObj
		},
	},
	"key-numpad-8": {
		Doc:   "Get ebiten.KeyNumpad8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad8)))
			return resObj
		},
	},
	"key-numpad-9": {
		Doc:   "Get ebiten.KeyNumpad9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad9)))
			return resObj
		},
	},
	"key-numpad-add": {
		Doc:   "Get ebiten.KeyNumpadAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadAdd)))
			return resObj
		},
	},
	"key-numpad-decimal": {
		Doc:   "Get ebiten.KeyNumpadDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDecimal)))
			return resObj
		},
	},
	"key-numpad-divide": {
		Doc:   "Get ebiten.KeyNumpadDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDivide)))
			return resObj
		},
	},
	"key-numpad-enter": {
		Doc:   "Get ebiten.KeyNumpadEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEnter)))
			return resObj
		},
	},
	"key-numpad-equal": {
		Doc:   "Get ebiten.KeyNumpadEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEqual)))
			return resObj
		},
	},
	"key-numpad-multiply": {
		Doc:   "Get ebiten.KeyNumpadMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadMultiply)))
			return resObj
		},
	},
	"key-numpad-subtract": {
		Doc:   "Get ebiten.KeyNumpadSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadSubtract)))
			return resObj
		},
	},
	"key-o": {
		Doc:   "Get ebiten.KeyO value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyO)))
			return resObj
		},
	},
	"key-p": {
		Doc:   "Get ebiten.KeyP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyP)))
			return resObj
		},
	},
	"key-page-down": {
		Doc:   "Get ebiten.KeyPageDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageDown)))
			return resObj
		},
	},
	"key-page-up": {
		Doc:   "Get ebiten.KeyPageUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageUp)))
			return resObj
		},
	},
	"key-pause": {
		Doc:   "Get ebiten.KeyPause value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPause)))
			return resObj
		},
	},
	"key-period": {
		Doc:   "Get ebiten.KeyPeriod value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPeriod)))
			return resObj
		},
	},
	"key-print-screen": {
		Doc:   "Get ebiten.KeyPrintScreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPrintScreen)))
			return resObj
		},
	},
	"key-q": {
		Doc:   "Get ebiten.KeyQ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQ)))
			return resObj
		},
	},
	"key-quote": {
		Doc:   "Get ebiten.KeyQuote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQuote)))
			return resObj
		},
	},
	"key-r": {
		Doc:   "Get ebiten.KeyR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyR)))
			return resObj
		},
	},
	"key-right": {
		Doc:   "Get ebiten.KeyRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRight)))
			return resObj
		},
	},
	"key-right-bracket": {
		Doc:   "Get ebiten.KeyRightBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRightBracket)))
			return resObj
		},
	},
	"key-s": {
		Doc:   "Get ebiten.KeyS value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyS)))
			return resObj
		},
	},
	"key-scroll-lock": {
		Doc:   "Get ebiten.KeyScrollLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyScrollLock)))
			return resObj
		},
	},
	"key-semicolon": {
		Doc:   "Get ebiten.KeySemicolon value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySemicolon)))
			return resObj
		},
	},
	"key-shift": {
		Doc:   "Get ebiten.KeyShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShift)))
			return resObj
		},
	},
	"key-shift-left": {
		Doc:   "Get ebiten.KeyShiftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftLeft)))
			return resObj
		},
	},
	"key-shift-right": {
		Doc:   "Get ebiten.KeyShiftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftRight)))
			return resObj
		},
	},
	"key-slash": {
		Doc:   "Get ebiten.KeySlash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySlash)))
			return resObj
		},
	},
	"key-space": {
		Doc:   "Get ebiten.KeySpace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySpace)))
			return resObj
		},
	},
	"key-t": {
		Doc:   "Get ebiten.KeyT value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyT)))
			return resObj
		},
	},
	"key-tab": {
		Doc:   "Get ebiten.KeyTab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyTab)))
			return resObj
		},
	},
	"key-u": {
		Doc:   "Get ebiten.KeyU value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyU)))
			return resObj
		},
	},
	"key-up": {
		Doc:   "Get ebiten.KeyUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyUp)))
			return resObj
		},
	},
	"key-v": {
		Doc:   "Get ebiten.KeyV value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyV)))
			return resObj
		},
	},
	"key-w": {
		Doc:   "Get ebiten.KeyW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyW)))
			return resObj
		},
	},
	"key-x": {
		Doc:   "Get ebiten.KeyX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyX)))
			return resObj
		},
	},
	"key-y": {
		Doc:   "Get ebiten.KeyY value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyY)))
			return resObj
		},
	},
	"key-z": {
		Doc:   "Get ebiten.KeyZ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyZ)))
			return resObj
		},
	},
	"max-tps": {
		Doc:   "ebiten.MaxTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.MaxTPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"maximize-window": {
		Doc:   "ebiten.MaximizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.MaximizeWindow()
			return nil
		},
	},
	"minimize-window": {
		Doc:   "ebiten.MinimizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.MinimizeWindow()
			return nil
		},
	},
	"monitor": {
		Doc:   "ebiten.Monitor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.Monitor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.MonitorType)")
			return res0Obj
		},
	},
	"mouse-button-0": {
		Doc:   "Get ebiten.MouseButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButton0, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-1": {
		Doc:   "Get ebiten.MouseButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButton1, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-2": {
		Doc:   "Get ebiten.MouseButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButton2, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-3": {
		Doc:   "Get ebiten.MouseButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButton3, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-4": {
		Doc:   "Get ebiten.MouseButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButton4, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-left": {
		Doc:   "Get ebiten.MouseButtonLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButtonLeft, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-max": {
		Doc:   "Get ebiten.MouseButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButtonMax, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-middle": {
		Doc:   "Get ebiten.MouseButtonMiddle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButtonMiddle, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"mouse-button-right": {
		Doc:   "Get ebiten.MouseButtonRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.MouseButtonRight, "Go(ebiten.MouseButton)")
			return resObj
		},
	},
	"blend": {
		Doc:   "Create a new ebiten.Blend struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.Blend{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.Blend)")
			return resObj
		},
	},
	"color-m": {
		Doc:   "Create a new ebiten.ColorM struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.ColorM{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.ColorM)")
			return resObj
		},
	},
	"color-scale": {
		Doc:   "Create a new ebiten.ColorScale struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.ColorScale{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.ColorScale)")
			return resObj
		},
	},
	"debug-info": {
		Doc:   "Create a new ebiten.DebugInfo struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.DebugInfo{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.DebugInfo)")
			return resObj
		},
	},
	"draw-image-options": {
		Doc:   "Create a new ebiten.DrawImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.DrawImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.DrawImageOptions)")
			return resObj
		},
	},
	"draw-triangles-options": {
		Doc:   "Create a new ebiten.DrawTrianglesOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.DrawTrianglesOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.DrawTrianglesOptions)")
			return resObj
		},
	},
	"geo-m": {
		Doc:   "Create a new ebiten.GeoM struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.GeoM{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.GeoM)")
			return resObj
		},
	},
	"image": {
		Doc:   "ebiten.NewImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := ebiten.NewImage(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			return res0Obj
		},
	},
	"image-from-image": {
		Doc:   "ebiten.NewImageFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-image: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-from-image: arg 1: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-image: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-image: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.NewImageFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			return res0Obj
		},
	},
	"image-from-image-with-options": {
		Doc:   "ebiten.NewImageFromImageWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 1: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-image-with-options: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.NewImageFromImageOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageFromImageOptions); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 2: " + "expected native of type *ebiten.NewImageFromImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-image-with-options: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.NewImageFromImageWithOptions(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			return res0Obj
		},
	},
	"image-with-options": {
		Doc:   "ebiten.NewImageWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-with-options: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.NewImageOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.NewImageOptions); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 2: " + "expected native of type *ebiten.NewImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-with-options: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.NewImageWithOptions(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			return res0Obj
		},
	},
	"new-image-from-image-options": {
		Doc:   "Create a new ebiten.NewImageFromImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.NewImageFromImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.NewImageFromImageOptions)")
			return resObj
		},
	},
	"new-image-options": {
		Doc:   "Create a new ebiten.NewImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.NewImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.NewImageOptions)")
			return resObj
		},
	},
	"run-game-options": {
		Doc:   "Create a new ebiten.RunGameOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.RunGameOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.RunGameOptions)")
			return resObj
		},
	},
	"shader": {
		Doc:   "ebiten.NewShader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(byte); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("shader: arg 1: " + "block item: " + "expected native of type byte, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("shader: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("shader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("shader: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := ebiten.NewShader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Shader)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vertex": {
		Doc:   "Create a new ebiten.Vertex struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.Vertex{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.Vertex)")
			return resObj
		},
	},
	"vibrate-gamepad-options": {
		Doc:   "Create a new ebiten.VibrateGamepadOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.VibrateGamepadOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.VibrateGamepadOptions)")
			return resObj
		},
	},
	"vibrate-options": {
		Doc:   "Create a new ebiten.VibrateOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.VibrateOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten.VibrateOptions)")
			return resObj
		},
	},
	"non-zero": {
		Doc:   "Get ebiten.NonZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.NonZero)))
			return resObj
		},
	},
	"read-debug-info": {
		Doc:   "ebiten.ReadDebugInfo",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DebugInfo); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("read-debug-info: arg 1: " + "expected native of type *ebiten.DebugInfo, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("read-debug-info: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("read-debug-info: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.ReadDebugInfo(arg0Val)
			return nil
		},
	},
	"restore-window": {
		Doc:   "ebiten.RestoreWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.RestoreWindow()
			return nil
		},
	},
	"run-game": {
		Doc:   "ebiten.RunGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := ebiten.RunGame(arg0Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"run-game-with-options": {
		Doc:   "ebiten.RunGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-with-options: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 2: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-with-options: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := ebiten.RunGameWithOptions(arg0Val, arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"schedule-frame": {
		Doc:   "ebiten.ScheduleFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.ScheduleFrame()
			return nil
		},
	},
	"screen-size-in-fullscreen": {
		Doc:   "ebiten.ScreenSizeInFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.ScreenSizeInFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"set-cursor-mode": {
		Doc:   "ebiten.SetCursorMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorModeType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.CursorModeType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("set-cursor-mode: arg 1: " + "expected native of type ebiten.CursorModeType, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("set-cursor-mode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.SetCursorMode(arg0Val)
			return nil
		},
	},
	"set-cursor-shape": {
		Doc:   "ebiten.SetCursorShape",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorShapeType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.CursorShapeType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("set-cursor-shape: arg 1: " + "expected native of type ebiten.CursorShapeType, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("set-cursor-shape: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.SetCursorShape(arg0Val)
			return nil
		},
	},
	"set-fps-mode": {
		Doc:   "ebiten.SetFPSMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FPSModeType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.FPSModeType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("set-fps-mode: arg 1: " + "expected native of type ebiten.FPSModeType, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("set-fps-mode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.SetFPSMode(arg0Val)
			return nil
		},
	},
	"set-fullscreen": {
		Doc:   "ebiten.SetFullscreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-fullscreen: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetFullscreen(arg0Val)
			return nil
		},
	},
	"set-init-focused": {
		Doc:   "ebiten.SetInitFocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-init-focused: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetInitFocused(arg0Val)
			return nil
		},
	},
	"set-max-tps": {
		Doc:   "ebiten.SetMaxTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-max-tps: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetMaxTPS(arg0Val)
			return nil
		},
	},
	"set-monitor": {
		Doc:   "ebiten.SetMonitor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.MonitorType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("set-monitor: arg 1: " + "expected native of type *ebiten.MonitorType, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-monitor: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-monitor: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.SetMonitor(arg0Val)
			return nil
		},
	},
	"set-runnable-on-unfocused": {
		Doc:   "ebiten.SetRunnableOnUnfocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-runnable-on-unfocused: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetRunnableOnUnfocused(arg0Val)
			return nil
		},
	},
	"set-screen-cleared-every-frame": {
		Doc:   "ebiten.SetScreenClearedEveryFrame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-cleared-every-frame: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetScreenClearedEveryFrame(arg0Val)
			return nil
		},
	},
	"set-screen-filter-enabled": {
		Doc:   "ebiten.SetScreenFilterEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-filter-enabled: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetScreenFilterEnabled(arg0Val)
			return nil
		},
	},
	"set-screen-transparent": {
		Doc:   "ebiten.SetScreenTransparent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-transparent: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetScreenTransparent(arg0Val)
			return nil
		},
	},
	"set-tps": {
		Doc:   "ebiten.SetTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-tps: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetTPS(arg0Val)
			return nil
		},
	},
	"set-vsync-enabled": {
		Doc:   "ebiten.SetVsyncEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-vsync-enabled: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetVsyncEnabled(arg0Val)
			return nil
		},
	},
	"set-window-closing-handled": {
		Doc:   "ebiten.SetWindowClosingHandled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-closing-handled: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetWindowClosingHandled(arg0Val)
			return nil
		},
	},
	"set-window-decorated": {
		Doc:   "ebiten.SetWindowDecorated",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-decorated: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetWindowDecorated(arg0Val)
			return nil
		},
	},
	"set-window-floating": {
		Doc:   "ebiten.SetWindowFloating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-floating: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetWindowFloating(arg0Val)
			return nil
		},
	},
	"set-window-icon": {
		Doc:   "ebiten.SetWindowIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []image.Image
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]image.Image, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.RyeCtx:
						var err error
						arg0Val[i], err = ctxTo_image_Image(ps, v)
						if err != nil {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: " + "block item: " + err.Error())
						}
					case env.Native:
						if vc, ok := v.Value.(image.Image); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: " + "block item: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("set-window-icon: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-window-icon: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-window-icon: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.SetWindowIcon(arg0Val)
			return nil
		},
	},
	"set-window-mouse-passthrough": {
		Doc:   "ebiten.SetWindowMousePassthrough",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-mouse-passthrough: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetWindowMousePassthrough(arg0Val)
			return nil
		},
	},
	"set-window-position": {
		Doc:   "ebiten.SetWindowPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-position: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-position: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			ebiten.SetWindowPosition(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-resizable": {
		Doc:   "ebiten.SetWindowResizable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = vc.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-resizable: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetWindowResizable(arg0Val)
			return nil
		},
	},
	"set-window-resizing-mode": {
		Doc:   "ebiten.SetWindowResizingMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.WindowResizingModeType
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.WindowResizingModeType); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("set-window-resizing-mode: arg 1: " + "expected native of type ebiten.WindowResizingModeType, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("set-window-resizing-mode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.SetWindowResizingMode(arg0Val)
			return nil
		},
	},
	"set-window-size": {
		Doc:   "ebiten.SetWindowSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			ebiten.SetWindowSize(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-size-limits": {
		Doc:   "ebiten.SetWindowSizeLimits",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			ebiten.SetWindowSizeLimits(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"set-window-title": {
		Doc:   "ebiten.SetWindowTitle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-title: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			ebiten.SetWindowTitle(arg0Val)
			return nil
		},
	},
	"standard-gamepad-axis-left-stick-horizontal": {
		Doc:   "Get ebiten.StandardGamepadAxisLeftStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadAxisLeftStickHorizontal, "Go(ebiten.StandardGamepadAxis)")
			return resObj
		},
	},
	"standard-gamepad-axis-left-stick-vertical": {
		Doc:   "Get ebiten.StandardGamepadAxisLeftStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadAxisLeftStickVertical, "Go(ebiten.StandardGamepadAxis)")
			return resObj
		},
	},
	"standard-gamepad-axis-max": {
		Doc:   "Get ebiten.StandardGamepadAxisMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadAxisMax, "Go(ebiten.StandardGamepadAxis)")
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-horizontal": {
		Doc:   "Get ebiten.StandardGamepadAxisRightStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadAxisRightStickHorizontal, "Go(ebiten.StandardGamepadAxis)")
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-vertical": {
		Doc:   "Get ebiten.StandardGamepadAxisRightStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadAxisRightStickVertical, "Go(ebiten.StandardGamepadAxis)")
			return resObj
		},
	},
	"standard-gamepad-axis-value": {
		Doc:   "ebiten.StandardGamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("standard-gamepad-axis-value: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("standard-gamepad-axis-value: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadAxis
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadAxis); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("standard-gamepad-axis-value: arg 2: " + "expected native of type ebiten.StandardGamepadAxis, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("standard-gamepad-axis-value: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.StandardGamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"standard-gamepad-button-center-center": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonCenterCenter, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-center-left": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonCenterLeft, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-center-right": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonCenterRight, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-left": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontBottomLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonFrontBottomLeft, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-right": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontBottomRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonFrontBottomRight, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-front-top-left": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontTopLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonFrontTopLeft, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-front-top-right": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontTopRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonFrontTopRight, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-left-bottom": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonLeftBottom, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-left-left": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonLeftLeft, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-left-right": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonLeftRight, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-left-stick": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonLeftStick, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-left-top": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonLeftTop, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-max": {
		Doc:   "Get ebiten.StandardGamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonMax, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-right-bottom": {
		Doc:   "Get ebiten.StandardGamepadButtonRightBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonRightBottom, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-right-left": {
		Doc:   "Get ebiten.StandardGamepadButtonRightLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonRightLeft, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-right-right": {
		Doc:   "Get ebiten.StandardGamepadButtonRightRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonRightRight, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-right-stick": {
		Doc:   "Get ebiten.StandardGamepadButtonRightStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonRightStick, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-right-top": {
		Doc:   "Get ebiten.StandardGamepadButtonRightTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.StandardGamepadButtonRightTop, "Go(ebiten.StandardGamepadButton)")
			return resObj
		},
	},
	"standard-gamepad-button-value": {
		Doc:   "ebiten.StandardGamepadButtonValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("standard-gamepad-button-value: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("standard-gamepad-button-value: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("standard-gamepad-button-value: arg 2: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("standard-gamepad-button-value: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := ebiten.StandardGamepadButtonValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ebiten-text-append-glyphs": {
		Doc:   "ebiten_text.AppendGlyphs",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten_text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*ebiten_text.Glyph); ok {
							arg0Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("ebiten-text-append-glyphs: arg 1: " + "block item: " + "expected native of type *ebiten_text.Glyph, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-text-append-glyphs: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-append-glyphs: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-append-glyphs: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val font.Face
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(font.Face); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-append-glyphs: arg 2: " + "expected native of type font.Face, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-append-glyphs: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val string
			if vc, ok := arg2.(env.String); ok {
				arg2Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-append-glyphs: arg 3: " + "expected string, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := ebiten_text.AppendGlyphs(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, &it, "Go(*ebiten_text.Glyph)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ebiten-text-bound-string": {
		Doc:   "ebiten_text.BoundString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(font.Face); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-bound-string: arg 1: " + "expected native of type font.Face, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-bound-string: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-bound-string: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := ebiten_text.BoundString(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"ebiten-text-cache-glyphs": {
		Doc:   "ebiten_text.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(font.Face); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-cache-glyphs: arg 1: " + "expected native of type font.Face, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-cache-glyphs: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-cache-glyphs: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			ebiten_text.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"ebiten-text-draw-with-options": {
		Doc:   "ebiten_text.DrawWithOptions",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val font.Face
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(font.Face); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 3: " + "expected native of type font.Face, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *ebiten.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.DrawImageOptions); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 4: " + "expected native of type *ebiten.DrawImageOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten_text.DrawWithOptions(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"ebiten-text-face-with-line-height": {
		Doc:   "ebiten_text.FaceWithLineHeight",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(font.Face); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-face-with-line-height: arg 1: " + "expected native of type font.Face, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-face-with-line-height: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-face-with-line-height: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := ebiten_text.FaceWithLineHeight(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(font.Face)")
			return res0Obj
		},
	},
	"ebiten-text-glyph": {
		Doc:   "Create a new ebiten_text.Glyph struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten_text.Glyph{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*ebiten_text.Glyph)")
			return resObj
		},
	},
	"touch-i-ds": {
		Doc:   "ebiten.TouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.TouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.TouchID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"touch-position": {
		Doc:   "ebiten.TouchPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.TouchID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("touch-position: arg 1: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("touch-position: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := ebiten.TouchPosition(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"tps": {
		Doc:   "ebiten.TPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.TPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"update-standard-gamepad-layout-mappings": {
		Doc:   "ebiten.UpdateStandardGamepadLayoutMappings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("update-standard-gamepad-layout-mappings: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0, resErr := ebiten.UpdateStandardGamepadLayoutMappings(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vibrate": {
		Doc:   "ebiten.Vibrate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateOptions); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vibrate: arg 1: " + "expected native of type *ebiten.VibrateOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vibrate: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.Vibrate(arg0Val)
			return nil
		},
	},
	"vibrate-gamepad": {
		Doc:   "ebiten.VibrateGamepad",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate-gamepad: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.VibrateGamepadOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.VibrateGamepadOptions); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 2: " + "expected native of type *ebiten.VibrateGamepadOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate-gamepad: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebiten.VibrateGamepad(arg0Val, arg1Val)
			return nil
		},
	},
	"wheel": {
		Doc:   "ebiten.Wheel",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.Wheel()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"window-position": {
		Doc:   "ebiten.WindowPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"window-resizing-mode": {
		Doc:   "ebiten.WindowResizingMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.WindowResizingMode()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(ebiten.WindowResizingModeType)")
			return res0Obj
		},
	},
	"window-resizing-mode-disabled": {
		Doc:   "Get ebiten.WindowResizingModeDisabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.WindowResizingModeDisabled, "Go(ebiten.WindowResizingModeType)")
			return resObj
		},
	},
	"window-resizing-mode-enabled": {
		Doc:   "Get ebiten.WindowResizingModeEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.WindowResizingModeEnabled, "Go(ebiten.WindowResizingModeType)")
			return resObj
		},
	},
	"window-resizing-mode-only-fullscreen-enabled": {
		Doc:   "Get ebiten.WindowResizingModeOnlyFullscreenEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, ebiten.WindowResizingModeOnlyFullscreenEnabled, "Go(ebiten.WindowResizingModeType)")
			return resObj
		},
	},
	"window-size": {
		Doc:   "ebiten.WindowSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"window-size-limits": {
		Doc:   "ebiten.WindowSizeLimits",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1, res2, res3 := ebiten.WindowSizeLimits()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"debug-print": {
		Doc:   "ebitenutil.DebugPrint",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("debug-print: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("debug-print: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("debug-print: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			ebitenutil.DebugPrint(arg0Val, arg1Val)
			return nil
		},
	},
	"debug-print-at": {
		Doc:   "ebitenutil.DebugPrintAt",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("debug-print-at: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("debug-print-at: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			ebitenutil.DebugPrintAt(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"draw-circle": {
		Doc:   "ebitenutil.DrawCircle",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val float64
			if vc, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 2: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val float64
			if vc, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 4: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg3))
			}
			var arg4Val color.Color
			switch v := arg4.(type) {
			case env.RyeCtx:
				var err error
				arg4Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg4Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 5: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			ebitenutil.DrawCircle(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val)
			return nil
		},
	},
	"image-from-file": {
		Doc:   "ebitenutil.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-file: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0, res1, resErr := ebitenutil.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			var res1Obj env.Object
			res1Obj = ifaceToNative(ps.Idx, res1, "Go(image.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-from-file-system": {
		Doc:   "ebitenutil.NewImageFromFileSystem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val fs.FS
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_fs_FS(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(fs.FS); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: " + "expected native of type fs.FS, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-file-system: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-file-system: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0, res1, resErr := ebitenutil.NewImageFromFileSystem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			var res1Obj env.Object
			res1Obj = ifaceToNative(ps.Idx, res1, "Go(image.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-from-reader": {
		Doc:   "ebitenutil.NewImageFromReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-reader: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, resErr := ebitenutil.NewImageFromReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			var res1Obj env.Object
			res1Obj = ifaceToNative(ps.Idx, res1, "Go(image.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-from-url": {
		Doc:   "ebitenutil.NewImageFromURL",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-url: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0, resErr := ebitenutil.NewImageFromURL(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*ebiten.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"open-file": {
		Doc:   "ebitenutil.OpenFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("open-file: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0, resErr := ebitenutil.OpenFile(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(ebitenutil.ReadSeekCloser)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"flappy-gopher-png": {
		Doc:   "Get flappy.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Gopher_png))
				for i, it := range flappy.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"flappy-tiles-png": {
		Doc:   "Get flappy.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Tiles_png))
				for i, it := range flappy.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-m-plus-1-p-regular-ttf": {
		Doc:   "Get fonts.MPlus1pRegular_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.MPlus1pRegular_ttf))
				for i, it := range fonts.MPlus1pRegular_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-press-start-2-p-ttf": {
		Doc:   "Get fonts.PressStart2P_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.PressStart2P_ttf))
				for i, it := range fonts.PressStart2P_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"gif-decode": {
		Doc:   "gif.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-decode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-decode: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := gif.Decode(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gif-decode-all": {
		Doc:   "gif.DecodeAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-decode-all: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-decode-all: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-decode-all: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-decode-all: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := gif.DecodeAll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*gif.GIF)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gif-decode-config": {
		Doc:   "gif.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-decode-config: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-decode-config: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-decode-config: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-decode-config: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := gif.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Config)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gif-encode": {
		Doc:   "gif.Encode",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 1: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 2: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val *gif.Options
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.Options); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 3: " + "expected native of type *gif.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := gif.Encode(arg0Val, arg1Val, arg2Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"gif-encode-all": {
		Doc:   "gif.EncodeAll",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 1: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode-all: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *gif.GIF
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*gif.GIF); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 2: " + "expected native of type *gif.GIF, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode-all: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := gif.EncodeAll(arg0Val, arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"gif-gif": {
		Doc:   "Create a new gif.GIF struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gif.GIF{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gif.GIF)")
			return resObj
		},
	},
	"gif-options": {
		Doc:   "Create a new gif.Options struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gif.Options{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gif.Options)")
			return resObj
		},
	},
	"image-decode": {
		Doc:   "image.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-decode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-decode: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, resErr := image.Decode(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			var res1Obj env.Object
			res1Obj = *env.NewString(res1)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-decode-config": {
		Doc:   "image.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-decode-config: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-decode-config: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-decode-config: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-decode-config: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1, resErr := image.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Config)")
			var res1Obj env.Object
			res1Obj = *env.NewString(res1)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-alpha": {
		Doc:   "image.NewAlpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-alpha: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-alpha: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewAlpha(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.Alpha)")
			return res0Obj
		},
	},
	"image-alpha-16": {
		Doc:   "image.NewAlpha16",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-alpha-16: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-alpha-16: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewAlpha16(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.Alpha16)")
			return res0Obj
		},
	},
	"image-cmyk": {
		Doc:   "image.NewCMYK",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-cmyk: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-cmyk: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewCMYK(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.CMYK)")
			return res0Obj
		},
	},
	"image-config": {
		Doc:   "Create a new image.Config struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &image.Config{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*image.Config)")
			return resObj
		},
	},
	"image-gray": {
		Doc:   "image.NewGray",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-gray: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-gray: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewGray(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.Gray)")
			return res0Obj
		},
	},
	"image-gray-16": {
		Doc:   "image.NewGray16",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-gray-16: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-gray-16: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewGray16(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.Gray16)")
			return res0Obj
		},
	},
	"image-nrgba": {
		Doc:   "image.NewNRGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-nrgba: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-nrgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewNRGBA(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.NRGBA)")
			return res0Obj
		},
	},
	"image-nrgba-64": {
		Doc:   "image.NewNRGBA64",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-nrgba-64: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-nrgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewNRGBA64(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.NRGBA64)")
			return res0Obj
		},
	},
	"image-ny-cb-cr-a": {
		Doc:   "image.NewNYCbCrA",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-ny-cb-cr-a: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-ny-cb-cr-a: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.YCbCrSubsampleRatio
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("image-ny-cb-cr-a: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = image.YCbCrSubsampleRatio(u)
				}
			}
			res0 := image.NewNYCbCrA(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.NYCbCrA)")
			return res0Obj
		},
	},
	"image-paletted": {
		Doc:   "image.NewPaletted",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-paletted: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-paletted: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val color.Palette
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u []color.Color
					switch v := arg1.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("image-paletted: arg 2: " + "block item: " + err.Error())
								}
							case env.Native:
								if vc, ok := v.Value.(color.Color); ok {
									u[i] = vc
								} else {
									ps.FailureFlag = true
									return env.NewError("image-paletted: arg 2: " + "block item: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("image-paletted: arg 2: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("image-paletted: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
							}
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("image-paletted: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("image-paletted: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
					}
					arg1Val = color.Palette(u)
				}
			}
			res0 := image.NewPaletted(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.Paletted)")
			return res0Obj
		},
	},
	"image-point": {
		Doc:   "Create a new image.Point struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &image.Point{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*image.Point)")
			return resObj
		},
	},
	"image-rectangle": {
		Doc:   "Create a new image.Rectangle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &image.Rectangle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"image-rgba": {
		Doc:   "image.NewRGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-rgba: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-rgba: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewRGBA(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.RGBA)")
			return res0Obj
		},
	},
	"image-rgba-64": {
		Doc:   "image.NewRGBA64",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-rgba-64: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-rgba-64: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewRGBA64(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.RGBA64)")
			return res0Obj
		},
	},
	"image-uniform": {
		Doc:   "image.NewUniform",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-uniform: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(color.Color); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-uniform: arg 1: " + "expected native of type color.Color, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-uniform: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-uniform: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := image.NewUniform(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.Uniform)")
			return res0Obj
		},
	},
	"image-y-cb-cr": {
		Doc:   "image.NewYCbCr",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*image.Rectangle); ok {
					arg0Val = *vc
				} else {
					ps.FailureFlag = true
					return env.NewError("image-y-cb-cr: arg 1: " + "expected native of type *image.Rectangle, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("image-y-cb-cr: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.YCbCrSubsampleRatio
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if vc, ok := arg1.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("image-y-cb-cr: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
					}
					arg1Val = image.YCbCrSubsampleRatio(u)
				}
			}
			res0 := image.NewYCbCr(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*image.YCbCr)")
			return res0Obj
		},
	},
	"image-pt": {
		Doc:   "image.Pt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-pt: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-pt: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0 := image.Pt(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Point)")
			return res0Obj
		},
	},
	"image-rect": {
		Doc:   "image.Rect",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			var arg3Val int
			if vc, ok := arg3.(env.Integer); ok {
				arg3Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 4: " + "expected integer, but got " + objectDebugString(ps.Idx, arg3))
			}
			res0 := image.Rect(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			return res0Obj
		},
	},
	"image-register-format": {
		Doc:   "image.RegisterFormat",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val func(io.Reader) (image.Image, error)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 3: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg2Val = func(farg0 io.Reader) (image.Image, error) {
					var farg0Val env.Object
					farg0Val = ifaceToNative(ps.Idx, farg0, "Go(io.Reader)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res0 image.Image
					var res1 error
					res, ok := ps.Res.(env.Block)
					if !ok {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					if len(res.Series.S) != 2 {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[0].(type) {
					case env.RyeCtx:
						var err error
						res0, err = ctxTo_image_Image(ps, v)
						if err != nil {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: "+err.Error(),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
					case env.Native:
						if vc, ok := v.Value.(image.Image); ok {
							res0 = vc
						} else {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: "+"expected native of type image.Image, but got "+objectDebugString(ps.Idx, v),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
						res0 = nil
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[1].(type) {
					case env.String:
						res1 = errors.New(v.Value)
					case env.Error:
						res1 = errors.New(v.Print(*ps.Idx))
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
						res1 = nil
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					return res0, res1
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 3: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			var arg3Val func(io.Reader) (image.Config, error)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 4: " + "expected 1 function arguments, but got " + strconv.Itoa(fn.Argsn))
				}
				arg3Val = func(farg0 io.Reader) (image.Config, error) {
					var farg0Val env.Object
					farg0Val = ifaceToNative(ps.Idx, farg0, "Go(io.Reader)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
					var res0 image.Config
					var res1 error
					res, ok := ps.Res.(env.Block)
					if !ok {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: "+"expected block for multiple return values, but got "+objectDebugString(ps.Idx, ps.Res),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					if len(res.Series.S) != 2 {
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: "+"expected block with 2 return values, but got "+strconv.Itoa(len(res.Series.S))+" return values",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[0].(type) {
					case env.Native:
						if vc, ok := v.Value.(*image.Config); ok {
							res0 = *vc
						} else {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 4: callback result: "+"expected native of type *image.Config, but got "+objectDebugString(ps.Idx, v),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: "+"expected native, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[1].(type) {
					case env.String:
						res1 = errors.New(v.Value)
					case env.Error:
						res1 = errors.New(v.Print(*ps.Idx))
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 4: callback result: "+"expected integer to be 0 or nil, but got "+strconv.FormatInt(v.Value, 10),
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
						res1 = nil
					default:
						ps.FailureFlag = true
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: "+"expected error, string or nil, but got "+objectDebugString(ps.Idx, v),
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					return res0, res1
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(fn.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 4: " + "expected function or nil, but got " + objectDebugString(ps.Idx, fn))
			}
			image.RegisterFormat(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"image-y-cb-cr-subsample-ratio-410": {
		Doc:   "Get image.YCbCrSubsampleRatio410 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio410)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-411": {
		Doc:   "Get image.YCbCrSubsampleRatio411 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio411)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-420": {
		Doc:   "Get image.YCbCrSubsampleRatio420 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio420)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-422": {
		Doc:   "Get image.YCbCrSubsampleRatio422 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio422)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-440": {
		Doc:   "Get image.YCbCrSubsampleRatio440 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio440)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-444": {
		Doc:   "Get image.YCbCrSubsampleRatio444 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio444)))
			return resObj
		},
	},
	"image-zp": {
		Doc:   "Get image.ZP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &image.ZP, "Go(*image.Point)")
			return resObj
		},
	},
	"image-zr": {
		Doc:   "Get image.ZR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &image.ZR, "Go(*image.Rectangle)")
			return resObj
		},
	},
	"images-audio-alert-png": {
		Doc:   "Get images_audio.Alert_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_audio.Alert_png))
				for i, it := range images_audio.Alert_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-audio-pause-png": {
		Doc:   "Get images_audio.Pause_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_audio.Pause_png))
				for i, it := range images_audio.Pause_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-audio-play-png": {
		Doc:   "Get images_audio.Play_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_audio.Play_png))
				for i, it := range images_audio.Play_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-blocks-background-png": {
		Doc:   "Get images_blocks.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_blocks.Background_png))
				for i, it := range images_blocks.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-blocks-blocks-png": {
		Doc:   "Get images_blocks.Blocks_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_blocks.Blocks_png))
				for i, it := range images_blocks.Blocks_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ebiten-png": {
		Doc:   "Get images.Ebiten_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Ebiten_png))
				for i, it := range images.Ebiten_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-five-years-jpg": {
		Doc:   "Get images.FiveYears_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.FiveYears_jpg))
				for i, it := range images.FiveYears_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-gophers-jpg": {
		Doc:   "Get images.Gophers_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Gophers_jpg))
				for i, it := range images.Gophers_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-keyboard-keyboard-png": {
		Doc:   "Get images_keyboard.Keyboard_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_keyboard.Keyboard_png))
				for i, it := range images_keyboard.Keyboard_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-runner-png": {
		Doc:   "Get images.Runner_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Runner_png))
				for i, it := range images.Runner_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-gopher-bg-png": {
		Doc:   "Get images_shader.GopherBg_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.GopherBg_png))
				for i, it := range images_shader.GopherBg_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-gopher-png": {
		Doc:   "Get images_shader.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.Gopher_png))
				for i, it := range images_shader.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-noise-png": {
		Doc:   "Get images_shader.Noise_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.Noise_png))
				for i, it := range images_shader.Noise_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-normal-png": {
		Doc:   "Get images_shader.Normal_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.Normal_png))
				for i, it := range images_shader.Normal_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-smoke-png": {
		Doc:   "Get images.Smoke_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Smoke_png))
				for i, it := range images.Smoke_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-spritesheet-png": {
		Doc:   "Get images.Spritesheet_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Spritesheet_png))
				for i, it := range images.Spritesheet_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tile-png": {
		Doc:   "Get images.Tile_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tile_png))
				for i, it := range images.Tile_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tiles-png": {
		Doc:   "Get images.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tiles_png))
				for i, it := range images.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ui-png": {
		Doc:   "Get images.UI_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.UI_png))
				for i, it := range images.UI_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"inpututil-append-just-connected-gamepad-i-ds": {
		Doc:   "inpututil.AppendJustConnectedGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.GamepadID); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: " + "block item: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustConnectedGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-gamepad-buttons": {
		Doc:   "inpututil.AppendJustPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.GamepadButton); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: " + "block item: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadButton)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-keys": {
		Doc:   "inpututil.AppendJustPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if vc, ok := it.(env.Integer); ok {
								u = int(vc.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-keys: arg 1: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-keys: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-keys: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendJustPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: " + "block item: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.StandardGamepadButton)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-touch-i-ds": {
		Doc:   "inpututil.AppendJustPressedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.TouchID); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: " + "block item: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustPressedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.TouchID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-gamepad-buttons": {
		Doc:   "inpututil.AppendJustReleasedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.GamepadButton); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: " + "block item: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustReleasedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadButton)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-keys": {
		Doc:   "inpututil.AppendJustReleasedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if vc, ok := it.(env.Integer); ok {
								u = int(vc.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-keys: arg 1: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-keys: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-keys: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustReleasedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendJustReleasedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: " + "block item: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustReleasedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.StandardGamepadButton)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-touch-i-ds": {
		Doc:   "inpututil.AppendJustReleasedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.TouchID); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: " + "block item: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendJustReleasedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.TouchID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-gamepad-buttons": {
		Doc:   "inpututil.AppendPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.GamepadButton); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: " + "block item: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadButton)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-keys": {
		Doc:   "inpututil.AppendPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if vc, ok := it.(env.Integer); ok {
								u = int(vc.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-keys: arg 1: " + "block item: " + "expected integer, but got " + objectDebugString(ps.Idx, it))
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-keys: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-keys: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
							arg1Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: " + "block item: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.AppendPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.StandardGamepadButton)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-gamepad-button-press-duration": {
		Doc:   "inpututil.GamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-gamepad-button-press-duration: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-gamepad-button-press-duration: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-gamepad-button-press-duration: arg 2: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-gamepad-button-press-duration: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.GamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-pressed": {
		Doc:   "inpututil.IsGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 2: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-released": {
		Doc:   "inpututil.IsGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-gamepad-button-just-released: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-gamepad-button-just-released: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-gamepad-button-just-released: arg 2: " + "expected native of type ebiten.GamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-gamepad-button-just-released: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-just-disconnected": {
		Doc:   "inpututil.IsGamepadJustDisconnected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-gamepad-just-disconnected: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-gamepad-just-disconnected: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsGamepadJustDisconnected(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-pressed": {
		Doc:   "inpututil.IsKeyJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-key-just-pressed: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-released": {
		Doc:   "inpututil.IsKeyJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-key-just-released: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-pressed": {
		Doc:   "inpututil.IsMouseButtonJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.MouseButton); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-mouse-button-just-pressed: arg 1: " + "expected native of type ebiten.MouseButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-mouse-button-just-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsMouseButtonJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-released": {
		Doc:   "inpututil.IsMouseButtonJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.MouseButton); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-mouse-button-just-released: arg 1: " + "expected native of type ebiten.MouseButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-mouse-button-just-released: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsMouseButtonJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-pressed": {
		Doc:   "inpututil.IsStandardGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 2: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsStandardGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-released": {
		Doc:   "inpututil.IsStandardGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 2: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsStandardGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-touch-just-released": {
		Doc:   "inpututil.IsTouchJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.TouchID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-is-touch-just-released: arg 1: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-is-touch-just-released: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.IsTouchJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-just-connected-gamepad-i-ds": {
		Doc:   "inpututil.JustConnectedGamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.JustConnectedGamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.GamepadID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-just-pressed-touch-i-ds": {
		Doc:   "inpututil.JustPressedTouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.JustPressedTouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(ebiten.TouchID)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-key-press-duration": {
		Doc:   "inpututil.KeyPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-key-press-duration: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.KeyPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-mouse-button-press-duration": {
		Doc:   "inpututil.MouseButtonPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.MouseButton); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-mouse-button-press-duration: arg 1: " + "expected native of type ebiten.MouseButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-mouse-button-press-duration: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.MouseButtonPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-pressed-keys": {
		Doc:   "inpututil.PressedKeys",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.PressedKeys()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-standard-gamepad-button-press-duration": {
		Doc:   "inpututil.StandardGamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.GamepadID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 1: " + "expected native of type ebiten.GamepadID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.StandardGamepadButton); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 2: " + "expected native of type ebiten.StandardGamepadButton, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.StandardGamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-touch-position-in-previous-tick": {
		Doc:   "inpututil.TouchPositionInPreviousTick",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.TouchID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-touch-position-in-previous-tick: arg 1: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-touch-position-in-previous-tick: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, res1 := inpututil.TouchPositionInPreviousTick(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"inpututil-touch-press-duration": {
		Doc:   "inpututil.TouchPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(ebiten.TouchID); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("inpututil-touch-press-duration: arg 1: " + "expected native of type ebiten.TouchID, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-touch-press-duration: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := inpututil.TouchPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"jpeg-decode": {
		Doc:   "jpeg.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := jpeg.Decode(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"jpeg-decode-config": {
		Doc:   "jpeg.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode-config: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode-config: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode-config: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-decode-config: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := jpeg.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Config)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"jpeg-encode": {
		Doc:   "jpeg.Encode",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 1: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-encode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 2: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-encode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val *jpeg.Options
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(*jpeg.Options); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 3: " + "expected native of type *jpeg.Options, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-encode: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := jpeg.Encode(arg0Val, arg1Val, arg2Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"jpeg-options": {
		Doc:   "Create a new jpeg.Options struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &jpeg.Options{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*jpeg.Options)")
			return resObj
		},
	},
	"keyboard-key-rect": {
		Doc:   "keyboard.KeyRect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if vc, ok := arg0.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("keyboard-key-rect: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, res1 := keyboard.KeyRect(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Rectangle)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"mascot-out-01-png": {
		Doc:   "Get mascot.Out01_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out01_png))
				for i, it := range mascot.Out01_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-02-png": {
		Doc:   "Get mascot.Out02_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out02_png))
				for i, it := range mascot.Out02_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-03-png": {
		Doc:   "Get mascot.Out03_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out03_png))
				for i, it := range mascot.Out03_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mobile-set-game": {
		Doc:   "mobile.SetGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			mobile.SetGame(arg0Val)
			return nil
		},
	},
	"mobile-set-game-with-options": {
		Doc:   "mobile.SetGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(ebiten.Game); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: " + "expected native of type ebiten.Game, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game-with-options: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.RunGameOptions); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 2: " + "expected native of type *ebiten.RunGameOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game-with-options: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			mobile.SetGameWithOptions(arg0Val, arg1Val)
			return nil
		},
	},
	"mp-3-decode": {
		Doc:   "mp3.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := mp3.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*mp3.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"mp-3-decode-with-sample-rate": {
		Doc:   "mp3.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-with-sample-rate: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-with-sample-rate: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := mp3.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*mp3.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"mp-3-decode-without-resampling": {
		Doc:   "mp3.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-without-resampling: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := mp3.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*mp3.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"mp-3-stream": {
		Doc:   "Create a new mp3.Stream struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &mp3.Stream{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*mp3.Stream)")
			return resObj
		},
	},
	"platformer-background-png": {
		Doc:   "Get platformer.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Background_png))
				for i, it := range platformer.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-left-png": {
		Doc:   "Get platformer.Left_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Left_png))
				for i, it := range platformer.Left_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-main-char-png": {
		Doc:   "Get platformer.MainChar_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.MainChar_png))
				for i, it := range platformer.MainChar_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-right-png": {
		Doc:   "Get platformer.Right_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Right_png))
				for i, it := range platformer.Right_png {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"png-best-compression": {
		Doc:   "Get png.BestCompression value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.BestCompression)))
			return resObj
		},
	},
	"png-best-speed": {
		Doc:   "Get png.BestSpeed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.BestSpeed)))
			return resObj
		},
	},
	"png-decode": {
		Doc:   "png.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-decode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("png-decode: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := png.Decode(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(image.Image)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"png-decode-config": {
		Doc:   "png.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-decode-config: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("png-decode-config: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-decode-config: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-decode-config: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := png.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*image.Config)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"png-default-compression": {
		Doc:   "Get png.DefaultCompression value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.DefaultCompression)))
			return resObj
		},
	},
	"png-encode": {
		Doc:   "png.Encode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Writer); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 1: " + "expected native of type io.Writer, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val image.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(image.Image); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 2: " + "expected native of type image.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			resErr := png.Encode(arg0Val, arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"png-encoder": {
		Doc:   "Create a new png.Encoder struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &png.Encoder{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*png.Encoder)")
			return resObj
		},
	},
	"png-no-compression": {
		Doc:   "Get png.NoCompression value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.NoCompression)))
			return resObj
		},
	},
	"resources-audio-jab-wav": {
		Doc:   "Get resources_audio.Jab_wav value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Jab_wav))
				for i, it := range resources_audio.Jab_wav {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"resources-audio-jump-ogg": {
		Doc:   "Get resources_audio.Jump_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Jump_ogg))
				for i, it := range resources_audio.Jump_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"resources-audio-ragtime-mp-3": {
		Doc:   "Get resources_audio.Ragtime_mp3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Ragtime_mp3))
				for i, it := range resources_audio.Ragtime_mp3 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"resources-audio-ragtime-ogg": {
		Doc:   "Get resources_audio.Ragtime_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Ragtime_ogg))
				for i, it := range resources_audio.Ragtime_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"text-advance": {
		Doc:   "text.Advance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-advance: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val text.Face
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-advance: arg 2: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-advance: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-advance: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := text.Advance(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-align-center": {
		Doc:   "Get text.AlignCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.AlignCenter)))
			return resObj
		},
	},
	"text-align-end": {
		Doc:   "Get text.AlignEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.AlignEnd)))
			return resObj
		},
	},
	"text-align-start": {
		Doc:   "Get text.AlignStart value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.AlignStart)))
			return resObj
		},
	},
	"text-append-glyphs": {
		Doc:   "text.AppendGlyphs",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(*text.Glyph); ok {
							arg0Val[i] = *vc
						} else {
							ps.FailureFlag = true
							return env.NewError("text-append-glyphs: arg 1: " + "block item: " + "expected native of type *text.Glyph, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("text-append-glyphs: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val text.Face
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 3: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *text.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 4: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := text.AppendGlyphs(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, &it, "Go(*text.Glyph)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"text-append-vector-path": {
		Doc:   "text.AppendVectorPath",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*vector.Path); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 1: " + "expected native of type *vector.Path, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val text.Face
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 3: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *text.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.LayoutOptions); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 4: " + "expected native of type *text.LayoutOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			text.AppendVectorPath(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-cache-glyphs": {
		Doc:   "text.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-cache-glyphs: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val text.Face
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-cache-glyphs: arg 2: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-cache-glyphs: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-cache-glyphs: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			text.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"text-direction-left-to-right": {
		Doc:   "Get text.DirectionLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionLeftToRight)))
			return resObj
		},
	},
	"text-direction-right-to-left": {
		Doc:   "Get text.DirectionRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionRightToLeft)))
			return resObj
		},
	},
	"text-direction-top-to-bottom-and-left-to-right": {
		Doc:   "Get text.DirectionTopToBottomAndLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionTopToBottomAndLeftToRight)))
			return resObj
		},
	},
	"text-direction-top-to-bottom-and-right-to-left": {
		Doc:   "Get text.DirectionTopToBottomAndRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionTopToBottomAndRightToLeft)))
			return resObj
		},
	},
	"text-draw": {
		Doc:   "text.Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*ebiten.Image); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 1: " + "expected native of type *ebiten.Image, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val string
			if vc, ok := arg1.(env.String); ok {
				arg1Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 2: " + "expected string, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val text.Face
			switch v := arg2.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg2Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 3: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 3: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 3: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg3Val *text.DrawOptions
			switch v := arg3.(type) {
			case env.Native:
				if vc, ok := v.Value.(*text.DrawOptions); ok {
					arg3Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 4: " + "expected native of type *text.DrawOptions, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 4: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 4: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			text.Draw(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-measure": {
		Doc:   "text.Measure",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-measure: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val text.Face
			switch v := arg1.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-measure: arg 2: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-measure: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-measure: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg2Val float64
			if vc, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-measure: arg 3: " + "expected decimal, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0, res1 := text.Measure(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"text-must-parse-tag": {
		Doc:   "text.MustParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-must-parse-tag: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0 := text.MustParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			return res0Obj
		},
	},
	"text-draw-options": {
		Doc:   "Create a new text.DrawOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.DrawOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.DrawOptions)")
			return resObj
		},
	},
	"text-glyph": {
		Doc:   "Create a new text.Glyph struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Glyph{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.Glyph)")
			return resObj
		},
	},
	"text-go-text-face": {
		Doc:   "Create a new text.GoTextFace struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.GoTextFace{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.GoTextFace)")
			return resObj
		},
	},
	"text-go-text-face-source": {
		Doc:   "text.NewGoTextFaceSource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-source: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-source: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-source: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-go-text-face-source: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := text.NewGoTextFaceSource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*text.GoTextFaceSource)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-go-text-face-sources-from-collection": {
		Doc:   "text.NewGoTextFaceSourcesFromCollection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-sources-from-collection: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-sources-from-collection: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-sources-from-collection: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-go-text-face-sources-from-collection: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := text.NewGoTextFaceSourcesFromCollection(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(*text.GoTextFaceSource)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-go-x-face": {
		Doc:   "text.NewGoXFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(font.Face); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-go-x-face: arg 1: " + "expected native of type font.Face, but got " + objectDebugString(ps.Idx, v))
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-go-x-face: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := text.NewGoXFace(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*text.GoXFace)")
			return res0Obj
		},
	},
	"text-layout-options": {
		Doc:   "Create a new text.LayoutOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.LayoutOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.LayoutOptions)")
			return resObj
		},
	},
	"text-limited-face": {
		Doc:   "text.NewLimitedFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Face
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(text.Face); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("text-limited-face: arg 1: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-limited-face: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-limited-face: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0 := text.NewLimitedFace(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*text.LimitedFace)")
			return res0Obj
		},
	},
	"text-metadata": {
		Doc:   "Create a new text.Metadata struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Metadata{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.Metadata)")
			return resObj
		},
	},
	"text-metrics": {
		Doc:   "Create a new text.Metrics struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Metrics{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.Metrics)")
			return resObj
		},
	},
	"text-multi-face": {
		Doc:   "text.NewMultiFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.Face
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.Face, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						if vc, ok := v.Value.(text.Face); ok {
							arg0Val[i] = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("text-multi-face: arg 1: " + "block item: " + "expected native of type text.Face, but got " + objectDebugString(ps.Idx, v))
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("text-multi-face: arg 1: " + "block item: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("text-multi-face: arg 1: " + "block item: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-multi-face: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-multi-face: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := text.NewMultiFace(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*text.MultiFace)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-parse-tag": {
		Doc:   "text.ParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if vc, ok := arg0.(env.String); ok {
				arg0Val = string(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-parse-tag: arg 1: " + "expected string, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0, resErr := text.ParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-stretch-condensed": {
		Doc:   "Get text.StretchCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchCondensed)))
			return resObj
		},
	},
	"text-stretch-expanded": {
		Doc:   "Get text.StretchExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchExpanded)))
			return resObj
		},
	},
	"text-stretch-extra-condensed": {
		Doc:   "Get text.StretchExtraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchExtraCondensed)))
			return resObj
		},
	},
	"text-stretch-extra-expanded": {
		Doc:   "Get text.StretchExtraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchExtraExpanded)))
			return resObj
		},
	},
	"text-stretch-normal": {
		Doc:   "Get text.StretchNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchNormal)))
			return resObj
		},
	},
	"text-stretch-semi-condensed": {
		Doc:   "Get text.StretchSemiCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchSemiCondensed)))
			return resObj
		},
	},
	"text-stretch-semi-expanded": {
		Doc:   "Get text.StretchSemiExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchSemiExpanded)))
			return resObj
		},
	},
	"text-stretch-ultra-condensed": {
		Doc:   "Get text.StretchUltraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchUltraCondensed)))
			return resObj
		},
	},
	"text-stretch-ultra-expanded": {
		Doc:   "Get text.StretchUltraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchUltraExpanded)))
			return resObj
		},
	},
	"text-style-italic": {
		Doc:   "Get text.StyleItalic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.StyleItalic)))
			return resObj
		},
	},
	"text-style-normal": {
		Doc:   "Get text.StyleNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.StyleNormal)))
			return resObj
		},
	},
	"text-weight-black": {
		Doc:   "Get text.WeightBlack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightBlack)))
			return resObj
		},
	},
	"text-weight-bold": {
		Doc:   "Get text.WeightBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightBold)))
			return resObj
		},
	},
	"text-weight-extra-bold": {
		Doc:   "Get text.WeightExtraBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightExtraBold)))
			return resObj
		},
	},
	"text-weight-extra-light": {
		Doc:   "Get text.WeightExtraLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightExtraLight)))
			return resObj
		},
	},
	"text-weight-light": {
		Doc:   "Get text.WeightLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightLight)))
			return resObj
		},
	},
	"text-weight-medium": {
		Doc:   "Get text.WeightMedium value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightMedium)))
			return resObj
		},
	},
	"text-weight-normal": {
		Doc:   "Get text.WeightNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightNormal)))
			return resObj
		},
	},
	"text-weight-semibold": {
		Doc:   "Get text.WeightSemibold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightSemibold)))
			return resObj
		},
	},
	"text-weight-thin": {
		Doc:   "Get text.WeightThin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightThin)))
			return resObj
		},
	},
	"textinput-field": {
		Doc:   "Create a new textinput.Field struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &textinput.Field{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*textinput.Field)")
			return resObj
		},
	},
	"textinput-state": {
		Doc:   "Create a new textinput.State struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &textinput.State{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*textinput.State)")
			return resObj
		},
	},
	"textinput-start": {
		Doc:   "textinput.Start",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-start: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-start: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			res0, res1 := textinput.Start(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(chan textinput.State)")
			var res1Obj env.Object
			res1Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				res1()
				return nil
			}, 0, false, false, "Returned func")
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"twenty-48-dir-down": {
		Doc:   "Get twenty48.DirDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirDown)))
			return resObj
		},
	},
	"twenty-48-dir-left": {
		Doc:   "Get twenty48.DirLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirLeft)))
			return resObj
		},
	},
	"twenty-48-dir-right": {
		Doc:   "Get twenty48.DirRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirRight)))
			return resObj
		},
	},
	"twenty-48-dir-up": {
		Doc:   "Get twenty48.DirUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirUp)))
			return resObj
		},
	},
	"twenty-48-move-tiles": {
		Doc:   "twenty48.MoveTiles",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val map[*twenty48.Tile]struct{}
			switch v := arg0.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("twenty-48-move-tiles: arg 1: " + "expected block to have length of multiple of 2, but got block with length " + strconv.Itoa(len(v.Series.S)))
				}
				arg0Val = make(map[*twenty48.Tile]struct{}, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK *twenty48.Tile
					switch v := v.Series.S[i+0].(type) {
					case env.Native:
						if vc, ok := v.Value.(*twenty48.Tile); ok {
							mapK = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("twenty-48-move-tiles: arg 1: " + "map key: " + "expected native of type *twenty48.Tile, but got " + objectDebugString(ps.Idx, v))
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("twenty-48-move-tiles: arg 1: " + "map key: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
						}
						mapK = nil
					default:
						ps.FailureFlag = true
						return env.NewError("twenty-48-move-tiles: arg 1: " + "map key: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					var mapV struct{}
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						if vc, ok := v.Value.(struct{}); ok {
							mapV = vc
						} else {
							ps.FailureFlag = true
							return env.NewError("twenty-48-move-tiles: arg 1: " + "map value: " + "expected native of type struct{}, but got " + objectDebugString(ps.Idx, v))
						}
					default:
						ps.FailureFlag = true
						return env.NewError("twenty-48-move-tiles: arg 1: " + "map value: " + "expected native, but got " + objectDebugString(ps.Idx, v))
					}
					arg0Val[mapK] = mapV
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("twenty-48-move-tiles: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("twenty-48-move-tiles: arg 1: " + "expected block or nil, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-move-tiles: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val twenty48.Dir
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u int
					if vc, ok := arg2.(env.Integer); ok {
						u = int(vc.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("twenty-48-move-tiles: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
					}
					arg2Val = twenty48.Dir(u)
				}
			}
			res0 := twenty48.MoveTiles(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"twenty-48-board": {
		Doc:   "twenty48.NewBoard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-board: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			res0, resErr := twenty48.NewBoard(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*twenty48.Board)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"twenty-48-game": {
		Doc:   "twenty48.NewGame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, resErr := twenty48.NewGame()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*twenty48.Game)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"twenty-48-input": {
		Doc:   "twenty48.NewInput",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := twenty48.NewInput()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*twenty48.Input)")
			return res0Obj
		},
	},
	"twenty-48-tile": {
		Doc:   "twenty48.NewTile",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val int
			if vc, ok := arg1.(env.Integer); ok {
				arg1Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 2: " + "expected integer, but got " + objectDebugString(ps.Idx, arg1))
			}
			var arg2Val int
			if vc, ok := arg2.(env.Integer); ok {
				arg2Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 3: " + "expected integer, but got " + objectDebugString(ps.Idx, arg2))
			}
			res0 := twenty48.NewTile(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*twenty48.Tile)")
			return res0Obj
		},
	},
	"twenty-48-tile-data": {
		Doc:   "Create a new twenty48.TileData struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &twenty48.TileData{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*twenty48.TileData)")
			return resObj
		},
	},
	"vector-clockwise": {
		Doc:   "Get vector.Clockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.Clockwise)))
			return resObj
		},
	},
	"vector-counter-clockwise": {
		Doc:   "Get vector.CounterClockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.CounterClockwise)))
			return resObj
		},
	},
	"vector-line-cap-butt": {
		Doc:   "Get vector.LineCapButt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapButt)))
			return resObj
		},
	},
	"vector-line-cap-round": {
		Doc:   "Get vector.LineCapRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapRound)))
			return resObj
		},
	},
	"vector-line-cap-square": {
		Doc:   "Get vector.LineCapSquare value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapSquare)))
			return resObj
		},
	},
	"vector-line-join-bevel": {
		Doc:   "Get vector.LineJoinBevel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinBevel)))
			return resObj
		},
	},
	"vector-line-join-miter": {
		Doc:   "Get vector.LineJoinMiter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinMiter)))
			return resObj
		},
	},
	"vector-line-join-round": {
		Doc:   "Get vector.LineJoinRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinRound)))
			return resObj
		},
	},
	"vector-path": {
		Doc:   "Create a new vector.Path struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &vector.Path{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*vector.Path)")
			return resObj
		},
	},
	"vector-stroke-options": {
		Doc:   "Create a new vector.StrokeOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &vector.StrokeOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*vector.StrokeOptions)")
			return resObj
		},
	},
	"vorbis-decode": {
		Doc:   "vorbis.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := vorbis.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*vorbis.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vorbis-decode-with-sample-rate": {
		Doc:   "vorbis.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-with-sample-rate: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-with-sample-rate: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := vorbis.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*vorbis.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vorbis-decode-without-resampling": {
		Doc:   "vorbis.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-without-resampling: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := vorbis.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*vorbis.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vorbis-stream": {
		Doc:   "Create a new vorbis.Stream struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &vorbis.Stream{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*vorbis.Stream)")
			return resObj
		},
	},
	"wav-decode": {
		Doc:   "wav.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				if vc, ok := v.Value.(*audio.Context); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 1: " + "expected native of type *audio.Context, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := wav.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*wav.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"wav-decode-with-sample-rate": {
		Doc:   "wav.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if vc, ok := arg0.(env.Integer); ok {
				arg0Val = int(vc.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("wav-decode-with-sample-rate: arg 1: " + "expected integer, but got " + objectDebugString(ps.Idx, arg0))
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg1Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode-with-sample-rate: arg 2: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := wav.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*wav.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"wav-decode-without-resampling": {
		Doc:   "wav.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: " + err.Error())
				}
			case env.Native:
				if vc, ok := v.Value.(io.Reader); ok {
					arg0Val = vc
				} else {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: " + "expected native of type io.Reader, but got " + objectDebugString(ps.Idx, v))
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: " + "expected integer to be 0 or nil, but got " + strconv.FormatInt(v.Value, 10))
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode-without-resampling: arg 1: " + "expected native, but got " + objectDebugString(ps.Idx, v))
			}
			res0, resErr := wav.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*wav.Stream)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"wav-stream": {
		Doc:   "Create a new wav.Stream struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &wav.Stream{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*wav.Stream)")
			return resObj
		},
	},
}
