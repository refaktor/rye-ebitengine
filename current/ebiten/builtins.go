// Code generated by ryegen. DO NOT EDIT.

//go:build b_ebiten

package ebiten

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/audio"
	"github.com/hajimehoshi/ebiten/v2/audio/mp3"
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis"
	"github.com/hajimehoshi/ebiten/v2/audio/wav"
	"github.com/hajimehoshi/ebiten/v2/colorm"
	"github.com/hajimehoshi/ebiten/v2/ebitenutil"
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048"
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/keyboard/keyboard"
	resources_audio "github.com/hajimehoshi/ebiten/v2/examples/resources/audio"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/fonts"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images"
	images_audio "github.com/hajimehoshi/ebiten/v2/examples/resources/images/audio"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/blend"
	images_blocks "github.com/hajimehoshi/ebiten/v2/examples/resources/images/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/flappy"
	images_keyboard "github.com/hajimehoshi/ebiten/v2/examples/resources/images/keyboard"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/mascot"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/platformer"
	images_shader "github.com/hajimehoshi/ebiten/v2/examples/resources/images/shader"
	"github.com/hajimehoshi/ebiten/v2/exp/textinput"
	"github.com/hajimehoshi/ebiten/v2/inpututil"
	"github.com/hajimehoshi/ebiten/v2/mobile"
	ebiten_text "github.com/hajimehoshi/ebiten/v2/text"
	"github.com/hajimehoshi/ebiten/v2/text/v2"
	"github.com/hajimehoshi/ebiten/v2/vector"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"golang.org/x/image/font"
	"golang.org/x/text/language"
	"image"
	"image/color"
	"image/draw"
	"image/gif"
	"image/jpeg"
	"image/png"
	"io"
	"io/fs"
	"reflect"
	"time"
	"unicode"
)

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

var ryeStructNameLookup = map[string]string{
	"bytes.*Buffer": "ptr-bytes-buffer",
	"bytes.*Reader": "ptr-bytes-reader",
	"github.com/hajimehoshi/ebiten/v2.*Blend":                               "ptr-ebiten-blend",
	"github.com/hajimehoshi/ebiten/v2.*ColorScale":                          "ptr-ebiten-color-scale",
	"github.com/hajimehoshi/ebiten/v2.*DebugInfo":                           "ptr-ebiten-debug-info",
	"github.com/hajimehoshi/ebiten/v2.*DrawImageOptions":                    "ptr-ebiten-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2.*DrawTrianglesOptions":                "ptr-ebiten-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2.*GeoM":                                "ptr-ebiten-geo-m",
	"github.com/hajimehoshi/ebiten/v2.*Image":                               "ptr-ebiten-image",
	"github.com/hajimehoshi/ebiten/v2.*NewImageFromImageOptions":            "ptr-ebiten-new-image-from-image-options",
	"github.com/hajimehoshi/ebiten/v2.*NewImageOptions":                     "ptr-ebiten-new-image-options",
	"github.com/hajimehoshi/ebiten/v2.*RunGameOptions":                      "ptr-ebiten-run-game-options",
	"github.com/hajimehoshi/ebiten/v2.*Shader":                              "ptr-ebiten-shader",
	"github.com/hajimehoshi/ebiten/v2.*Vertex":                              "ptr-ebiten-vertex",
	"github.com/hajimehoshi/ebiten/v2.*VibrateGamepadOptions":               "ptr-ebiten-vibrate-gamepad-options",
	"github.com/hajimehoshi/ebiten/v2.*VibrateOptions":                      "ptr-ebiten-vibrate-options",
	"github.com/hajimehoshi/ebiten/v2/audio.*InfiniteLoop":                  "ptr-audio-infinite-loop",
	"github.com/hajimehoshi/ebiten/v2/audio.*Player":                        "ptr-audio-player",
	"github.com/hajimehoshi/ebiten/v2/audio/mp3.*Stream":                    "ptr-mp-3-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis.*Stream":                 "ptr-vorbis-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/wav.*Stream":                    "ptr-wav-stream",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawImageOptions":             "ptr-colorm-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawTrianglesOptions":         "ptr-colorm-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Game":             "ptr-twenty-48-game",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Input":            "ptr-twenty-48-input",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Tile":             "ptr-twenty-48-tile",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*TileData":         "ptr-twenty-48-tile-data",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Game":         "ptr-blocks-game",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameScene":    "ptr-blocks-game-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameState":    "ptr-blocks-game-state",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GamepadScene": "ptr-blocks-gamepad-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Input":        "ptr-blocks-input",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Piece":        "ptr-blocks-piece",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*SceneManager": "ptr-blocks-scene-manager",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*TitleScene":   "ptr-blocks-title-scene",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.*Field":                 "ptr-textinput-field",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.*State":                 "ptr-textinput-state",
	"github.com/hajimehoshi/ebiten/v2/text.*Glyph":                          "ptr-ebiten-text-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*DrawOptions":                 "ptr-text-draw-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Glyph":                       "ptr-text-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*GoTextFace":                  "ptr-text-go-text-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LayoutOptions":               "ptr-text-layout-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LimitedFace":                 "ptr-text-limited-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metadata":                    "ptr-text-metadata",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metrics":                     "ptr-text-metrics",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*MultiFace":                   "ptr-text-multi-face",
	"github.com/hajimehoshi/ebiten/v2/vector.*Path":                         "ptr-vector-path",
	"github.com/hajimehoshi/ebiten/v2/vector.*StrokeOptions":                "ptr-vector-stroke-options",
	"image.*Alpha":         "ptr-image-alpha",
	"image.*Alpha16":       "ptr-image-alpha-16",
	"image.*CMYK":          "ptr-image-cmyk",
	"image.*Config":        "ptr-image-config",
	"image.*Gray":          "ptr-image-gray",
	"image.*Gray16":        "ptr-image-gray-16",
	"image.*NRGBA":         "ptr-image-nrgba",
	"image.*NRGBA64":       "ptr-image-nrgba-64",
	"image.*NYCbCrA":       "ptr-image-ny-cb-cr-a",
	"image.*Paletted":      "ptr-image-paletted",
	"image.*Point":         "ptr-image-point",
	"image.*RGBA":          "ptr-image-rgba",
	"image.*RGBA64":        "ptr-image-rgba-64",
	"image.*Rectangle":     "ptr-image-rectangle",
	"image.*Uniform":       "ptr-image-uniform",
	"image.*YCbCr":         "ptr-image-y-cb-cr",
	"image/color.*Alpha":   "ptr-color-alpha",
	"image/color.*Alpha16": "ptr-color-alpha-16",
	"image/color.*CMYK":    "ptr-color-cmyk",
	"image/color.*Gray":    "ptr-color-gray",
	"image/color.*Gray16":  "ptr-color-gray-16",
	"image/color.*NRGBA":   "ptr-color-nrgba",
	"image/color.*NRGBA64": "ptr-color-nrgba-64",
	"image/color.*NYCbCrA": "ptr-color-ny-cb-cr-a",
	"image/color.*RGBA":    "ptr-color-rgba",
	"image/color.*RGBA64":  "ptr-color-rgba-64",
	"image/color.*YCbCr":   "ptr-color-y-cb-cr",
	"image/gif.*GIF":       "ptr-gif-gif",
	"image/gif.*Options":   "ptr-gif-options",
	"image/jpeg.*Options":  "ptr-jpeg-options",
	"image/png.*Encoder":   "ptr-png-encoder",
	"io.*LimitedReader":    "ptr-io-limited-reader",
	"io.*PipeReader":       "ptr-io-pipe-reader",
	"io.*PipeWriter":       "ptr-io-pipe-writer",
	"io.*SectionReader":    "ptr-io-section-reader",
	"io/fs.*PathError":     "ptr-fs-path-error",
}

type iface_blocks_Scene struct {
	self      env.RyeCtx
	fn_Update func(self env.RyeCtx, arg0 *blocks.GameState) error
	fn_Draw   func(self env.RyeCtx, arg0 *ebiten.Image)
}

func (self *iface_blocks_Scene) Update(arg0 *blocks.GameState) error {
	return self.fn_Update(self.self, arg0)
}
func (self *iface_blocks_Scene) Draw(arg0 *ebiten.Image) {
	self.fn_Draw(self.self, arg0)
}

func ctxTo_blocks_Scene(ps *env.ProgramState, v env.RyeCtx) (blocks.Scene, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_blocks_Scene{
		self: v,
	}
	ctxObj0, ok := wordToObj["update"]
	if !ok {
		return nil, errors.New("context to blocks.Scene: expected context to have function update")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to blocks.Scene: context fn update: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Update = func(ctx env.RyeCtx, arg0 *blocks.GameState) error {
			var arg0Val env.Object
			arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-blocks-game-state")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to blocks.Scene: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to blocks.Scene: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to blocks.Scene: context fn update: expected function")
	}
	ctxObj1, ok := wordToObj["draw"]
	if !ok {
		return nil, errors.New("context to blocks.Scene: expected context to have function draw")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to blocks.Scene: context fn draw: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
			var arg0Val env.Object
			arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
		}
	default:
		return nil, errors.New("context to blocks.Scene: context fn draw: expected function")
	}
	return impl, nil
}

type iface_color_Color struct {
	self    env.RyeCtx
	fn_RGBA func(self env.RyeCtx) (uint32, uint32, uint32, uint32)
}

func (self *iface_color_Color) RGBA() (uint32, uint32, uint32, uint32) {
	return self.fn_RGBA(self.self)
}

func ctxTo_color_Color(ps *env.ProgramState, v env.RyeCtx) (color.Color, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_color_Color{
		self: v,
	}
	ctxObj0, ok := wordToObj["rgba"]
	if !ok {
		return nil, errors.New("context to color.Color: expected context to have function rgba")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to color.Color: context fn rgba: function has invalid number of arguments (expected 0)")
		}
		impl.fn_RGBA = func(ctx env.RyeCtx) (uint32, uint32, uint32, uint32) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res0 uint32
			var res1 uint32
			var res2 uint32
			var res3 uint32
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if len(res.Series.S) != 4 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: expected block with 4 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = uint32(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if v, ok := res.Series.S[1].(env.Integer); ok {
				res1 = uint32(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if v, ok := res.Series.S[2].(env.Integer); ok {
				res2 = uint32(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			if v, ok := res.Series.S[3].(env.Integer); ok {
				res3 = uint32(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Color: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1, res2, res3
			}
			return res0, res1, res2, res3
		}
	default:
		return nil, errors.New("context to color.Color: context fn rgba: expected function")
	}
	return impl, nil
}

type iface_color_Model struct {
	self       env.RyeCtx
	fn_Convert func(self env.RyeCtx, arg0 color.Color) color.Color
}

func (self *iface_color_Model) Convert(arg0 color.Color) color.Color {
	return self.fn_Convert(self.self, arg0)
}

func ctxTo_color_Model(ps *env.ProgramState, v env.RyeCtx) (color.Model, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_color_Model{
		self: v,
	}
	ctxObj0, ok := wordToObj["convert"]
	if !ok {
		return nil, errors.New("context to color.Model: expected context to have function convert")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to color.Model: context fn convert: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Convert = func(ctx env.RyeCtx, arg0 color.Color) color.Color {
			var arg0Val env.Object
			{
				typ := reflect.TypeOf(arg0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
				} else {
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
				}
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to color.Model: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Color)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to color.Model: arg 0: callback result: expected native of type color.Color",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to color.Model: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to color.Model: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to color.Model: context fn convert: expected function")
	}
	return impl, nil
}

type iface_draw_Drawer struct {
	self    env.RyeCtx
	fn_Draw func(self env.RyeCtx, arg0 draw.Image, arg1 image.Rectangle, arg2 image.Image, arg3 image.Point)
}

func (self *iface_draw_Drawer) Draw(arg0 draw.Image, arg1 image.Rectangle, arg2 image.Image, arg3 image.Point) {
	self.fn_Draw(self.self, arg0, arg1, arg2, arg3)
}

func ctxTo_draw_Drawer(ps *env.ProgramState, v env.RyeCtx) (draw.Drawer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_Drawer{
		self: v,
	}
	ctxObj0, ok := wordToObj["draw"]
	if !ok {
		return nil, errors.New("context to draw.Drawer: expected context to have function draw")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 4 {
			return nil, errors.New("context to draw.Drawer: context fn draw: function has invalid number of arguments (expected 4)")
		}
		impl.fn_Draw = func(ctx env.RyeCtx, arg0 draw.Image, arg1 image.Rectangle, arg2 image.Image, arg3 image.Point) {
			var arg0Val, arg1Val, arg2Val, arg3Val env.Object
			{
				typ := reflect.TypeOf(arg0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
				} else {
					arg0Val = *env.NewNative(ps.Idx, arg0, "draw-image")
				}
			}
			arg1Val = *env.NewNative(ps.Idx, arg1, "image-rectangle")
			{
				typ := reflect.TypeOf(arg2)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg2Val = *env.NewNative(ps.Idx, arg2, typRyeName)
				} else {
					arg2Val = *env.NewNative(ps.Idx, arg2, "image-image")
				}
			}
			arg3Val = *env.NewNative(ps.Idx, arg3, "image-point")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val, arg2Val, arg3Val)
		}
	default:
		return nil, errors.New("context to draw.Drawer: context fn draw: expected function")
	}
	return impl, nil
}

type iface_draw_Image struct {
	self          env.RyeCtx
	fn_Set        func(self env.RyeCtx, arg0 int, arg1 int, arg2 color.Color)
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_draw_Image) Set(arg0 int, arg1 int, arg2 color.Color) {
	self.fn_Set(self.self, arg0, arg1, arg2)
}
func (self *iface_draw_Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_draw_Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_draw_Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_draw_Image(ps *env.ProgramState, v env.RyeCtx) (draw.Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["set"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function set")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to draw.Image: context fn set: function has invalid number of arguments (expected 3)")
		}
		impl.fn_Set = func(ctx env.RyeCtx, arg0 int, arg1 int, arg2 color.Color) {
			var arg0Val, arg1Val, arg2Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			{
				typ := reflect.TypeOf(arg2)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg2Val = *env.NewNative(ps.Idx, arg2, typRyeName)
				} else {
					arg2Val = *env.NewNative(ps.Idx, arg2, "color-color")
				}
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val, arg2Val)
		}
	default:
		return nil, errors.New("context to draw.Image: context fn set: expected function")
	}
	ctxObj1, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function color-model")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.Image: context fn color-model: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Model)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: expected native of type color.Model",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Image: context fn color-model: expected function")
	}
	ctxObj2, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function bounds")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.Image: context fn bounds: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(image.Rectangle)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: expected native of type image.Rectangle",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Image: context fn bounds: expected function")
	}
	ctxObj3, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to draw.Image: expected context to have function at")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.Image: context fn at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.Color {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Color)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: expected native of type color.Color",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Image: context fn at: expected function")
	}
	return impl, nil
}

type iface_draw_Quantizer struct {
	self        env.RyeCtx
	fn_Quantize func(self env.RyeCtx, arg0 color.Palette, arg1 image.Image) color.Palette
}

func (self *iface_draw_Quantizer) Quantize(arg0 color.Palette, arg1 image.Image) color.Palette {
	return self.fn_Quantize(self.self, arg0, arg1)
}

func ctxTo_draw_Quantizer(ps *env.ProgramState, v env.RyeCtx) (draw.Quantizer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_Quantizer{
		self: v,
	}
	ctxObj0, ok := wordToObj["quantize"]
	if !ok {
		return nil, errors.New("context to draw.Quantizer: expected context to have function quantize")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.Quantizer: context fn quantize: function has invalid number of arguments (expected 2)")
		}
		impl.fn_Quantize = func(ctx env.RyeCtx, arg0 color.Palette, arg1 image.Image) color.Palette {
			var arg0Val, arg1Val env.Object
			{
				items := make([]env.Object, len([]color.Color(arg0)))
				for i, it := range []color.Color(arg0) {
					{
						typ := reflect.TypeOf(it)
						var typRyeName string
						var ok bool
						if typ != nil {
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						}
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "color-color")
						}
					}
				}
				arg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			{
				typ := reflect.TypeOf(arg1)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
				} else {
					arg1Val = *env.NewNative(ps.Idx, arg1, "image-image")
				}
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.Palette
			{
				nat, natOk := ps.Res.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					res = natVal
				} else {
					var u []color.Color
					switch v := ps.Res.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"context to draw.Quantizer: arg 0: callback result: block item: "+err.Error()+"",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							case env.Native:
								var ok bool
								u[i], ok = v.Value.(color.Color)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"context to draw.Quantizer: arg 0: callback result: block item: expected native of type color.Color",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							case env.Integer:
								if v.Value != 0 {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"context to draw.Quantizer: arg 0: callback result: block item: expected integer to be 0 or nil",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
								u[i] = nil
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"context to draw.Quantizer: arg 0: callback result: block item: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
						}
					case env.Native:
						var ok bool
						u, ok = v.Value.([]color.Color)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"context to draw.Quantizer: arg 0: callback result: expected native of type []color.Color",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					case env.Integer:
						if v.Value != 0 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"context to draw.Quantizer: arg 0: callback result: expected integer to be 0 or nil",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
						u = nil
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"context to draw.Quantizer: arg 0: callback result: expected block, native or nil",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					res = color.Palette(u)
				}
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.Quantizer: context fn quantize: expected function")
	}
	return impl, nil
}

type iface_draw_RGBA64Image struct {
	self          env.RyeCtx
	fn_Set        func(self env.RyeCtx, arg0 int, arg1 int, arg2 color.Color)
	fn_SetRGBA64  func(self env.RyeCtx, arg0 int, arg1 int, arg2 color.RGBA64)
	fn_RGBA64At   func(self env.RyeCtx, arg0 int, arg1 int) color.RGBA64
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_draw_RGBA64Image) Set(arg0 int, arg1 int, arg2 color.Color) {
	self.fn_Set(self.self, arg0, arg1, arg2)
}
func (self *iface_draw_RGBA64Image) SetRGBA64(arg0 int, arg1 int, arg2 color.RGBA64) {
	self.fn_SetRGBA64(self.self, arg0, arg1, arg2)
}
func (self *iface_draw_RGBA64Image) RGBA64At(arg0 int, arg1 int) color.RGBA64 {
	return self.fn_RGBA64At(self.self, arg0, arg1)
}
func (self *iface_draw_RGBA64Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_draw_RGBA64Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_draw_RGBA64Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_draw_RGBA64Image(ps *env.ProgramState, v env.RyeCtx) (draw.RGBA64Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_draw_RGBA64Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["set"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function set")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to draw.RGBA64Image: context fn set: function has invalid number of arguments (expected 3)")
		}
		impl.fn_Set = func(ctx env.RyeCtx, arg0 int, arg1 int, arg2 color.Color) {
			var arg0Val, arg1Val, arg2Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			{
				typ := reflect.TypeOf(arg2)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg2Val = *env.NewNative(ps.Idx, arg2, typRyeName)
				} else {
					arg2Val = *env.NewNative(ps.Idx, arg2, "color-color")
				}
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val, arg2Val)
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn set: expected function")
	}
	ctxObj1, ok := wordToObj["set-rgba-64"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function set-rgba-64")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to draw.RGBA64Image: context fn set-rgba-64: function has invalid number of arguments (expected 3)")
		}
		impl.fn_SetRGBA64 = func(ctx env.RyeCtx, arg0 int, arg1 int, arg2 color.RGBA64) {
			var arg0Val, arg1Val, arg2Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			arg2Val = *env.NewNative(ps.Idx, arg2, "color-rgba-64")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val, arg2Val)
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn set-rgba-64: expected function")
	}
	ctxObj2, ok := wordToObj["rgba-64-at"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function rgba-64-at")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.RGBA64Image: context fn rgba-64-at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_RGBA64At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.RGBA64 {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.RGBA64
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.RGBA64)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: expected native of type color.RGBA64",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn rgba-64-at: expected function")
	}
	ctxObj3, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function color-model")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.RGBA64Image: context fn color-model: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Model)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: expected native of type color.Model",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn color-model: expected function")
	}
	ctxObj4, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function bounds")
	}
	switch fn := ctxObj4.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to draw.RGBA64Image: context fn bounds: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(image.Rectangle)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: expected native of type image.Rectangle",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn bounds: expected function")
	}
	ctxObj5, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to draw.RGBA64Image: expected context to have function at")
	}
	switch fn := ctxObj5.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to draw.RGBA64Image: context fn at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.Color {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Color)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: expected native of type color.Color",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to draw.RGBA64Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to draw.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to draw.RGBA64Image: context fn at: expected function")
	}
	return impl, nil
}

type iface_ebiten_FinalScreenDrawer struct {
	self               env.RyeCtx
	fn_DrawFinalScreen func(self env.RyeCtx, arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM)
}

func (self *iface_ebiten_FinalScreenDrawer) DrawFinalScreen(arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM) {
	self.fn_DrawFinalScreen(self.self, arg0, arg1, arg2)
}

func ctxTo_ebiten_FinalScreenDrawer(ps *env.ProgramState, v env.RyeCtx) (ebiten.FinalScreenDrawer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebiten_FinalScreenDrawer{
		self: v,
	}
	ctxObj0, ok := wordToObj["draw-final-screen"]
	if !ok {
		return nil, errors.New("context to ebiten.FinalScreenDrawer: expected context to have function draw-final-screen")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to ebiten.FinalScreenDrawer: context fn draw-final-screen: function has invalid number of arguments (expected 3)")
		}
		impl.fn_DrawFinalScreen = func(ctx env.RyeCtx, arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM) {
			var arg0Val, arg1Val, arg2Val env.Object
			{
				typ := reflect.TypeOf(arg0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
				} else {
					arg0Val = *env.NewNative(ps.Idx, arg0, "ebiten-final-screen")
				}
			}
			arg1Val = *env.NewNative(ps.Idx, arg1, "ptr-ebiten-image")
			arg2Val = *env.NewNative(ps.Idx, arg2, "ebiten-geo-m")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val, arg2Val)
		}
	default:
		return nil, errors.New("context to ebiten.FinalScreenDrawer: context fn draw-final-screen: expected function")
	}
	return impl, nil
}

type iface_ebiten_Game struct {
	self      env.RyeCtx
	fn_Update func(self env.RyeCtx) error
	fn_Draw   func(self env.RyeCtx, arg0 *ebiten.Image)
	fn_Layout func(self env.RyeCtx, arg0 int, arg1 int) (int, int)
}

func (self *iface_ebiten_Game) Update() error {
	return self.fn_Update(self.self)
}
func (self *iface_ebiten_Game) Draw(arg0 *ebiten.Image) {
	self.fn_Draw(self.self, arg0)
}
func (self *iface_ebiten_Game) Layout(arg0 int, arg1 int) (int, int) {
	return self.fn_Layout(self.self, arg0, arg1)
}

func ctxTo_ebiten_Game(ps *env.ProgramState, v env.RyeCtx) (ebiten.Game, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebiten_Game{
		self: v,
	}
	ctxObj0, ok := wordToObj["update"]
	if !ok {
		return nil, errors.New("context to ebiten.Game: expected context to have function update")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Update = func(ctx env.RyeCtx) error {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to ebiten.Game: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to ebiten.Game: context fn update: expected function")
	}
	ctxObj1, ok := wordToObj["draw"]
	if !ok {
		return nil, errors.New("context to ebiten.Game: expected context to have function draw")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
			var arg0Val env.Object
			arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
		}
	default:
		return nil, errors.New("context to ebiten.Game: context fn draw: expected function")
	}
	ctxObj2, ok := wordToObj["layout"]
	if !ok {
		return nil, errors.New("context to ebiten.Game: expected context to have function layout")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
		}
		impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res0 int
			var res1 int
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[1].(env.Integer); ok {
				res1 = int(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.Game: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to ebiten.Game: context fn layout: expected function")
	}
	return impl, nil
}

type iface_ebiten_LayoutFer struct {
	self       env.RyeCtx
	fn_LayoutF func(self env.RyeCtx, arg0 float64, arg1 float64) (float64, float64)
}

func (self *iface_ebiten_LayoutFer) LayoutF(arg0 float64, arg1 float64) (float64, float64) {
	return self.fn_LayoutF(self.self, arg0, arg1)
}

func ctxTo_ebiten_LayoutFer(ps *env.ProgramState, v env.RyeCtx) (ebiten.LayoutFer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_ebiten_LayoutFer{
		self: v,
	}
	ctxObj0, ok := wordToObj["layout-f"]
	if !ok {
		return nil, errors.New("context to ebiten.LayoutFer: expected context to have function layout-f")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to ebiten.LayoutFer: context fn layout-f: function has invalid number of arguments (expected 2)")
		}
		impl.fn_LayoutF = func(ctx env.RyeCtx, arg0 float64, arg1 float64) (float64, float64) {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewDecimal(float64(arg0))
			arg1Val = *env.NewDecimal(float64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res0 float64
			var res1 float64
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Decimal); ok {
				res0 = float64(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: expected decimal",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[1].(env.Decimal); ok {
				res1 = float64(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to ebiten.LayoutFer: arg 0: callback result: expected decimal",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to ebiten.LayoutFer: context fn layout-f: expected function")
	}
	return impl, nil
}

type iface_fs_FS struct {
	self    env.RyeCtx
	fn_Open func(self env.RyeCtx, arg0 string) (fs.File, error)
}

func (self *iface_fs_FS) Open(arg0 string) (fs.File, error) {
	return self.fn_Open(self.self, arg0)
}

func ctxTo_fs_FS(ps *env.ProgramState, v env.RyeCtx) (fs.FS, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_fs_FS{
		self: v,
	}
	ctxObj0, ok := wordToObj["open"]
	if !ok {
		return nil, errors.New("context to fs.FS: expected context to have function open")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to fs.FS: context fn open: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Open = func(ctx env.RyeCtx, arg0 string) (fs.File, error) {
			var arg0Val env.Object
			arg0Val = *env.NewString(arg0)
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res0 fs.File
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[0].(type) {
			case env.RyeCtx:
				var err error
				res0, err = ctxTo_fs_File(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Native:
				var ok bool
				res0, ok = v.Value.(fs.File)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: expected native of type fs.File",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res0 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FS: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FS: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to fs.FS: context fn open: expected function")
	}
	return impl, nil
}

type iface_fs_File struct {
	self     env.RyeCtx
	fn_Stat  func(self env.RyeCtx) (fs.FileInfo, error)
	fn_Read  func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Close func(self env.RyeCtx) error
}

func (self *iface_fs_File) Stat() (fs.FileInfo, error) {
	return self.fn_Stat(self.self)
}
func (self *iface_fs_File) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *iface_fs_File) Close() error {
	return self.fn_Close(self.self)
}

func ctxTo_fs_File(ps *env.ProgramState, v env.RyeCtx) (fs.File, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_fs_File{
		self: v,
	}
	ctxObj0, ok := wordToObj["stat"]
	if !ok {
		return nil, errors.New("context to fs.File: expected context to have function stat")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.File: context fn stat: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Stat = func(ctx env.RyeCtx) (fs.FileInfo, error) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res0 fs.FileInfo
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[0].(type) {
			case env.RyeCtx:
				var err error
				res0, err = ctxTo_fs_FileInfo(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Native:
				var ok bool
				res0, ok = v.Value.(fs.FileInfo)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: expected native of type fs.FileInfo",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res0 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to fs.File: context fn stat: expected function")
	}
	ctxObj1, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to fs.File: expected context to have function read")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to fs.File: context fn read: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
			var arg0Val env.Object
			{
				items := make([]env.Object, len(arg0))
				for i, it := range arg0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				arg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to fs.File: context fn read: expected function")
	}
	ctxObj2, ok := wordToObj["close"]
	if !ok {
		return nil, errors.New("context to fs.File: expected context to have function close")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.File: context fn close: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Close = func(ctx env.RyeCtx) error {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.File: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.File: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.File: context fn close: expected function")
	}
	return impl, nil
}

type iface_fs_FileInfo struct {
	self       env.RyeCtx
	fn_Name    func(self env.RyeCtx) string
	fn_Size    func(self env.RyeCtx) int64
	fn_Mode    func(self env.RyeCtx) fs.FileMode
	fn_ModTime func(self env.RyeCtx) time.Time
	fn_IsDir   func(self env.RyeCtx) bool
	fn_Sys     func(self env.RyeCtx) any
}

func (self *iface_fs_FileInfo) Name() string {
	return self.fn_Name(self.self)
}
func (self *iface_fs_FileInfo) Size() int64 {
	return self.fn_Size(self.self)
}
func (self *iface_fs_FileInfo) Mode() fs.FileMode {
	return self.fn_Mode(self.self)
}
func (self *iface_fs_FileInfo) ModTime() time.Time {
	return self.fn_ModTime(self.self)
}
func (self *iface_fs_FileInfo) IsDir() bool {
	return self.fn_IsDir(self.self)
}
func (self *iface_fs_FileInfo) Sys() any {
	return self.fn_Sys(self.self)
}

func ctxTo_fs_FileInfo(ps *env.ProgramState, v env.RyeCtx) (fs.FileInfo, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_fs_FileInfo{
		self: v,
	}
	ctxObj0, ok := wordToObj["name"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function name")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn name: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Name = func(ctx env.RyeCtx) string {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res string
			if v, ok := ps.Res.(env.String); ok {
				res = string(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: expected string",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn name: expected function")
	}
	ctxObj1, ok := wordToObj["size"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function size")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn size: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Size = func(ctx env.RyeCtx) int64 {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res int64
			if v, ok := ps.Res.(env.Integer); ok {
				res = int64(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn size: expected function")
	}
	ctxObj2, ok := wordToObj["mode"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function mode")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn mode: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Mode = func(ctx env.RyeCtx) fs.FileMode {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res fs.FileMode
			{
				nat, natOk := ps.Res.(env.Native)
				var natValOk bool
				var natVal fs.FileMode
				if natOk {
					natVal, natValOk = nat.Value.(fs.FileMode)
				}
				if natValOk {
					res = natVal
				} else {
					var u uint32
					if v, ok := ps.Res.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"context to fs.FileInfo: arg 0: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					res = fs.FileMode(u)
				}
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn mode: expected function")
	}
	ctxObj3, ok := wordToObj["mod-time"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function mod-time")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn mod-time: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ModTime = func(ctx env.RyeCtx) time.Time {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res time.Time
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(time.Time)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FileInfo: arg 0: callback result: expected native of type time.Time",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn mod-time: expected function")
	}
	ctxObj4, ok := wordToObj["is-dir"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function is-dir")
	}
	switch fn := ctxObj4.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn is-dir: function has invalid number of arguments (expected 0)")
		}
		impl.fn_IsDir = func(ctx env.RyeCtx) bool {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res bool
			if v, ok := ps.Res.(env.Integer); ok {
				res = v.Value != 0
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn is-dir: expected function")
	}
	ctxObj5, ok := wordToObj["sys"]
	if !ok {
		return nil, errors.New("context to fs.FileInfo: expected context to have function sys")
	}
	switch fn := ctxObj5.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to fs.FileInfo: context fn sys: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Sys = func(ctx env.RyeCtx) any {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res any
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(any)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to fs.FileInfo: arg 0: callback result: expected native of type any",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to fs.FileInfo: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to fs.FileInfo: context fn sys: expected function")
	}
	return impl, nil
}

type iface_image_Image struct {
	self          env.RyeCtx
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_image_Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_image_Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_image_Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_image_Image(ps *env.ProgramState, v env.RyeCtx) (image.Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_image_Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to image.Image: expected context to have function color-model")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.Image: context fn color-model: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Model)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: expected native of type color.Model",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.Image: context fn color-model: expected function")
	}
	ctxObj1, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to image.Image: expected context to have function bounds")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.Image: context fn bounds: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(image.Rectangle)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: expected native of type image.Rectangle",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.Image: context fn bounds: expected function")
	}
	ctxObj2, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to image.Image: expected context to have function at")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.Image: context fn at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.Color {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Color)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: expected native of type color.Color",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.Image: context fn at: expected function")
	}
	return impl, nil
}

type iface_image_PalettedImage struct {
	self            env.RyeCtx
	fn_ColorIndexAt func(self env.RyeCtx, arg0 int, arg1 int) uint8
	fn_ColorModel   func(self env.RyeCtx) color.Model
	fn_Bounds       func(self env.RyeCtx) image.Rectangle
	fn_At           func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_image_PalettedImage) ColorIndexAt(arg0 int, arg1 int) uint8 {
	return self.fn_ColorIndexAt(self.self, arg0, arg1)
}
func (self *iface_image_PalettedImage) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_image_PalettedImage) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_image_PalettedImage) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_image_PalettedImage(ps *env.ProgramState, v env.RyeCtx) (image.PalettedImage, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_image_PalettedImage{
		self: v,
	}
	ctxObj0, ok := wordToObj["color-index-at"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function color-index-at")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.PalettedImage: context fn color-index-at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_ColorIndexAt = func(ctx env.RyeCtx, arg0 int, arg1 int) uint8 {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res uint8
			if v, ok := ps.Res.(env.Integer); ok {
				res = uint8(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn color-index-at: expected function")
	}
	ctxObj1, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function color-model")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.PalettedImage: context fn color-model: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Model)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: expected native of type color.Model",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn color-model: expected function")
	}
	ctxObj2, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function bounds")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.PalettedImage: context fn bounds: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(image.Rectangle)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: expected native of type image.Rectangle",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn bounds: expected function")
	}
	ctxObj3, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to image.PalettedImage: expected context to have function at")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.PalettedImage: context fn at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.Color {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Color)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: expected native of type color.Color",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.PalettedImage: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.PalettedImage: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.PalettedImage: context fn at: expected function")
	}
	return impl, nil
}

type iface_image_RGBA64Image struct {
	self          env.RyeCtx
	fn_RGBA64At   func(self env.RyeCtx, arg0 int, arg1 int) color.RGBA64
	fn_ColorModel func(self env.RyeCtx) color.Model
	fn_Bounds     func(self env.RyeCtx) image.Rectangle
	fn_At         func(self env.RyeCtx, arg0 int, arg1 int) color.Color
}

func (self *iface_image_RGBA64Image) RGBA64At(arg0 int, arg1 int) color.RGBA64 {
	return self.fn_RGBA64At(self.self, arg0, arg1)
}
func (self *iface_image_RGBA64Image) ColorModel() color.Model {
	return self.fn_ColorModel(self.self)
}
func (self *iface_image_RGBA64Image) Bounds() image.Rectangle {
	return self.fn_Bounds(self.self)
}
func (self *iface_image_RGBA64Image) At(arg0 int, arg1 int) color.Color {
	return self.fn_At(self.self, arg0, arg1)
}

func ctxTo_image_RGBA64Image(ps *env.ProgramState, v env.RyeCtx) (image.RGBA64Image, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_image_RGBA64Image{
		self: v,
	}
	ctxObj0, ok := wordToObj["rgba-64-at"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function rgba-64-at")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.RGBA64Image: context fn rgba-64-at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_RGBA64At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.RGBA64 {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.RGBA64
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.RGBA64)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: expected native of type color.RGBA64",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn rgba-64-at: expected function")
	}
	ctxObj1, ok := wordToObj["color-model"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function color-model")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.RGBA64Image: context fn color-model: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ColorModel = func(ctx env.RyeCtx) color.Model {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res color.Model
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Model(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Model)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: expected native of type color.Model",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn color-model: expected function")
	}
	ctxObj2, ok := wordToObj["bounds"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function bounds")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to image.RGBA64Image: context fn bounds: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Bounds = func(ctx env.RyeCtx) image.Rectangle {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res image.Rectangle
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(image.Rectangle)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: expected native of type image.Rectangle",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn bounds: expected function")
	}
	ctxObj3, ok := wordToObj["at"]
	if !ok {
		return nil, errors.New("context to image.RGBA64Image: expected context to have function at")
	}
	switch fn := ctxObj3.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to image.RGBA64Image: context fn at: function has invalid number of arguments (expected 2)")
		}
		impl.fn_At = func(ctx env.RyeCtx, arg0 int, arg1 int) color.Color {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res color.Color
			switch v := ps.Res.(type) {
			case env.RyeCtx:
				var err error
				res, err = ctxTo_color_Color(ps, v)
				if err != nil {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: "+err.Error()+"",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Native:
				var ok bool
				res, ok = v.Value.(color.Color)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: expected native of type color.Color",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to image.RGBA64Image: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to image.RGBA64Image: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to image.RGBA64Image: context fn at: expected function")
	}
	return impl, nil
}

type iface_io_ByteReader struct {
	self        env.RyeCtx
	fn_ReadByte func(self env.RyeCtx) (byte, error)
}

func (self *iface_io_ByteReader) ReadByte() (byte, error) {
	return self.fn_ReadByte(self.self)
}

func ctxTo_io_ByteReader(ps *env.ProgramState, v env.RyeCtx) (io.ByteReader, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_ByteReader{
		self: v,
	}
	ctxObj0, ok := wordToObj["read-byte"]
	if !ok {
		return nil, errors.New("context to io.ByteReader: expected context to have function read-byte")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to io.ByteReader: context fn read-byte: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ReadByte = func(ctx env.RyeCtx) (byte, error) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res0 byte
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ByteReader: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ByteReader: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[0].(type) {
			case env.Native:
				var ok bool
				res0, ok = v.Value.(byte)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.ByteReader: arg 0: callback result: expected native of type byte",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ByteReader: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.ByteReader: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ByteReader: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.ByteReader: context fn read-byte: expected function")
	}
	return impl, nil
}

type iface_io_Closer struct {
	self     env.RyeCtx
	fn_Close func(self env.RyeCtx) error
}

func (self *iface_io_Closer) Close() error {
	return self.fn_Close(self.self)
}

func ctxTo_io_Closer(ps *env.ProgramState, v env.RyeCtx) (io.Closer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_Closer{
		self: v,
	}
	ctxObj0, ok := wordToObj["close"]
	if !ok {
		return nil, errors.New("context to io.Closer: expected context to have function close")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to io.Closer: context fn close: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Close = func(ctx env.RyeCtx) error {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.Closer: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Closer: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to io.Closer: context fn close: expected function")
	}
	return impl, nil
}

type iface_io_ReadSeeker struct {
	self    env.RyeCtx
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Seek func(self env.RyeCtx, arg0 int64, arg1 int) (int64, error)
}

func (self *iface_io_ReadSeeker) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *iface_io_ReadSeeker) Seek(arg0 int64, arg1 int) (int64, error) {
	return self.fn_Seek(self.self, arg0, arg1)
}

func ctxTo_io_ReadSeeker(ps *env.ProgramState, v env.RyeCtx) (io.ReadSeeker, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_ReadSeeker{
		self: v,
	}
	ctxObj0, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to io.ReadSeeker: expected context to have function read")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to io.ReadSeeker: context fn read: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
			var arg0Val env.Object
			{
				items := make([]env.Object, len(arg0))
				for i, it := range arg0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				arg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.ReadSeeker: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.ReadSeeker: context fn read: expected function")
	}
	ctxObj1, ok := wordToObj["seek"]
	if !ok {
		return nil, errors.New("context to io.ReadSeeker: expected context to have function seek")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to io.ReadSeeker: context fn seek: function has invalid number of arguments (expected 2)")
		}
		impl.fn_Seek = func(ctx env.RyeCtx, arg0 int64, arg1 int) (int64, error) {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res0 int64
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int64(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.ReadSeeker: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.ReadSeeker: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.ReadSeeker: context fn seek: expected function")
	}
	return impl, nil
}

type iface_io_Reader struct {
	self    env.RyeCtx
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
}

func (self *iface_io_Reader) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}

func ctxTo_io_Reader(ps *env.ProgramState, v env.RyeCtx) (io.Reader, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_Reader{
		self: v,
	}
	ctxObj0, ok := wordToObj["read"]
	if !ok {
		return nil, errors.New("context to io.Reader: expected context to have function read")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
			var arg0Val env.Object
			{
				items := make([]env.Object, len(arg0))
				for i, it := range arg0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				arg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.Reader: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Reader: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.Reader: context fn read: expected function")
	}
	return impl, nil
}

type iface_io_Seeker struct {
	self    env.RyeCtx
	fn_Seek func(self env.RyeCtx, arg0 int64, arg1 int) (int64, error)
}

func (self *iface_io_Seeker) Seek(arg0 int64, arg1 int) (int64, error) {
	return self.fn_Seek(self.self, arg0, arg1)
}

func ctxTo_io_Seeker(ps *env.ProgramState, v env.RyeCtx) (io.Seeker, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_Seeker{
		self: v,
	}
	ctxObj0, ok := wordToObj["seek"]
	if !ok {
		return nil, errors.New("context to io.Seeker: expected context to have function seek")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 2 {
			return nil, errors.New("context to io.Seeker: context fn seek: function has invalid number of arguments (expected 2)")
		}
		impl.fn_Seek = func(ctx env.RyeCtx, arg0 int64, arg1 int) (int64, error) {
			var arg0Val, arg1Val env.Object
			arg0Val = *env.NewInteger(int64(arg0))
			arg1Val = *env.NewInteger(int64(arg1))
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
			var res0 int64
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Seeker: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Seeker: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int64(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Seeker: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.Seeker: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Seeker: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.Seeker: context fn seek: expected function")
	}
	return impl, nil
}

type iface_io_Writer struct {
	self     env.RyeCtx
	fn_Write func(self env.RyeCtx, arg0 []byte) (int, error)
}

func (self *iface_io_Writer) Write(arg0 []byte) (int, error) {
	return self.fn_Write(self.self, arg0)
}

func ctxTo_io_Writer(ps *env.ProgramState, v env.RyeCtx) (io.Writer, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_io_Writer{
		self: v,
	}
	ctxObj0, ok := wordToObj["write"]
	if !ok {
		return nil, errors.New("context to io.Writer: expected context to have function write")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to io.Writer: context fn write: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Write = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
			var arg0Val env.Object
			{
				items := make([]env.Object, len(arg0))
				for i, it := range arg0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				arg0Val = *env.NewBlock(*env.NewTSeries(items))
			}
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
			var res0 int
			var res1 error
			res, ok := ps.Res.(env.Block)
			if !ok {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: expected block for multiple return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if len(res.Series.S) != 2 {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: expected block with 2 return values",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			if v, ok := res.Series.S[0].(env.Integer); ok {
				res0 = int(v.Value)
			} else {
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: expected integer",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			switch v := res.Series.S[1].(type) {
			case env.String:
				res1 = errors.New(v.Value)
			case env.Error:
				res1 = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to io.Writer: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res0, res1
				}
				res1 = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to io.Writer: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res0, res1
			}
			return res0, res1
		}
	default:
		return nil, errors.New("context to io.Writer: context fn write: expected function")
	}
	return impl, nil
}

type iface_png_EncoderBufferPool struct {
	self   env.RyeCtx
	fn_Get func(self env.RyeCtx) *png.EncoderBuffer
	fn_Put func(self env.RyeCtx, arg0 *png.EncoderBuffer)
}

func (self *iface_png_EncoderBufferPool) Get() *png.EncoderBuffer {
	return self.fn_Get(self.self)
}
func (self *iface_png_EncoderBufferPool) Put(arg0 *png.EncoderBuffer) {
	self.fn_Put(self.self, arg0)
}

func ctxTo_png_EncoderBufferPool(ps *env.ProgramState, v env.RyeCtx) (png.EncoderBufferPool, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_png_EncoderBufferPool{
		self: v,
	}
	ctxObj0, ok := wordToObj["get"]
	if !ok {
		return nil, errors.New("context to png.EncoderBufferPool: expected context to have function get")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to png.EncoderBufferPool: context fn get: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Get = func(ctx env.RyeCtx) *png.EncoderBuffer {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res *png.EncoderBuffer
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(*png.EncoderBuffer)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to png.EncoderBufferPool: arg 0: callback result: expected native of type *png.EncoderBuffer",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to png.EncoderBufferPool: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to png.EncoderBufferPool: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to png.EncoderBufferPool: context fn get: expected function")
	}
	ctxObj1, ok := wordToObj["put"]
	if !ok {
		return nil, errors.New("context to png.EncoderBufferPool: expected context to have function put")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to png.EncoderBufferPool: context fn put: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Put = func(ctx env.RyeCtx, arg0 *png.EncoderBuffer) {
			var arg0Val env.Object
			arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-png-encoder-buffer")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
		}
	default:
		return nil, errors.New("context to png.EncoderBufferPool: context fn put: expected function")
	}
	return impl, nil
}

var Builtins = map[string]*env.Builtin{
	"nil": {
		Doc: "nil value for go types",
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			return *env.NewInteger(0)
		},
	},
	"audio-current-context": {
		Doc:   "audio.CurrentContext",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := audio.CurrentContext()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-context")
			return res0Obj
		},
	},
	"audio-context": {
		Doc:   "audio.NewContext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-context: arg 1: expected integer")
			}
			res0 := audio.NewContext(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-context")
			return res0Obj
		},
	},
	"audio-infinite-loop": {
		Doc:   "audio.NewInfiniteLoop",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ReadSeeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.ReadSeeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: expected native of type io.ReadSeeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop: arg 2: expected integer")
			}
			res0 := audio.NewInfiniteLoop(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-infinite-loop")
			return res0Obj
		},
	},
	"audio-infinite-loop-with-intro": {
		Doc:   "audio.NewInfiniteLoopWithIntro",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ReadSeeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.ReadSeeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: expected native of type io.ReadSeeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 2: expected integer")
			}
			var arg2Val int64
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 3: expected integer")
			}
			res0 := audio.NewInfiniteLoopWithIntro(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-infinite-loop")
			return res0Obj
		},
	},
	"audio-player": {
		Doc:   "audio.NewPlayer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player: arg 2: expected native")
			}
			res0, resErr := audio.NewPlayer(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-player")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"audio-player-from-bytes": {
		Doc:   "audio.NewPlayerFromBytes",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player-from-bytes: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("audio-player-from-bytes: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("audio-player-from-bytes: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-player-from-bytes: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-player-from-bytes: arg 2: expected block, native or nil")
			}
			res0 := audio.NewPlayerFromBytes(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-player")
			return res0Obj
		},
	},
	"audio-resample": {
		Doc:   "audio.Resample",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ReadSeeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("audio-resample: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.ReadSeeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-resample: arg 1: expected native of type io.ReadSeeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-resample: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-resample: arg 4: expected integer")
			}
			res0 := audio.Resample(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "io-read-seeker")
				}
			}
			return res0Obj
		},
	},
	"blend-dest-png": {
		Doc:   "Get blend.Dest_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Dest_png))
				for i, it := range blend.Dest_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blend-source-png": {
		Doc:   "Get blend.Source_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Source_png))
				for i, it := range blend.Source_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-angle-0": {
		Doc:   "Get blocks.Angle0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle0)))
			return resObj
		},
	},
	"blocks-angle-180": {
		Doc:   "Get blocks.Angle180 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle180)))
			return resObj
		},
	},
	"blocks-angle-270": {
		Doc:   "Get blocks.Angle270 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle270)))
			return resObj
		},
	},
	"blocks-angle-90": {
		Doc:   "Get blocks.Angle90 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle90)))
			return resObj
		},
	},
	"blocks-angle//rotate-left": {
		Doc:   "blocks.Angle.RotateLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("blocks-angle//rotate-left: arg 1: expected integer")
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"blocks-angle//rotate-right": {
		Doc:   "blocks.Angle.RotateRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("blocks-angle//rotate-right: arg 1: expected integer")
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"blocks-block-type-1": {
		Doc:   "Get blocks.BlockType1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType1)))
			return resObj
		},
	},
	"blocks-block-type-2": {
		Doc:   "Get blocks.BlockType2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType2)))
			return resObj
		},
	},
	"blocks-block-type-3": {
		Doc:   "Get blocks.BlockType3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType3)))
			return resObj
		},
	},
	"blocks-block-type-4": {
		Doc:   "Get blocks.BlockType4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType4)))
			return resObj
		},
	},
	"blocks-block-type-5": {
		Doc:   "Get blocks.BlockType5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType5)))
			return resObj
		},
	},
	"blocks-block-type-6": {
		Doc:   "Get blocks.BlockType6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType6)))
			return resObj
		},
	},
	"blocks-block-type-7": {
		Doc:   "Get blocks.BlockType7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType7)))
			return resObj
		},
	},
	"blocks-block-type-max": {
		Doc:   "Get blocks.BlockTypeMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeMax)))
			return resObj
		},
	},
	"blocks-block-type-none": {
		Doc:   "Get blocks.BlockTypeNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeNone)))
			return resObj
		},
	},
	"blocks-game": {
		Doc:   "Create a new blocks.Game struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Game{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-game")
			return resObj
		},
	},
	"blocks-game-scene": {
		Doc:   "blocks.NewGameScene",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := blocks.NewGameScene()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-blocks-game-scene")
			return res0Obj
		},
	},
	"blocks-game-state": {
		Doc:   "Create a new blocks.GameState struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.GameState{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-game-state")
			return resObj
		},
	},
	"blocks-gamepad-scene": {
		Doc:   "Create a new blocks.GamepadScene struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.GamepadScene{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-gamepad-scene")
			return resObj
		},
	},
	"blocks-input": {
		Doc:   "Create a new blocks.Input struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Input{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-input")
			return resObj
		},
	},
	"blocks-piece": {
		Doc:   "Create a new blocks.Piece struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.Piece{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-piece")
			return resObj
		},
	},
	"blocks-scene-manager": {
		Doc:   "Create a new blocks.SceneManager struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.SceneManager{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-scene-manager")
			return resObj
		},
	},
	"blocks-title-scene": {
		Doc:   "Create a new blocks.TitleScene struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &blocks.TitleScene{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-blocks-title-scene")
			return resObj
		},
	},
	"blocks-pieces": {
		Doc:   "Get blocks.Pieces value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, blocks.Pieces, "map(blocks-block-type)ptr-blocks-piece")
			return resObj
		},
	},
	"blocks-scene//draw": {
		Doc:   "blocks.Scene.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_blocks_Scene(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(blocks.Scene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 1: expected native of type blocks.Scene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"blocks-scene//update": {
		Doc:   "blocks.Scene.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_blocks_Scene(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(blocks.Scene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 1: expected native of type blocks.Scene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//update: arg 2: expected native")
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"bytes-compare": {
		Doc:   "bytes.Compare",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-compare: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-compare: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-compare: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-compare: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-compare: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-compare: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-compare: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-compare: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-compare: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-compare: arg 2: expected block, native or nil")
			}
			res0 := bytes.Compare(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-contains": {
		Doc:   "bytes.Contains",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-contains: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-contains: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-contains: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-contains: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains: arg 2: expected block, native or nil")
			}
			res0 := bytes.Contains(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-contains-any": {
		Doc:   "bytes.ContainsAny",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-contains-any: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains-any: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-any: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-any: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains-any: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-contains-any: arg 2: expected string")
			}
			res0 := bytes.ContainsAny(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-contains-rune": {
		Doc:   "bytes.ContainsRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-contains-rune: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-contains-rune: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-rune: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains-rune: arg 1: expected block, native or nil")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-contains-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-contains-rune: arg 2: expected native")
			}
			res0 := bytes.ContainsRune(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-count": {
		Doc:   "bytes.Count",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-count: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-count: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-count: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-count: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-count: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-count: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-count: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-count: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-count: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-count: arg 2: expected block, native or nil")
			}
			res0 := bytes.Count(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-cut": {
		Doc:   "bytes.Cut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-cut: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-cut: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-cut: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-cut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-cut: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-cut: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-cut: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-cut: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-cut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-cut: arg 2: expected block, native or nil")
			}
			res0, res1, res2 := bytes.Cut(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res2Obj env.Object
			res2Obj = *env.NewInteger(boolToInt64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"bytes-equal": {
		Doc:   "bytes.Equal",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-equal: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-equal: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-equal: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-equal: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal: arg 2: expected block, native or nil")
			}
			res0 := bytes.Equal(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-equal-fold": {
		Doc:   "bytes.EqualFold",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-equal-fold: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal-fold: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-equal-fold: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal-fold: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal-fold: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-equal-fold: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-equal-fold: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-equal-fold: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-equal-fold: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-equal-fold: arg 2: expected block, native or nil")
			}
			res0 := bytes.EqualFold(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-fields": {
		Doc:   "bytes.Fields",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-fields: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-fields: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-fields: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-fields: arg 1: expected block, native or nil")
			}
			res0 := bytes.Fields(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-fields-func": {
		Doc:   "bytes.FieldsFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-fields-func: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-fields-func: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-fields-func: arg 1: expected block, native or nil")
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-fields-func: arg 2: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-fields-func: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-fields-func: arg 2: expected function or nil")
			}
			res0 := bytes.FieldsFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-has-prefix": {
		Doc:   "bytes.HasPrefix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-has-prefix: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-prefix: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-has-prefix: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-prefix: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-prefix: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-has-prefix: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-prefix: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-has-prefix: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-prefix: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-prefix: arg 2: expected block, native or nil")
			}
			res0 := bytes.HasPrefix(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-has-suffix": {
		Doc:   "bytes.HasSuffix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-has-suffix: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-suffix: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-has-suffix: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-suffix: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-suffix: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-has-suffix: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-has-suffix: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-has-suffix: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-has-suffix: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-has-suffix: arg 2: expected block, native or nil")
			}
			res0 := bytes.HasSuffix(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"bytes-index": {
		Doc:   "bytes.Index",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-index: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-index: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index: arg 2: expected block, native or nil")
			}
			res0 := bytes.Index(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-any": {
		Doc:   "bytes.IndexAny",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-index-any: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-any: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index-any: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-any: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-any: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-index-any: arg 2: expected string")
			}
			res0 := bytes.IndexAny(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-byte": {
		Doc:   "bytes.IndexByte",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-index-byte: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-byte: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index-byte: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-byte: arg 1: expected block, native or nil")
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index-byte: arg 2: expected native of type byte")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-byte: arg 2: expected native")
			}
			res0 := bytes.IndexByte(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-func": {
		Doc:   "bytes.IndexFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-index-func: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-func: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-func: arg 1: expected block, native or nil")
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-index-func: arg 2: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-func: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-func: arg 2: expected function or nil")
			}
			res0 := bytes.IndexFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-index-rune": {
		Doc:   "bytes.IndexRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-index-rune: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-index-rune: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index-rune: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-index-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-rune: arg 1: expected block, native or nil")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-index-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-index-rune: arg 2: expected native")
			}
			res0 := bytes.IndexRune(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-join": {
		Doc:   "bytes.Join",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val [][]byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([][]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Block:
						arg0Val[i] = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								arg0Val[i][i], ok = v.Value.(byte)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("bytes-join: arg 1: block item: block item: expected native of type byte")
								}
							default:
								ps.FailureFlag = true
								return env.NewError("bytes-join: arg 1: block item: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.([]byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-join: arg 1: block item: expected native of type []byte")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("bytes-join: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-join: arg 1: block item: expected block, native or nil")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([][]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-join: arg 1: expected native of type [][]byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-join: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-join: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-join: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-join: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-join: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-join: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-join: arg 2: expected block, native or nil")
			}
			res0 := bytes.Join(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-last-index": {
		Doc:   "bytes.LastIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index: arg 2: expected block, native or nil")
			}
			res0 := bytes.LastIndex(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-last-index-any": {
		Doc:   "bytes.LastIndexAny",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index-any: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index-any: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-any: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-any: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-any: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-any: arg 2: expected string")
			}
			res0 := bytes.LastIndexAny(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-last-index-byte": {
		Doc:   "bytes.LastIndexByte",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index-byte: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index-byte: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-byte: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-byte: arg 1: expected block, native or nil")
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-byte: arg 2: expected native of type byte")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-byte: arg 2: expected native")
			}
			res0 := bytes.LastIndexByte(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-last-index-func": {
		Doc:   "bytes.LastIndexFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-last-index-func: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-last-index-func: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-func: arg 1: expected block, native or nil")
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-last-index-func: arg 2: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-last-index-func: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-last-index-func: arg 2: expected function or nil")
			}
			res0 := bytes.LastIndexFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"bytes-map": {
		Doc:   "bytes.Map",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val func(rune) rune
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 1: function has invalid number of arguments (expected 1)")
				}
				arg0Val = func(arg0 rune) rune {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res rune
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(rune)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"bytes-map: arg 1: callback result: expected native of type rune",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-map: arg 1: callback result: expected native",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-map: arg 1: expected function or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-map: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-map: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-map: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-map: arg 2: expected block, native or nil")
			}
			res0 := bytes.Map(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-buffer": {
		Doc:   "bytes.NewBuffer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-buffer: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-buffer: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-buffer: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-buffer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-buffer: arg 1: expected block, native or nil")
			}
			res0 := bytes.NewBuffer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-bytes-buffer")
			return res0Obj
		},
	},
	"bytes-buffer-string": {
		Doc:   "bytes.NewBufferString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-buffer-string: arg 1: expected string")
			}
			res0 := bytes.NewBufferString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-bytes-buffer")
			return res0Obj
		},
	},
	"bytes-reader": {
		Doc:   "bytes.NewReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-reader: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-reader: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-reader: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-reader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-reader: arg 1: expected block, native or nil")
			}
			res0 := bytes.NewReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-bytes-reader")
			return res0Obj
		},
	},
	"bytes-repeat": {
		Doc:   "bytes.Repeat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-repeat: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-repeat: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-repeat: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-repeat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-repeat: arg 1: expected block, native or nil")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-repeat: arg 2: expected integer")
			}
			res0 := bytes.Repeat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-replace": {
		Doc:   "bytes.Replace",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-replace: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-replace: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 2: expected block, native or nil")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-replace: arg 3: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace: arg 3: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 3: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 3: expected block, native or nil")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-replace: arg 4: expected integer")
			}
			res0 := bytes.Replace(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-replace-all": {
		Doc:   "bytes.ReplaceAll",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-replace-all: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace-all: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace-all: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-replace-all: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace-all: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace-all: arg 2: expected block, native or nil")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-replace-all: arg 3: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-replace-all: arg 3: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 3: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-replace-all: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-replace-all: arg 3: expected block, native or nil")
			}
			res0 := bytes.ReplaceAll(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-runes": {
		Doc:   "bytes.Runes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-runes: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-runes: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-runes: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-runes: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-runes: arg 1: expected block, native or nil")
			}
			res0 := bytes.Runes(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split": {
		Doc:   "bytes.Split",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split: arg 2: expected block, native or nil")
			}
			res0 := bytes.Split(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split-after": {
		Doc:   "bytes.SplitAfter",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after: arg 2: expected block, native or nil")
			}
			res0 := bytes.SplitAfter(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split-after-n": {
		Doc:   "bytes.SplitAfterN",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after-n: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after-n: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after-n: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after-n: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after-n: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split-after-n: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-after-n: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after-n: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-after-n: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-after-n: arg 2: expected block, native or nil")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-split-after-n: arg 3: expected integer")
			}
			res0 := bytes.SplitAfterN(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-split-n": {
		Doc:   "bytes.SplitN",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split-n: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-n: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split-n: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-n: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-n: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-split-n: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-split-n: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-split-n: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-split-n: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-split-n: arg 2: expected block, native or nil")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-split-n: arg 3: expected integer")
			}
			res0 := bytes.SplitN(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-title": {
		Doc:   "bytes.Title",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-title: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-title: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-title: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-title: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-title: arg 1: expected block, native or nil")
			}
			res0 := bytes.Title(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-lower": {
		Doc:   "bytes.ToLower",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-lower: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-lower: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-lower: arg 1: expected block, native or nil")
			}
			res0 := bytes.ToLower(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-lower-special": {
		Doc:   "bytes.ToLowerSpecial",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unicode.SpecialCase
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(unicode.SpecialCase)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower-special: arg 1: expected native of type unicode.SpecialCase")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-lower-special: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-lower-special: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-lower-special: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower-special: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-lower-special: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-lower-special: arg 2: expected block, native or nil")
			}
			res0 := bytes.ToLowerSpecial(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-title": {
		Doc:   "bytes.ToTitle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-title: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-title: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-title: arg 1: expected block, native or nil")
			}
			res0 := bytes.ToTitle(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-title-special": {
		Doc:   "bytes.ToTitleSpecial",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unicode.SpecialCase
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(unicode.SpecialCase)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title-special: arg 1: expected native of type unicode.SpecialCase")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-title-special: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-title-special: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-title-special: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title-special: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-title-special: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-title-special: arg 2: expected block, native or nil")
			}
			res0 := bytes.ToTitleSpecial(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-upper": {
		Doc:   "bytes.ToUpper",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-upper: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-upper: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-upper: arg 1: expected block, native or nil")
			}
			res0 := bytes.ToUpper(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-upper-special": {
		Doc:   "bytes.ToUpperSpecial",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unicode.SpecialCase
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(unicode.SpecialCase)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper-special: arg 1: expected native of type unicode.SpecialCase")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-upper-special: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-upper-special: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-upper-special: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper-special: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-upper-special: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-upper-special: arg 2: expected block, native or nil")
			}
			res0 := bytes.ToUpperSpecial(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-to-valid-utf-8": {
		Doc:   "bytes.ToValidUTF8",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-valid-utf-8: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-valid-utf-8: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-valid-utf-8: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-valid-utf-8: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-valid-utf-8: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-to-valid-utf-8: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-to-valid-utf-8: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-to-valid-utf-8: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-to-valid-utf-8: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-to-valid-utf-8: arg 2: expected block, native or nil")
			}
			res0 := bytes.ToValidUTF8(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim": {
		Doc:   "bytes.Trim",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-trim: arg 2: expected string")
			}
			res0 := bytes.Trim(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-func": {
		Doc:   "bytes.TrimFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-func: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-func: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-func: arg 1: expected block, native or nil")
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-trim-func: arg 2: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-func: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-func: arg 2: expected function or nil")
			}
			res0 := bytes.TrimFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-left": {
		Doc:   "bytes.TrimLeft",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-left: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-left: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left: arg 2: expected string")
			}
			res0 := bytes.TrimLeft(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-left-func": {
		Doc:   "bytes.TrimLeftFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-left-func: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-left-func: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left-func: arg 1: expected block, native or nil")
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-trim-left-func: arg 2: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-left-func: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-left-func: arg 2: expected function or nil")
			}
			res0 := bytes.TrimLeftFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-prefix": {
		Doc:   "bytes.TrimPrefix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-prefix: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-prefix: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-prefix: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-prefix: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-prefix: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-prefix: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-prefix: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-prefix: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-prefix: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-prefix: arg 2: expected block, native or nil")
			}
			res0 := bytes.TrimPrefix(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-right": {
		Doc:   "bytes.TrimRight",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-right: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-right: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right: arg 2: expected string")
			}
			res0 := bytes.TrimRight(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-right-func": {
		Doc:   "bytes.TrimRightFunc",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-right-func: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-right-func: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right-func: arg 1: expected block, native or nil")
			}
			var arg1Val func(rune) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"bytes-trim-right-func: arg 2: callback result: expected integer",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-right-func: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-right-func: arg 2: expected function or nil")
			}
			res0 := bytes.TrimRightFunc(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-space": {
		Doc:   "bytes.TrimSpace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-space: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-space: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-space: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-space: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-space: arg 1: expected block, native or nil")
			}
			res0 := bytes.TrimSpace(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"bytes-trim-suffix": {
		Doc:   "bytes.TrimSuffix",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-suffix: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-suffix: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-suffix: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-suffix: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-suffix: arg 1: expected block, native or nil")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("bytes-trim-suffix: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("bytes-trim-suffix: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-suffix: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("bytes-trim-suffix: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("bytes-trim-suffix: arg 2: expected block, native or nil")
			}
			res0 := bytes.TrimSuffix(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"color-alpha-16-model": {
		Doc:   "Get color.Alpha16Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.Alpha16Model)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.Alpha16Model, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.Alpha16Model, "color-model")
				}
			}
			return resObj
		},
	},
	"color-alpha-16//rgba": {
		Doc:   "color.Alpha16.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-alpha-16//rgba: arg 1: expected native of type *color.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-alpha-16//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-alpha-16//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-alpha-model": {
		Doc:   "Get color.AlphaModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.AlphaModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.AlphaModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.AlphaModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-alpha//rgba": {
		Doc:   "color.Alpha.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-alpha//rgba: arg 1: expected native of type *color.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-alpha//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-alpha//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-cmyk-model": {
		Doc:   "Get color.CMYKModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.CMYKModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.CMYKModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.CMYKModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-cmyk-to-rgb": {
		Doc:   "color.CMYKToRGB",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 1: expected integer")
			}
			var arg1Val uint8
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 2: expected integer")
			}
			var arg2Val uint8
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 3: expected integer")
			}
			var arg3Val uint8
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-cmyk-to-rgb: arg 4: expected integer")
			}
			res0, res1, res2 := color.CMYKToRGB(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"color-cmyk//rgba": {
		Doc:   "color.CMYK.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-cmyk//rgba: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-cmyk//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-cmyk//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-color//rgba": {
		Doc:   "color.Color.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("color-color//rgba: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-color//rgba: arg 1: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-color//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-color//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-gray-16-model": {
		Doc:   "Get color.Gray16Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.Gray16Model)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.Gray16Model, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.Gray16Model, "color-model")
				}
			}
			return resObj
		},
	},
	"color-gray-16//rgba": {
		Doc:   "color.Gray16.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-gray-16//rgba: arg 1: expected native of type *color.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-gray-16//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-gray-16//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-gray-model": {
		Doc:   "Get color.GrayModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.GrayModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.GrayModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.GrayModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-gray//rgba": {
		Doc:   "color.Gray.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-gray//rgba: arg 1: expected native of type *color.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-gray//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-gray//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-model-func": {
		Doc:   "color.ModelFunc",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val func(color.Color) color.Color
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("color-model-func: arg 1: function has invalid number of arguments (expected 1)")
				}
				arg0Val = func(arg0 color.Color) color.Color {
					var arg0Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typRyeName string
						var ok bool
						if typ != nil {
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						}
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
						}
					}
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res color.Color
					switch v := ps.Res.(type) {
					case env.RyeCtx:
						var err error
						res, err = ctxTo_color_Color(ps, v)
						if err != nil {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"color-model-func: arg 1: callback result: "+err.Error()+"",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.(color.Color)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"color-model-func: arg 1: callback result: expected native of type color.Color",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					case env.Integer:
						if v.Value != 0 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"color-model-func: arg 1: callback result: expected integer to be 0 or nil",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
						res = nil
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"color-model-func: arg 1: callback result: expected native",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-model-func: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-model-func: arg 1: expected function or nil")
			}
			res0 := color.ModelFunc(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"color-model//convert": {
		Doc:   "color.Model.Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Model
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("color-model//convert: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Model)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-model//convert: arg 1: expected native of type color.Model")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-model//convert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-model//convert: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("color-model//convert: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-model//convert: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-model//convert: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-model//convert: arg 2: expected native")
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"color-alpha": {
		Doc:   "Create a new color.Alpha struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Alpha{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-alpha")
			return resObj
		},
	},
	"color-alpha-16": {
		Doc:   "Create a new color.Alpha16 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Alpha16{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-alpha-16")
			return resObj
		},
	},
	"color-cmyk": {
		Doc:   "Create a new color.CMYK struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.CMYK{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-cmyk")
			return resObj
		},
	},
	"color-gray": {
		Doc:   "Create a new color.Gray struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Gray{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-gray")
			return resObj
		},
	},
	"color-gray-16": {
		Doc:   "Create a new color.Gray16 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.Gray16{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-gray-16")
			return resObj
		},
	},
	"color-nrgba": {
		Doc:   "Create a new color.NRGBA struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.NRGBA{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-nrgba")
			return resObj
		},
	},
	"color-nrgba-64": {
		Doc:   "Create a new color.NRGBA64 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.NRGBA64{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-nrgba-64")
			return resObj
		},
	},
	"color-ny-cb-cr-a": {
		Doc:   "Create a new color.NYCbCrA struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.NYCbCrA{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-ny-cb-cr-a")
			return resObj
		},
	},
	"color-rgba": {
		Doc:   "Create a new color.RGBA struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.RGBA{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-rgba")
			return resObj
		},
	},
	"color-rgba-64": {
		Doc:   "Create a new color.RGBA64 struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.RGBA64{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-rgba-64")
			return resObj
		},
	},
	"color-y-cb-cr": {
		Doc:   "Create a new color.YCbCr struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &color.YCbCr{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-color-y-cb-cr")
			return resObj
		},
	},
	"color-nrgba-64-model": {
		Doc:   "Get color.NRGBA64Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.NRGBA64Model)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.NRGBA64Model, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.NRGBA64Model, "color-model")
				}
			}
			return resObj
		},
	},
	"color-nrgba-64//rgba": {
		Doc:   "color.NRGBA64.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-nrgba-64//rgba: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-nrgba-64//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-nrgba-64//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-nrgba-model": {
		Doc:   "Get color.NRGBAModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.NRGBAModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.NRGBAModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.NRGBAModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-nrgba//rgba": {
		Doc:   "color.NRGBA.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-nrgba//rgba: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-nrgba//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-nrgba//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-ny-cb-cr-a-model": {
		Doc:   "Get color.NYCbCrAModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.NYCbCrAModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.NYCbCrAModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.NYCbCrAModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-ny-cb-cr-a//rgba": {
		Doc:   "color.NYCbCrA.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-ny-cb-cr-a//rgba: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-ny-cb-cr-a//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-ny-cb-cr-a//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-palette//convert": {
		Doc:   "color.Palette.Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Palette
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u []color.Color
					switch v := arg0.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("color-palette//convert: arg 1: block item: " + err.Error() + "")
								}
							case env.Native:
								var ok bool
								u[i], ok = v.Value.(color.Color)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("color-palette//convert: arg 1: block item: expected native of type color.Color")
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("color-palette//convert: arg 1: block item: expected integer to be 0 or nil")
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("color-palette//convert: arg 1: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						u, ok = v.Value.([]color.Color)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("color-palette//convert: arg 1: expected native of type []color.Color")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("color-palette//convert: arg 1: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("color-palette//convert: arg 1: expected block, native or nil")
					}
					arg0Val = color.Palette(u)
				}
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("color-palette//convert: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-palette//convert: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-palette//convert: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-palette//convert: arg 2: expected native")
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"color-palette//index": {
		Doc:   "color.Palette.Index",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Palette
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u []color.Color
					switch v := arg0.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("color-palette//index: arg 1: block item: " + err.Error() + "")
								}
							case env.Native:
								var ok bool
								u[i], ok = v.Value.(color.Color)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("color-palette//index: arg 1: block item: expected native of type color.Color")
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("color-palette//index: arg 1: block item: expected integer to be 0 or nil")
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("color-palette//index: arg 1: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						u, ok = v.Value.([]color.Color)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("color-palette//index: arg 1: expected native of type []color.Color")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("color-palette//index: arg 1: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("color-palette//index: arg 1: expected block, native or nil")
					}
					arg0Val = color.Palette(u)
				}
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("color-palette//index: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-palette//index: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-palette//index: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-palette//index: arg 2: expected native")
			}
			res0 := arg0Val.Index(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"color-rgb-to-cmyk": {
		Doc:   "color.RGBToCMYK",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-cmyk: arg 1: expected integer")
			}
			var arg1Val uint8
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-cmyk: arg 2: expected integer")
			}
			var arg2Val uint8
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-cmyk: arg 3: expected integer")
			}
			res0, res1, res2, res3 := color.RGBToCMYK(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-rgb-to-y-cb-cr": {
		Doc:   "color.RGBToYCbCr",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-y-cb-cr: arg 1: expected integer")
			}
			var arg1Val uint8
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-y-cb-cr: arg 2: expected integer")
			}
			var arg2Val uint8
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-rgb-to-y-cb-cr: arg 3: expected integer")
			}
			res0, res1, res2 := color.RGBToYCbCr(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"color-rgba-64-model": {
		Doc:   "Get color.RGBA64Model value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.RGBA64Model)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.RGBA64Model, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.RGBA64Model, "color-model")
				}
			}
			return resObj
		},
	},
	"color-rgba-64//rgba": {
		Doc:   "color.RGBA64.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-rgba-64//rgba: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-rgba-64//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-rgba-64//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-rgba-model": {
		Doc:   "Get color.RGBAModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.RGBAModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.RGBAModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.RGBAModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-rgba//rgba": {
		Doc:   "color.RGBA.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-rgba//rgba: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-rgba//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-rgba//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"color-y-cb-cr-model": {
		Doc:   "Get color.YCbCrModel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(color.YCbCrModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, color.YCbCrModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, color.YCbCrModel, "color-model")
				}
			}
			return resObj
		},
	},
	"color-y-cb-cr-to-rgb": {
		Doc:   "color.YCbCrToRGB",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val uint8
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr-to-rgb: arg 1: expected integer")
			}
			var arg1Val uint8
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr-to-rgb: arg 2: expected integer")
			}
			var arg2Val uint8
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr-to-rgb: arg 3: expected integer")
			}
			res0, res1, res2 := color.YCbCrToRGB(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"color-y-cb-cr//rgba": {
		Doc:   "color.YCbCr.RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("color-y-cb-cr//rgba: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("color-y-cb-cr//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("color-y-cb-cr//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := (*arg0Val).RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"colorm-draw-image": {
		Doc:   "colorm.DrawImage",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 2: expected native")
			}
			var arg2Val colorm.ColorM
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 3: expected native of type colorm.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 3: expected native")
			}
			var arg3Val *colorm.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 4: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 4: expected native")
			}
			colorm.DrawImage(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"colorm-draw-image-options": {
		Doc:   "Create a new colorm.DrawImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &colorm.DrawImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-colorm-draw-image-options")
			return resObj
		},
	},
	"colorm-draw-triangles-options": {
		Doc:   "Create a new colorm.DrawTrianglesOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &colorm.DrawTrianglesOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-colorm-draw-triangles-options")
			return resObj
		},
	},
	"draw-draw": {
		Doc:   "draw.Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(draw.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 1: expected native of type draw.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 2: expected native")
			}
			var arg2Val image.Image
			switch v := arg2.(type) {
			case env.RyeCtx:
				var err error
				arg2Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 3: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 3: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 3: expected native")
			}
			var arg3Val *image.Point
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 4: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-draw: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-draw: arg 4: expected native")
			}
			var arg4Val draw.Op
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal draw.Op
				if natOk {
					natVal, natValOk = nat.Value.(draw.Op)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("draw-draw: arg 5: expected integer")
					}
					arg4Val = draw.Op(u)
				}
			}
			draw.Draw(arg0Val, *arg1Val, arg2Val, *arg3Val, arg4Val)
			return nil
		},
	},
	"draw-drawer//draw": {
		Doc:   "draw.Drawer.Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Drawer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Drawer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(draw.Drawer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 1: expected native of type draw.Drawer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-drawer//draw: arg 1: expected native")
			}
			var arg1Val draw.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(draw.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 2: expected native of type draw.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-drawer//draw: arg 2: expected native")
			}
			var arg2Val *image.Rectangle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 3: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-drawer//draw: arg 3: expected native")
			}
			var arg3Val image.Image
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 4: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-drawer//draw: arg 4: expected native")
			}
			var arg4Val *image.Point
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 5: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-drawer//draw: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-drawer//draw: arg 5: expected native")
			}
			arg0Val.Draw(arg1Val, *arg2Val, arg3Val, *arg4Val)
			return arg0
		},
	},
	"draw-floyd-steinberg": {
		Doc:   "Get draw.FloydSteinberg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(draw.FloydSteinberg)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, draw.FloydSteinberg, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, draw.FloydSteinberg, "draw-drawer")
				}
			}
			return resObj
		},
	},
	"draw-image//set": {
		Doc:   "draw.Image.Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-image//set: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(draw.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-image//set: arg 1: expected native of type draw.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-image//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-image//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-image//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-image//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-image//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-image//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-image//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-image//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"draw-op//draw": {
		Doc:   "draw.Op.Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Op
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal draw.Op
				if natOk {
					natVal, natValOk = nat.Value.(draw.Op)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("draw-op//draw: arg 1: expected integer")
					}
					arg0Val = draw.Op(u)
				}
			}
			var arg1Val draw.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_draw_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(draw.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 2: expected native of type draw.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-op//draw: arg 2: expected native")
			}
			var arg2Val *image.Rectangle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 3: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-op//draw: arg 3: expected native")
			}
			var arg3Val image.Image
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 4: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-op//draw: arg 4: expected native")
			}
			var arg4Val *image.Point
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 5: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-op//draw: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-op//draw: arg 5: expected native")
			}
			arg0Val.Draw(arg1Val, *arg2Val, arg3Val, *arg4Val)
			return arg0
		},
	},
	"draw-over": {
		Doc:   "Get draw.Over value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(draw.Over)))
			return resObj
		},
	},
	"draw-quantizer//quantize": {
		Doc:   "draw.Quantizer.Quantize",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.Quantizer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_Quantizer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-quantizer//quantize: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(draw.Quantizer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-quantizer//quantize: arg 1: expected native of type draw.Quantizer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-quantizer//quantize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-quantizer//quantize: arg 1: expected native")
			}
			var arg1Val color.Palette
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u []color.Color
					switch v := arg1.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("draw-quantizer//quantize: arg 2: block item: " + err.Error() + "")
								}
							case env.Native:
								var ok bool
								u[i], ok = v.Value.(color.Color)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("draw-quantizer//quantize: arg 2: block item: expected native of type color.Color")
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("draw-quantizer//quantize: arg 2: block item: expected integer to be 0 or nil")
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("draw-quantizer//quantize: arg 2: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						u, ok = v.Value.([]color.Color)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("draw-quantizer//quantize: arg 2: expected native of type []color.Color")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("draw-quantizer//quantize: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("draw-quantizer//quantize: arg 2: expected block, native or nil")
					}
					arg1Val = color.Palette(u)
				}
			}
			var arg2Val image.Image
			switch v := arg2.(type) {
			case env.RyeCtx:
				var err error
				arg2Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-quantizer//quantize: arg 3: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-quantizer//quantize: arg 3: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-quantizer//quantize: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-quantizer//quantize: arg 3: expected native")
			}
			res0 := arg0Val.Quantize(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len([]color.Color(res0)))
				for i, it := range []color.Color(res0) {
					{
						typ := reflect.TypeOf(it)
						var typRyeName string
						var ok bool
						if typ != nil {
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						}
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "color-color")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"draw-rgba-64-image//set": {
		Doc:   "draw.RGBA64Image.Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(draw.RGBA64Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set: arg 1: expected native of type draw.RGBA64Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"draw-rgba-64-image//set-rgba-64": {
		Doc:   "draw.RGBA64Image.SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val draw.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_draw_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set-rgba-64: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(draw.RGBA64Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set-rgba-64: arg 1: expected native of type draw.RGBA64Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-rgba-64-image//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-rgba-64-image//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"draw-src": {
		Doc:   "Get draw.Src value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(draw.Src)))
			return resObj
		},
	},
	"actual-fps": {
		Doc:   "ebiten.ActualFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.ActualFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"actual-tps": {
		Doc:   "ebiten.ActualTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.ActualTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"address-clamp-to-zero": {
		Doc:   "Get ebiten.AddressClampToZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressClampToZero)))
			return resObj
		},
	},
	"address-repeat": {
		Doc:   "Get ebiten.AddressRepeat value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressRepeat)))
			return resObj
		},
	},
	"address-unsafe": {
		Doc:   "Get ebiten.AddressUnsafe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressUnsafe)))
			return resObj
		},
	},
	"append-gamepad-i-ds": {
		Doc:   "ebiten.AppendGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadID)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("append-gamepad-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.GamepadID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.GamepadID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-gamepad-i-ds: arg 1: expected native of type []ebiten.GamepadID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-gamepad-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-gamepad-i-ds: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-input-chars": {
		Doc:   "ebiten.AppendInputChars",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []rune
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(rune)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("append-input-chars: arg 1: block item: expected native of type rune")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("append-input-chars: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-input-chars: arg 1: expected native of type []rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-input-chars: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-input-chars: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendInputChars(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-monitors": {
		Doc:   "ebiten.AppendMonitors",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []*ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*ebiten.MonitorType, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*ebiten.MonitorType)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("append-monitors: arg 1: block item: expected native of type *ebiten.MonitorType")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("append-monitors: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("append-monitors: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-monitors: arg 1: expected native of type []*ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-monitors: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-monitors: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendMonitors(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-ebiten-monitor-type")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-touch-i-ds": {
		Doc:   "ebiten.AppendTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("append-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"blend-factor-default": {
		Doc:   "Get ebiten.BlendFactorDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDefault), "byte")
			return resObj
		},
	},
	"blend-factor-destination-alpha": {
		Doc:   "Get ebiten.BlendFactorDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-destination-color": {
		Doc:   "Get ebiten.BlendFactorDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationColor), "byte")
			return resObj
		},
	},
	"blend-factor-one": {
		Doc:   "Get ebiten.BlendFactorOne value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOne), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-alpha": {
		Doc:   "Get ebiten.BlendFactorOneMinusDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-color": {
		Doc:   "Get ebiten.BlendFactorOneMinusDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationColor), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-source-alpha": {
		Doc:   "Get ebiten.BlendFactorOneMinusSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-source-color": {
		Doc:   "Get ebiten.BlendFactorOneMinusSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceColor), "byte")
			return resObj
		},
	},
	"blend-factor-source-alpha": {
		Doc:   "Get ebiten.BlendFactorSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-source-color": {
		Doc:   "Get ebiten.BlendFactorSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceColor), "byte")
			return resObj
		},
	},
	"blend-factor-zero": {
		Doc:   "Get ebiten.BlendFactorZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorZero), "byte")
			return resObj
		},
	},
	"blend-operation-add": {
		Doc:   "Get ebiten.BlendOperationAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationAdd), "byte")
			return resObj
		},
	},
	"blend-operation-max": {
		Doc:   "Get ebiten.BlendOperationMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMax), "byte")
			return resObj
		},
	},
	"blend-operation-min": {
		Doc:   "Get ebiten.BlendOperationMin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMin), "byte")
			return resObj
		},
	},
	"blend-operation-reverse-subtract": {
		Doc:   "Get ebiten.BlendOperationReverseSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationReverseSubtract), "byte")
			return resObj
		},
	},
	"blend-operation-subtract": {
		Doc:   "Get ebiten.BlendOperationSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationSubtract), "byte")
			return resObj
		},
	},
	"color-scale-mode-premultiplied-alpha": {
		Doc:   "Get ebiten.ColorScaleModePremultipliedAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModePremultipliedAlpha)))
			return resObj
		},
	},
	"color-scale-mode-straight-alpha": {
		Doc:   "Get ebiten.ColorScaleModeStraightAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModeStraightAlpha)))
			return resObj
		},
	},
	"composite-mode-clear": {
		Doc:   "Get ebiten.CompositeModeClear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeClear)))
			return resObj
		},
	},
	"composite-mode-copy": {
		Doc:   "Get ebiten.CompositeModeCopy value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCopy)))
			return resObj
		},
	},
	"composite-mode-custom": {
		Doc:   "Get ebiten.CompositeModeCustom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCustom)))
			return resObj
		},
	},
	"composite-mode-destination": {
		Doc:   "Get ebiten.CompositeModeDestination value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestination)))
			return resObj
		},
	},
	"composite-mode-destination-atop": {
		Doc:   "Get ebiten.CompositeModeDestinationAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationAtop)))
			return resObj
		},
	},
	"composite-mode-destination-in": {
		Doc:   "Get ebiten.CompositeModeDestinationIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationIn)))
			return resObj
		},
	},
	"composite-mode-destination-out": {
		Doc:   "Get ebiten.CompositeModeDestinationOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOut)))
			return resObj
		},
	},
	"composite-mode-destination-over": {
		Doc:   "Get ebiten.CompositeModeDestinationOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOver)))
			return resObj
		},
	},
	"composite-mode-lighter": {
		Doc:   "Get ebiten.CompositeModeLighter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeLighter)))
			return resObj
		},
	},
	"composite-mode-multiply": {
		Doc:   "Get ebiten.CompositeModeMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeMultiply)))
			return resObj
		},
	},
	"composite-mode-source-atop": {
		Doc:   "Get ebiten.CompositeModeSourceAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceAtop)))
			return resObj
		},
	},
	"composite-mode-source-in": {
		Doc:   "Get ebiten.CompositeModeSourceIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceIn)))
			return resObj
		},
	},
	"composite-mode-source-out": {
		Doc:   "Get ebiten.CompositeModeSourceOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOut)))
			return resObj
		},
	},
	"composite-mode-source-over": {
		Doc:   "Get ebiten.CompositeModeSourceOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOver)))
			return resObj
		},
	},
	"composite-mode-xor": {
		Doc:   "Get ebiten.CompositeModeXor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeXor)))
			return resObj
		},
	},
	"current-fps": {
		Doc:   "ebiten.CurrentFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"current-tps": {
		Doc:   "ebiten.CurrentTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"cursor-mode": {
		Doc:   "ebiten.CursorMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CursorMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"cursor-mode-captured": {
		Doc:   "Get ebiten.CursorModeCaptured value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeCaptured)))
			return resObj
		},
	},
	"cursor-mode-hidden": {
		Doc:   "Get ebiten.CursorModeHidden value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeHidden)))
			return resObj
		},
	},
	"cursor-mode-visible": {
		Doc:   "Get ebiten.CursorModeVisible value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeVisible)))
			return resObj
		},
	},
	"cursor-position": {
		Doc:   "ebiten.CursorPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.CursorPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"cursor-shape": {
		Doc:   "ebiten.CursorShape",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CursorShape()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"cursor-shape-crosshair": {
		Doc:   "Get ebiten.CursorShapeCrosshair value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeCrosshair)))
			return resObj
		},
	},
	"cursor-shape-default": {
		Doc:   "Get ebiten.CursorShapeDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeDefault)))
			return resObj
		},
	},
	"cursor-shape-ew-resize": {
		Doc:   "Get ebiten.CursorShapeEWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeEWResize)))
			return resObj
		},
	},
	"cursor-shape-move": {
		Doc:   "Get ebiten.CursorShapeMove value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeMove)))
			return resObj
		},
	},
	"cursor-shape-nesw-resize": {
		Doc:   "Get ebiten.CursorShapeNESWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNESWResize)))
			return resObj
		},
	},
	"cursor-shape-not-allowed": {
		Doc:   "Get ebiten.CursorShapeNotAllowed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNotAllowed)))
			return resObj
		},
	},
	"cursor-shape-ns-resize": {
		Doc:   "Get ebiten.CursorShapeNSResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNSResize)))
			return resObj
		},
	},
	"cursor-shape-nwse-resize": {
		Doc:   "Get ebiten.CursorShapeNWSEResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNWSEResize)))
			return resObj
		},
	},
	"cursor-shape-pointer": {
		Doc:   "Get ebiten.CursorShapePointer value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapePointer)))
			return resObj
		},
	},
	"cursor-shape-text": {
		Doc:   "Get ebiten.CursorShapeText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeText)))
			return resObj
		},
	},
	"device-scale-factor": {
		Doc:   "ebiten.DeviceScaleFactor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"dropped-files": {
		Doc:   "ebiten.DroppedFiles",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.DroppedFiles()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fs-fs")
				}
			}
			return res0Obj
		},
	},
	"even-odd": {
		Doc:   "Get ebiten.EvenOdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.EvenOdd)))
			return resObj
		},
	},
	"fill-all": {
		Doc:   "Get ebiten.FillAll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FillAll)))
			return resObj
		},
	},
	"filter-linear": {
		Doc:   "Get ebiten.FilterLinear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterLinear)))
			return resObj
		},
	},
	"filter-nearest": {
		Doc:   "Get ebiten.FilterNearest value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterNearest)))
			return resObj
		},
	},
	"ebiten-final-screen-drawer//draw-final-screen": {
		Doc:   "ebiten.FinalScreenDrawer.DrawFinalScreen",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreenDrawer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_FinalScreenDrawer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreenDrawer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected native of type ebiten.FinalScreenDrawer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected native")
			}
			var arg1Val ebiten.FinalScreen
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected native")
			}
			var arg2Val *ebiten.Image
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected native")
			}
			var arg3Val *ebiten.GeoM
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected native")
			}
			arg0Val.DrawFinalScreen(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ebiten-final-screen//bounds": {
		Doc:   "ebiten.FinalScreen.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//bounds: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ebiten-final-screen//clear": {
		Doc:   "ebiten.FinalScreen.Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//clear: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//clear: arg 1: expected native")
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"ebiten-final-screen//draw-image": {
		Doc:   "ebiten.FinalScreen.DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-image: arg 2: expected native")
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 3: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-image: arg 3: expected native")
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-rect-shader": {
		Doc:   "ebiten.FinalScreen.DrawRectShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 3: expected integer")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawRectShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawRectShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected native of type *ebiten.DrawRectShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected native")
			}
			arg0Val.DrawRectShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-triangles": {
		Doc:   "ebiten.FinalScreen.DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-final-screen//draw-triangles: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected native")
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-triangles-shader": {
		Doc:   "ebiten.FinalScreen.DrawTrianglesShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected native")
			}
			arg0Val.DrawTrianglesShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//fill": {
		Doc:   "ebiten.FinalScreen.Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//fill: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//fill: arg 2: expected native")
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"fps-mode": {
		Doc:   "ebiten.FPSMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.FPSMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"fps-mode-vsync-off-maximum": {
		Doc:   "Get ebiten.FPSModeVsyncOffMaximum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOffMaximum)))
			return resObj
		},
	},
	"fps-mode-vsync-off-minimum": {
		Doc:   "Get ebiten.FPSModeVsyncOffMinimum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOffMinimum)))
			return resObj
		},
	},
	"fps-mode-vsync-on": {
		Doc:   "Get ebiten.FPSModeVsyncOn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOn)))
			return resObj
		},
	},
	"ebiten-game//draw": {
		Doc:   "ebiten.Game.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ebiten-game//layout": {
		Doc:   "ebiten.Game.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//layout: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//layout: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ebiten-game//update": {
		Doc:   "ebiten.Game.Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//update: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//update: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//update: arg 1: expected native")
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"gamepad-axis": {
		Doc:   "ebiten.GamepadAxis",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxis(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-count": {
		Doc:   "ebiten.GamepadAxisCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-count: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadAxisCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-num": {
		Doc:   "ebiten.GamepadAxisNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-num: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadAxisNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-value": {
		Doc:   "ebiten.GamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-value: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-button-0": {
		Doc:   "Get ebiten.GamepadButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton0)))
			return resObj
		},
	},
	"gamepad-button-1": {
		Doc:   "Get ebiten.GamepadButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton1)))
			return resObj
		},
	},
	"gamepad-button-10": {
		Doc:   "Get ebiten.GamepadButton10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton10)))
			return resObj
		},
	},
	"gamepad-button-11": {
		Doc:   "Get ebiten.GamepadButton11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton11)))
			return resObj
		},
	},
	"gamepad-button-12": {
		Doc:   "Get ebiten.GamepadButton12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton12)))
			return resObj
		},
	},
	"gamepad-button-13": {
		Doc:   "Get ebiten.GamepadButton13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton13)))
			return resObj
		},
	},
	"gamepad-button-14": {
		Doc:   "Get ebiten.GamepadButton14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton14)))
			return resObj
		},
	},
	"gamepad-button-15": {
		Doc:   "Get ebiten.GamepadButton15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton15)))
			return resObj
		},
	},
	"gamepad-button-16": {
		Doc:   "Get ebiten.GamepadButton16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton16)))
			return resObj
		},
	},
	"gamepad-button-17": {
		Doc:   "Get ebiten.GamepadButton17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton17)))
			return resObj
		},
	},
	"gamepad-button-18": {
		Doc:   "Get ebiten.GamepadButton18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton18)))
			return resObj
		},
	},
	"gamepad-button-19": {
		Doc:   "Get ebiten.GamepadButton19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton19)))
			return resObj
		},
	},
	"gamepad-button-2": {
		Doc:   "Get ebiten.GamepadButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton2)))
			return resObj
		},
	},
	"gamepad-button-20": {
		Doc:   "Get ebiten.GamepadButton20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton20)))
			return resObj
		},
	},
	"gamepad-button-21": {
		Doc:   "Get ebiten.GamepadButton21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton21)))
			return resObj
		},
	},
	"gamepad-button-22": {
		Doc:   "Get ebiten.GamepadButton22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton22)))
			return resObj
		},
	},
	"gamepad-button-23": {
		Doc:   "Get ebiten.GamepadButton23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton23)))
			return resObj
		},
	},
	"gamepad-button-24": {
		Doc:   "Get ebiten.GamepadButton24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton24)))
			return resObj
		},
	},
	"gamepad-button-25": {
		Doc:   "Get ebiten.GamepadButton25 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton25)))
			return resObj
		},
	},
	"gamepad-button-26": {
		Doc:   "Get ebiten.GamepadButton26 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton26)))
			return resObj
		},
	},
	"gamepad-button-27": {
		Doc:   "Get ebiten.GamepadButton27 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton27)))
			return resObj
		},
	},
	"gamepad-button-28": {
		Doc:   "Get ebiten.GamepadButton28 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton28)))
			return resObj
		},
	},
	"gamepad-button-29": {
		Doc:   "Get ebiten.GamepadButton29 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton29)))
			return resObj
		},
	},
	"gamepad-button-3": {
		Doc:   "Get ebiten.GamepadButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton3)))
			return resObj
		},
	},
	"gamepad-button-30": {
		Doc:   "Get ebiten.GamepadButton30 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton30)))
			return resObj
		},
	},
	"gamepad-button-31": {
		Doc:   "Get ebiten.GamepadButton31 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton31)))
			return resObj
		},
	},
	"gamepad-button-4": {
		Doc:   "Get ebiten.GamepadButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton4)))
			return resObj
		},
	},
	"gamepad-button-5": {
		Doc:   "Get ebiten.GamepadButton5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton5)))
			return resObj
		},
	},
	"gamepad-button-6": {
		Doc:   "Get ebiten.GamepadButton6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton6)))
			return resObj
		},
	},
	"gamepad-button-7": {
		Doc:   "Get ebiten.GamepadButton7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton7)))
			return resObj
		},
	},
	"gamepad-button-8": {
		Doc:   "Get ebiten.GamepadButton8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton8)))
			return resObj
		},
	},
	"gamepad-button-9": {
		Doc:   "Get ebiten.GamepadButton9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton9)))
			return resObj
		},
	},
	"gamepad-button-count": {
		Doc:   "ebiten.GamepadButtonCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-button-count: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadButtonCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-button-max": {
		Doc:   "Get ebiten.GamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButtonMax)))
			return resObj
		},
	},
	"gamepad-button-num": {
		Doc:   "ebiten.GamepadButtonNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-button-num: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadButtonNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-i-ds": {
		Doc:   "ebiten.GamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.GamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"gamepad-name": {
		Doc:   "ebiten.GamepadName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-name: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"gamepad-sdlid": {
		Doc:   "ebiten.GamepadSDLID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-sdlid: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadSDLID(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"graphics-library-auto": {
		Doc:   "Get ebiten.GraphicsLibraryAuto value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryAuto)))
			return resObj
		},
	},
	"graphics-library-direct-x": {
		Doc:   "Get ebiten.GraphicsLibraryDirectX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryDirectX)))
			return resObj
		},
	},
	"graphics-library-metal": {
		Doc:   "Get ebiten.GraphicsLibraryMetal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryMetal)))
			return resObj
		},
	},
	"graphics-library-open-gl": {
		Doc:   "Get ebiten.GraphicsLibraryOpenGL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryOpenGL)))
			return resObj
		},
	},
	"graphics-library-play-station-5": {
		Doc:   "Get ebiten.GraphicsLibraryPlayStation5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryPlayStation5)))
			return resObj
		},
	},
	"graphics-library-unknown": {
		Doc:   "Get ebiten.GraphicsLibraryUnknown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryUnknown)))
			return resObj
		},
	},
	"ebiten-graphics-library//string": {
		Doc:   "ebiten.GraphicsLibrary.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GraphicsLibrary
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-graphics-library//string: arg 1: expected integer")
					}
					arg0Val = ebiten.GraphicsLibrary(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"input-chars": {
		Doc:   "ebiten.InputChars",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.InputChars()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"is-focused": {
		Doc:   "ebiten.IsFocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsFocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-fullscreen": {
		Doc:   "ebiten.IsFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-gamepad-button-pressed": {
		Doc:   "ebiten.IsGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-gamepad-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-gamepad-button-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := ebiten.IsGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-key-pressed": {
		Doc:   "ebiten.IsKeyPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-key-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.IsKeyPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-mouse-button-pressed": {
		Doc:   "ebiten.IsMouseButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-mouse-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := ebiten.IsMouseButtonPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-runnable-on-unfocused": {
		Doc:   "ebiten.IsRunnableOnUnfocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsRunnableOnUnfocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-cleared-every-frame": {
		Doc:   "ebiten.IsScreenClearedEveryFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenClearedEveryFrame()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-filter-enabled": {
		Doc:   "ebiten.IsScreenFilterEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenFilterEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-transparent": {
		Doc:   "ebiten.IsScreenTransparent",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenTransparent()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-axis-available": {
		Doc:   "ebiten.IsStandardGamepadAxisAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-axis-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadAxis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadAxis
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadAxis)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-axis-available: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadAxis(u)
				}
			}
			res0 := ebiten.IsStandardGamepadAxisAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-available": {
		Doc:   "ebiten.IsStandardGamepadButtonAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-available: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.IsStandardGamepadButtonAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-pressed": {
		Doc:   "ebiten.IsStandardGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.IsStandardGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-layout-available": {
		Doc:   "ebiten.IsStandardGamepadLayoutAvailable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-layout-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.IsStandardGamepadLayoutAvailable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-vsync-enabled": {
		Doc:   "ebiten.IsVsyncEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsVsyncEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-being-closed": {
		Doc:   "ebiten.IsWindowBeingClosed",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowBeingClosed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-closing-handled": {
		Doc:   "ebiten.IsWindowClosingHandled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowClosingHandled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-decorated": {
		Doc:   "ebiten.IsWindowDecorated",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowDecorated()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-floating": {
		Doc:   "ebiten.IsWindowFloating",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowFloating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-maximized": {
		Doc:   "ebiten.IsWindowMaximized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMaximized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-minimized": {
		Doc:   "ebiten.IsWindowMinimized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMinimized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-mouse-passthrough": {
		Doc:   "ebiten.IsWindowMousePassthrough",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMousePassthrough()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-resizable": {
		Doc:   "ebiten.IsWindowResizable",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowResizable()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"key-0": {
		Doc:   "Get ebiten.Key0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key0)))
			return resObj
		},
	},
	"key-1": {
		Doc:   "Get ebiten.Key1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key1)))
			return resObj
		},
	},
	"key-2": {
		Doc:   "Get ebiten.Key2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key2)))
			return resObj
		},
	},
	"key-3": {
		Doc:   "Get ebiten.Key3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key3)))
			return resObj
		},
	},
	"key-4": {
		Doc:   "Get ebiten.Key4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key4)))
			return resObj
		},
	},
	"key-5": {
		Doc:   "Get ebiten.Key5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key5)))
			return resObj
		},
	},
	"key-6": {
		Doc:   "Get ebiten.Key6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key6)))
			return resObj
		},
	},
	"key-7": {
		Doc:   "Get ebiten.Key7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key7)))
			return resObj
		},
	},
	"key-8": {
		Doc:   "Get ebiten.Key8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key8)))
			return resObj
		},
	},
	"key-9": {
		Doc:   "Get ebiten.Key9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key9)))
			return resObj
		},
	},
	"key-a": {
		Doc:   "Get ebiten.KeyA value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyA)))
			return resObj
		},
	},
	"key-alt": {
		Doc:   "Get ebiten.KeyAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAlt)))
			return resObj
		},
	},
	"key-alt-left": {
		Doc:   "Get ebiten.KeyAltLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltLeft)))
			return resObj
		},
	},
	"key-alt-right": {
		Doc:   "Get ebiten.KeyAltRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltRight)))
			return resObj
		},
	},
	"key-apostrophe": {
		Doc:   "Get ebiten.KeyApostrophe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyApostrophe)))
			return resObj
		},
	},
	"key-arrow-down": {
		Doc:   "Get ebiten.KeyArrowDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowDown)))
			return resObj
		},
	},
	"key-arrow-left": {
		Doc:   "Get ebiten.KeyArrowLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowLeft)))
			return resObj
		},
	},
	"key-arrow-right": {
		Doc:   "Get ebiten.KeyArrowRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowRight)))
			return resObj
		},
	},
	"key-arrow-up": {
		Doc:   "Get ebiten.KeyArrowUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowUp)))
			return resObj
		},
	},
	"key-b": {
		Doc:   "Get ebiten.KeyB value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyB)))
			return resObj
		},
	},
	"key-backquote": {
		Doc:   "Get ebiten.KeyBackquote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackquote)))
			return resObj
		},
	},
	"key-backslash": {
		Doc:   "Get ebiten.KeyBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackslash)))
			return resObj
		},
	},
	"key-backspace": {
		Doc:   "Get ebiten.KeyBackspace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackspace)))
			return resObj
		},
	},
	"key-bracket-left": {
		Doc:   "Get ebiten.KeyBracketLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketLeft)))
			return resObj
		},
	},
	"key-bracket-right": {
		Doc:   "Get ebiten.KeyBracketRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketRight)))
			return resObj
		},
	},
	"key-c": {
		Doc:   "Get ebiten.KeyC value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyC)))
			return resObj
		},
	},
	"key-caps-lock": {
		Doc:   "Get ebiten.KeyCapsLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyCapsLock)))
			return resObj
		},
	},
	"key-comma": {
		Doc:   "Get ebiten.KeyComma value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyComma)))
			return resObj
		},
	},
	"key-context-menu": {
		Doc:   "Get ebiten.KeyContextMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyContextMenu)))
			return resObj
		},
	},
	"key-control": {
		Doc:   "Get ebiten.KeyControl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControl)))
			return resObj
		},
	},
	"key-control-left": {
		Doc:   "Get ebiten.KeyControlLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlLeft)))
			return resObj
		},
	},
	"key-control-right": {
		Doc:   "Get ebiten.KeyControlRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlRight)))
			return resObj
		},
	},
	"key-d": {
		Doc:   "Get ebiten.KeyD value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyD)))
			return resObj
		},
	},
	"key-delete": {
		Doc:   "Get ebiten.KeyDelete value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDelete)))
			return resObj
		},
	},
	"key-digit-0": {
		Doc:   "Get ebiten.KeyDigit0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit0)))
			return resObj
		},
	},
	"key-digit-1": {
		Doc:   "Get ebiten.KeyDigit1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit1)))
			return resObj
		},
	},
	"key-digit-2": {
		Doc:   "Get ebiten.KeyDigit2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit2)))
			return resObj
		},
	},
	"key-digit-3": {
		Doc:   "Get ebiten.KeyDigit3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit3)))
			return resObj
		},
	},
	"key-digit-4": {
		Doc:   "Get ebiten.KeyDigit4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit4)))
			return resObj
		},
	},
	"key-digit-5": {
		Doc:   "Get ebiten.KeyDigit5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit5)))
			return resObj
		},
	},
	"key-digit-6": {
		Doc:   "Get ebiten.KeyDigit6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit6)))
			return resObj
		},
	},
	"key-digit-7": {
		Doc:   "Get ebiten.KeyDigit7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit7)))
			return resObj
		},
	},
	"key-digit-8": {
		Doc:   "Get ebiten.KeyDigit8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit8)))
			return resObj
		},
	},
	"key-digit-9": {
		Doc:   "Get ebiten.KeyDigit9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit9)))
			return resObj
		},
	},
	"key-down": {
		Doc:   "Get ebiten.KeyDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDown)))
			return resObj
		},
	},
	"key-e": {
		Doc:   "Get ebiten.KeyE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyE)))
			return resObj
		},
	},
	"key-end": {
		Doc:   "Get ebiten.KeyEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnd)))
			return resObj
		},
	},
	"key-enter": {
		Doc:   "Get ebiten.KeyEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnter)))
			return resObj
		},
	},
	"key-equal": {
		Doc:   "Get ebiten.KeyEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEqual)))
			return resObj
		},
	},
	"key-escape": {
		Doc:   "Get ebiten.KeyEscape value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEscape)))
			return resObj
		},
	},
	"key-f": {
		Doc:   "Get ebiten.KeyF value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF)))
			return resObj
		},
	},
	"key-f-1": {
		Doc:   "Get ebiten.KeyF1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF1)))
			return resObj
		},
	},
	"key-f-10": {
		Doc:   "Get ebiten.KeyF10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF10)))
			return resObj
		},
	},
	"key-f-11": {
		Doc:   "Get ebiten.KeyF11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF11)))
			return resObj
		},
	},
	"key-f-12": {
		Doc:   "Get ebiten.KeyF12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF12)))
			return resObj
		},
	},
	"key-f-13": {
		Doc:   "Get ebiten.KeyF13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF13)))
			return resObj
		},
	},
	"key-f-14": {
		Doc:   "Get ebiten.KeyF14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF14)))
			return resObj
		},
	},
	"key-f-15": {
		Doc:   "Get ebiten.KeyF15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF15)))
			return resObj
		},
	},
	"key-f-16": {
		Doc:   "Get ebiten.KeyF16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF16)))
			return resObj
		},
	},
	"key-f-17": {
		Doc:   "Get ebiten.KeyF17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF17)))
			return resObj
		},
	},
	"key-f-18": {
		Doc:   "Get ebiten.KeyF18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF18)))
			return resObj
		},
	},
	"key-f-19": {
		Doc:   "Get ebiten.KeyF19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF19)))
			return resObj
		},
	},
	"key-f-2": {
		Doc:   "Get ebiten.KeyF2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF2)))
			return resObj
		},
	},
	"key-f-20": {
		Doc:   "Get ebiten.KeyF20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF20)))
			return resObj
		},
	},
	"key-f-21": {
		Doc:   "Get ebiten.KeyF21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF21)))
			return resObj
		},
	},
	"key-f-22": {
		Doc:   "Get ebiten.KeyF22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF22)))
			return resObj
		},
	},
	"key-f-23": {
		Doc:   "Get ebiten.KeyF23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF23)))
			return resObj
		},
	},
	"key-f-24": {
		Doc:   "Get ebiten.KeyF24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF24)))
			return resObj
		},
	},
	"key-f-3": {
		Doc:   "Get ebiten.KeyF3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF3)))
			return resObj
		},
	},
	"key-f-4": {
		Doc:   "Get ebiten.KeyF4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF4)))
			return resObj
		},
	},
	"key-f-5": {
		Doc:   "Get ebiten.KeyF5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF5)))
			return resObj
		},
	},
	"key-f-6": {
		Doc:   "Get ebiten.KeyF6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF6)))
			return resObj
		},
	},
	"key-f-7": {
		Doc:   "Get ebiten.KeyF7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF7)))
			return resObj
		},
	},
	"key-f-8": {
		Doc:   "Get ebiten.KeyF8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF8)))
			return resObj
		},
	},
	"key-f-9": {
		Doc:   "Get ebiten.KeyF9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF9)))
			return resObj
		},
	},
	"key-g": {
		Doc:   "Get ebiten.KeyG value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyG)))
			return resObj
		},
	},
	"key-grave-accent": {
		Doc:   "Get ebiten.KeyGraveAccent value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyGraveAccent)))
			return resObj
		},
	},
	"key-h": {
		Doc:   "Get ebiten.KeyH value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyH)))
			return resObj
		},
	},
	"key-home": {
		Doc:   "Get ebiten.KeyHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyHome)))
			return resObj
		},
	},
	"key-i": {
		Doc:   "Get ebiten.KeyI value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyI)))
			return resObj
		},
	},
	"key-insert": {
		Doc:   "Get ebiten.KeyInsert value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyInsert)))
			return resObj
		},
	},
	"key-intl-backslash": {
		Doc:   "Get ebiten.KeyIntlBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyIntlBackslash)))
			return resObj
		},
	},
	"key-j": {
		Doc:   "Get ebiten.KeyJ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyJ)))
			return resObj
		},
	},
	"key-k": {
		Doc:   "Get ebiten.KeyK value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyK)))
			return resObj
		},
	},
	"key-kp-0": {
		Doc:   "Get ebiten.KeyKP0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP0)))
			return resObj
		},
	},
	"key-kp-1": {
		Doc:   "Get ebiten.KeyKP1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP1)))
			return resObj
		},
	},
	"key-kp-2": {
		Doc:   "Get ebiten.KeyKP2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP2)))
			return resObj
		},
	},
	"key-kp-3": {
		Doc:   "Get ebiten.KeyKP3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP3)))
			return resObj
		},
	},
	"key-kp-4": {
		Doc:   "Get ebiten.KeyKP4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP4)))
			return resObj
		},
	},
	"key-kp-5": {
		Doc:   "Get ebiten.KeyKP5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP5)))
			return resObj
		},
	},
	"key-kp-6": {
		Doc:   "Get ebiten.KeyKP6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP6)))
			return resObj
		},
	},
	"key-kp-7": {
		Doc:   "Get ebiten.KeyKP7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP7)))
			return resObj
		},
	},
	"key-kp-8": {
		Doc:   "Get ebiten.KeyKP8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP8)))
			return resObj
		},
	},
	"key-kp-9": {
		Doc:   "Get ebiten.KeyKP9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP9)))
			return resObj
		},
	},
	"key-kp-add": {
		Doc:   "Get ebiten.KeyKPAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPAdd)))
			return resObj
		},
	},
	"key-kp-decimal": {
		Doc:   "Get ebiten.KeyKPDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDecimal)))
			return resObj
		},
	},
	"key-kp-divide": {
		Doc:   "Get ebiten.KeyKPDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDivide)))
			return resObj
		},
	},
	"key-kp-enter": {
		Doc:   "Get ebiten.KeyKPEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEnter)))
			return resObj
		},
	},
	"key-kp-equal": {
		Doc:   "Get ebiten.KeyKPEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEqual)))
			return resObj
		},
	},
	"key-kp-multiply": {
		Doc:   "Get ebiten.KeyKPMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPMultiply)))
			return resObj
		},
	},
	"key-kp-subtract": {
		Doc:   "Get ebiten.KeyKPSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPSubtract)))
			return resObj
		},
	},
	"key-l": {
		Doc:   "Get ebiten.KeyL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyL)))
			return resObj
		},
	},
	"key-left": {
		Doc:   "Get ebiten.KeyLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeft)))
			return resObj
		},
	},
	"key-left-bracket": {
		Doc:   "Get ebiten.KeyLeftBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeftBracket)))
			return resObj
		},
	},
	"key-m": {
		Doc:   "Get ebiten.KeyM value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyM)))
			return resObj
		},
	},
	"key-max": {
		Doc:   "Get ebiten.KeyMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMax)))
			return resObj
		},
	},
	"key-menu": {
		Doc:   "Get ebiten.KeyMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMenu)))
			return resObj
		},
	},
	"key-meta": {
		Doc:   "Get ebiten.KeyMeta value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMeta)))
			return resObj
		},
	},
	"key-meta-left": {
		Doc:   "Get ebiten.KeyMetaLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaLeft)))
			return resObj
		},
	},
	"key-meta-right": {
		Doc:   "Get ebiten.KeyMetaRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaRight)))
			return resObj
		},
	},
	"key-minus": {
		Doc:   "Get ebiten.KeyMinus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMinus)))
			return resObj
		},
	},
	"key-n": {
		Doc:   "Get ebiten.KeyN value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyN)))
			return resObj
		},
	},
	"key-name": {
		Doc:   "ebiten.KeyName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("key-name: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.KeyName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"key-num-lock": {
		Doc:   "Get ebiten.KeyNumLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumLock)))
			return resObj
		},
	},
	"key-numpad-0": {
		Doc:   "Get ebiten.KeyNumpad0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad0)))
			return resObj
		},
	},
	"key-numpad-1": {
		Doc:   "Get ebiten.KeyNumpad1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad1)))
			return resObj
		},
	},
	"key-numpad-2": {
		Doc:   "Get ebiten.KeyNumpad2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad2)))
			return resObj
		},
	},
	"key-numpad-3": {
		Doc:   "Get ebiten.KeyNumpad3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad3)))
			return resObj
		},
	},
	"key-numpad-4": {
		Doc:   "Get ebiten.KeyNumpad4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad4)))
			return resObj
		},
	},
	"key-numpad-5": {
		Doc:   "Get ebiten.KeyNumpad5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad5)))
			return resObj
		},
	},
	"key-numpad-6": {
		Doc:   "Get ebiten.KeyNumpad6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad6)))
			return resObj
		},
	},
	"key-numpad-7": {
		Doc:   "Get ebiten.KeyNumpad7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad7)))
			return resObj
		},
	},
	"key-numpad-8": {
		Doc:   "Get ebiten.KeyNumpad8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad8)))
			return resObj
		},
	},
	"key-numpad-9": {
		Doc:   "Get ebiten.KeyNumpad9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad9)))
			return resObj
		},
	},
	"key-numpad-add": {
		Doc:   "Get ebiten.KeyNumpadAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadAdd)))
			return resObj
		},
	},
	"key-numpad-decimal": {
		Doc:   "Get ebiten.KeyNumpadDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDecimal)))
			return resObj
		},
	},
	"key-numpad-divide": {
		Doc:   "Get ebiten.KeyNumpadDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDivide)))
			return resObj
		},
	},
	"key-numpad-enter": {
		Doc:   "Get ebiten.KeyNumpadEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEnter)))
			return resObj
		},
	},
	"key-numpad-equal": {
		Doc:   "Get ebiten.KeyNumpadEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEqual)))
			return resObj
		},
	},
	"key-numpad-multiply": {
		Doc:   "Get ebiten.KeyNumpadMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadMultiply)))
			return resObj
		},
	},
	"key-numpad-subtract": {
		Doc:   "Get ebiten.KeyNumpadSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadSubtract)))
			return resObj
		},
	},
	"key-o": {
		Doc:   "Get ebiten.KeyO value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyO)))
			return resObj
		},
	},
	"key-p": {
		Doc:   "Get ebiten.KeyP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyP)))
			return resObj
		},
	},
	"key-page-down": {
		Doc:   "Get ebiten.KeyPageDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageDown)))
			return resObj
		},
	},
	"key-page-up": {
		Doc:   "Get ebiten.KeyPageUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageUp)))
			return resObj
		},
	},
	"key-pause": {
		Doc:   "Get ebiten.KeyPause value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPause)))
			return resObj
		},
	},
	"key-period": {
		Doc:   "Get ebiten.KeyPeriod value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPeriod)))
			return resObj
		},
	},
	"key-print-screen": {
		Doc:   "Get ebiten.KeyPrintScreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPrintScreen)))
			return resObj
		},
	},
	"key-q": {
		Doc:   "Get ebiten.KeyQ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQ)))
			return resObj
		},
	},
	"key-quote": {
		Doc:   "Get ebiten.KeyQuote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQuote)))
			return resObj
		},
	},
	"key-r": {
		Doc:   "Get ebiten.KeyR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyR)))
			return resObj
		},
	},
	"key-right": {
		Doc:   "Get ebiten.KeyRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRight)))
			return resObj
		},
	},
	"key-right-bracket": {
		Doc:   "Get ebiten.KeyRightBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRightBracket)))
			return resObj
		},
	},
	"key-s": {
		Doc:   "Get ebiten.KeyS value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyS)))
			return resObj
		},
	},
	"key-scroll-lock": {
		Doc:   "Get ebiten.KeyScrollLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyScrollLock)))
			return resObj
		},
	},
	"key-semicolon": {
		Doc:   "Get ebiten.KeySemicolon value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySemicolon)))
			return resObj
		},
	},
	"key-shift": {
		Doc:   "Get ebiten.KeyShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShift)))
			return resObj
		},
	},
	"key-shift-left": {
		Doc:   "Get ebiten.KeyShiftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftLeft)))
			return resObj
		},
	},
	"key-shift-right": {
		Doc:   "Get ebiten.KeyShiftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftRight)))
			return resObj
		},
	},
	"key-slash": {
		Doc:   "Get ebiten.KeySlash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySlash)))
			return resObj
		},
	},
	"key-space": {
		Doc:   "Get ebiten.KeySpace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySpace)))
			return resObj
		},
	},
	"key-t": {
		Doc:   "Get ebiten.KeyT value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyT)))
			return resObj
		},
	},
	"key-tab": {
		Doc:   "Get ebiten.KeyTab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyTab)))
			return resObj
		},
	},
	"key-u": {
		Doc:   "Get ebiten.KeyU value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyU)))
			return resObj
		},
	},
	"key-up": {
		Doc:   "Get ebiten.KeyUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyUp)))
			return resObj
		},
	},
	"key-v": {
		Doc:   "Get ebiten.KeyV value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyV)))
			return resObj
		},
	},
	"key-w": {
		Doc:   "Get ebiten.KeyW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyW)))
			return resObj
		},
	},
	"key-x": {
		Doc:   "Get ebiten.KeyX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyX)))
			return resObj
		},
	},
	"key-y": {
		Doc:   "Get ebiten.KeyY value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyY)))
			return resObj
		},
	},
	"key-z": {
		Doc:   "Get ebiten.KeyZ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyZ)))
			return resObj
		},
	},
	"ebiten-key//marshal-text": {
		Doc:   "ebiten.Key.MarshalText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-key//marshal-text: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, resErr := arg0Val.MarshalText()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ebiten-key//string": {
		Doc:   "ebiten.Key.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-key//string: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ebiten-layout-fer//layout-f": {
		Doc:   "ebiten.LayoutFer.LayoutF",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.LayoutFer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_LayoutFer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ebiten-layout-fer//layout-f: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.LayoutFer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected native of type ebiten.LayoutFer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-layout-fer//layout-f: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-layout-fer//layout-f: arg 3: expected decimal")
			}
			res0, res1 := arg0Val.LayoutF(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"max-tps": {
		Doc:   "ebiten.MaxTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.MaxTPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"maximize-window": {
		Doc:   "ebiten.MaximizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.MaximizeWindow()
			return nil
		},
	},
	"minimize-window": {
		Doc:   "ebiten.MinimizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.MinimizeWindow()
			return nil
		},
	},
	"monitor": {
		Doc:   "ebiten.Monitor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.Monitor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-monitor-type")
			return res0Obj
		},
	},
	"mouse-button-0": {
		Doc:   "Get ebiten.MouseButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton0)))
			return resObj
		},
	},
	"mouse-button-1": {
		Doc:   "Get ebiten.MouseButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton1)))
			return resObj
		},
	},
	"mouse-button-2": {
		Doc:   "Get ebiten.MouseButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton2)))
			return resObj
		},
	},
	"mouse-button-3": {
		Doc:   "Get ebiten.MouseButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton3)))
			return resObj
		},
	},
	"mouse-button-4": {
		Doc:   "Get ebiten.MouseButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton4)))
			return resObj
		},
	},
	"mouse-button-left": {
		Doc:   "Get ebiten.MouseButtonLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonLeft)))
			return resObj
		},
	},
	"mouse-button-max": {
		Doc:   "Get ebiten.MouseButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonMax)))
			return resObj
		},
	},
	"mouse-button-middle": {
		Doc:   "Get ebiten.MouseButtonMiddle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonMiddle)))
			return resObj
		},
	},
	"mouse-button-right": {
		Doc:   "Get ebiten.MouseButtonRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonRight)))
			return resObj
		},
	},
	"blend": {
		Doc:   "Create a new ebiten.Blend struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.Blend{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-blend")
			return resObj
		},
	},
	"color-scale": {
		Doc:   "Create a new ebiten.ColorScale struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.ColorScale{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-color-scale")
			return resObj
		},
	},
	"debug-info": {
		Doc:   "Create a new ebiten.DebugInfo struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.DebugInfo{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-debug-info")
			return resObj
		},
	},
	"draw-image-options": {
		Doc:   "Create a new ebiten.DrawImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.DrawImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-draw-image-options")
			return resObj
		},
	},
	"draw-triangles-options": {
		Doc:   "Create a new ebiten.DrawTrianglesOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.DrawTrianglesOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-draw-triangles-options")
			return resObj
		},
	},
	"geo-m": {
		Doc:   "Create a new ebiten.GeoM struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.GeoM{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-geo-m")
			return resObj
		},
	},
	"image": {
		Doc:   "ebiten.NewImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image: arg 2: expected integer")
			}
			res0 := ebiten.NewImage(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			return res0Obj
		},
	},
	"image-from-image": {
		Doc:   "ebiten.NewImageFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-image: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-image: arg 1: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-image: arg 1: expected native")
			}
			res0 := ebiten.NewImageFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			return res0Obj
		},
	},
	"image-from-image-with-options": {
		Doc:   "ebiten.NewImageFromImageWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 1: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-image-with-options: arg 1: expected native")
			}
			var arg1Val *ebiten.NewImageFromImageOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.NewImageFromImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 2: expected native of type *ebiten.NewImageFromImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-image-with-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-image-with-options: arg 2: expected native")
			}
			res0 := ebiten.NewImageFromImageWithOptions(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			return res0Obj
		},
	},
	"image-with-options": {
		Doc:   "ebiten.NewImageWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-with-options: arg 1: expected native")
			}
			var arg1Val *ebiten.NewImageOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.NewImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 2: expected native of type *ebiten.NewImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-with-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-with-options: arg 2: expected native")
			}
			res0 := ebiten.NewImageWithOptions(*arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			return res0Obj
		},
	},
	"new-image-from-image-options": {
		Doc:   "Create a new ebiten.NewImageFromImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.NewImageFromImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-new-image-from-image-options")
			return resObj
		},
	},
	"new-image-options": {
		Doc:   "Create a new ebiten.NewImageOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.NewImageOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-new-image-options")
			return resObj
		},
	},
	"run-game-options": {
		Doc:   "Create a new ebiten.RunGameOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.RunGameOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-run-game-options")
			return resObj
		},
	},
	"shader": {
		Doc:   "ebiten.NewShader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("shader: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("shader: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("shader: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("shader: arg 1: expected block, native or nil")
			}
			res0, resErr := ebiten.NewShader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-shader")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vertex": {
		Doc:   "Create a new ebiten.Vertex struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.Vertex{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-vertex")
			return resObj
		},
	},
	"vibrate-gamepad-options": {
		Doc:   "Create a new ebiten.VibrateGamepadOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.VibrateGamepadOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-vibrate-gamepad-options")
			return resObj
		},
	},
	"vibrate-options": {
		Doc:   "Create a new ebiten.VibrateOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten.VibrateOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-vibrate-options")
			return resObj
		},
	},
	"non-zero": {
		Doc:   "Get ebiten.NonZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.NonZero)))
			return resObj
		},
	},
	"read-debug-info": {
		Doc:   "ebiten.ReadDebugInfo",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("read-debug-info: arg 1: expected native of type *ebiten.DebugInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("read-debug-info: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("read-debug-info: arg 1: expected native")
			}
			ebiten.ReadDebugInfo(arg0Val)
			return nil
		},
	},
	"restore-window": {
		Doc:   "ebiten.RestoreWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.RestoreWindow()
			return nil
		},
	},
	"run-game": {
		Doc:   "ebiten.RunGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game: arg 1: expected native")
			}
			resErr := ebiten.RunGame(arg0Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"run-game-with-options": {
		Doc:   "ebiten.RunGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-with-options: arg 1: expected native")
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 2: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-with-options: arg 2: expected native")
			}
			resErr := ebiten.RunGameWithOptions(arg0Val, arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"schedule-frame": {
		Doc:   "ebiten.ScheduleFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.ScheduleFrame()
			return nil
		},
	},
	"screen-size-in-fullscreen": {
		Doc:   "ebiten.ScreenSizeInFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.ScreenSizeInFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"set-cursor-mode": {
		Doc:   "ebiten.SetCursorMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.CursorModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CursorModeType)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-cursor-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.CursorModeType(u)
				}
			}
			ebiten.SetCursorMode(arg0Val)
			return nil
		},
	},
	"set-cursor-shape": {
		Doc:   "ebiten.SetCursorShape",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorShapeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.CursorShapeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CursorShapeType)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-cursor-shape: arg 1: expected integer")
					}
					arg0Val = ebiten.CursorShapeType(u)
				}
			}
			ebiten.SetCursorShape(arg0Val)
			return nil
		},
	},
	"set-fps-mode": {
		Doc:   "ebiten.SetFPSMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FPSModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.FPSModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FPSModeType)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-fps-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.FPSModeType(u)
				}
			}
			ebiten.SetFPSMode(arg0Val)
			return nil
		},
	},
	"set-fullscreen": {
		Doc:   "ebiten.SetFullscreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-fullscreen: arg 1: expected integer")
			}
			ebiten.SetFullscreen(arg0Val)
			return nil
		},
	},
	"set-init-focused": {
		Doc:   "ebiten.SetInitFocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-init-focused: arg 1: expected integer")
			}
			ebiten.SetInitFocused(arg0Val)
			return nil
		},
	},
	"set-max-tps": {
		Doc:   "ebiten.SetMaxTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-max-tps: arg 1: expected integer")
			}
			ebiten.SetMaxTPS(arg0Val)
			return nil
		},
	},
	"set-monitor": {
		Doc:   "ebiten.SetMonitor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("set-monitor: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-monitor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-monitor: arg 1: expected native")
			}
			ebiten.SetMonitor(arg0Val)
			return nil
		},
	},
	"set-runnable-on-unfocused": {
		Doc:   "ebiten.SetRunnableOnUnfocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-runnable-on-unfocused: arg 1: expected integer")
			}
			ebiten.SetRunnableOnUnfocused(arg0Val)
			return nil
		},
	},
	"set-screen-cleared-every-frame": {
		Doc:   "ebiten.SetScreenClearedEveryFrame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-cleared-every-frame: arg 1: expected integer")
			}
			ebiten.SetScreenClearedEveryFrame(arg0Val)
			return nil
		},
	},
	"set-screen-filter-enabled": {
		Doc:   "ebiten.SetScreenFilterEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-filter-enabled: arg 1: expected integer")
			}
			ebiten.SetScreenFilterEnabled(arg0Val)
			return nil
		},
	},
	"set-screen-transparent": {
		Doc:   "ebiten.SetScreenTransparent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-transparent: arg 1: expected integer")
			}
			ebiten.SetScreenTransparent(arg0Val)
			return nil
		},
	},
	"set-tps": {
		Doc:   "ebiten.SetTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-tps: arg 1: expected integer")
			}
			ebiten.SetTPS(arg0Val)
			return nil
		},
	},
	"set-vsync-enabled": {
		Doc:   "ebiten.SetVsyncEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-vsync-enabled: arg 1: expected integer")
			}
			ebiten.SetVsyncEnabled(arg0Val)
			return nil
		},
	},
	"set-window-closing-handled": {
		Doc:   "ebiten.SetWindowClosingHandled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-closing-handled: arg 1: expected integer")
			}
			ebiten.SetWindowClosingHandled(arg0Val)
			return nil
		},
	},
	"set-window-decorated": {
		Doc:   "ebiten.SetWindowDecorated",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-decorated: arg 1: expected integer")
			}
			ebiten.SetWindowDecorated(arg0Val)
			return nil
		},
	},
	"set-window-floating": {
		Doc:   "ebiten.SetWindowFloating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-floating: arg 1: expected integer")
			}
			ebiten.SetWindowFloating(arg0Val)
			return nil
		},
	},
	"set-window-icon": {
		Doc:   "ebiten.SetWindowIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []image.Image
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]image.Image, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.RyeCtx:
						var err error
						arg0Val[i], err = ctxTo_image_Image(ps, v)
						if err != nil {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: block item: " + err.Error() + "")
						}
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(image.Image)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: block item: expected native of type image.Image")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("set-window-icon: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("set-window-icon: arg 1: expected native of type []image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-window-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-window-icon: arg 1: expected block, native or nil")
			}
			ebiten.SetWindowIcon(arg0Val)
			return nil
		},
	},
	"set-window-mouse-passthrough": {
		Doc:   "ebiten.SetWindowMousePassthrough",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-mouse-passthrough: arg 1: expected integer")
			}
			ebiten.SetWindowMousePassthrough(arg0Val)
			return nil
		},
	},
	"set-window-position": {
		Doc:   "ebiten.SetWindowPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-position: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-position: arg 2: expected integer")
			}
			ebiten.SetWindowPosition(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-resizable": {
		Doc:   "ebiten.SetWindowResizable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-resizable: arg 1: expected integer")
			}
			ebiten.SetWindowResizable(arg0Val)
			return nil
		},
	},
	"set-window-resizing-mode": {
		Doc:   "ebiten.SetWindowResizingMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.WindowResizingModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.WindowResizingModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.WindowResizingModeType)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-window-resizing-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.WindowResizingModeType(u)
				}
			}
			ebiten.SetWindowResizingMode(arg0Val)
			return nil
		},
	},
	"set-window-size": {
		Doc:   "ebiten.SetWindowSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size: arg 2: expected integer")
			}
			ebiten.SetWindowSize(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-size-limits": {
		Doc:   "ebiten.SetWindowSizeLimits",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 4: expected integer")
			}
			ebiten.SetWindowSizeLimits(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"set-window-title": {
		Doc:   "ebiten.SetWindowTitle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-title: arg 1: expected string")
			}
			ebiten.SetWindowTitle(arg0Val)
			return nil
		},
	},
	"standard-gamepad-axis-left-stick-horizontal": {
		Doc:   "Get ebiten.StandardGamepadAxisLeftStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisLeftStickHorizontal)))
			return resObj
		},
	},
	"standard-gamepad-axis-left-stick-vertical": {
		Doc:   "Get ebiten.StandardGamepadAxisLeftStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisLeftStickVertical)))
			return resObj
		},
	},
	"standard-gamepad-axis-max": {
		Doc:   "Get ebiten.StandardGamepadAxisMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisMax)))
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-horizontal": {
		Doc:   "Get ebiten.StandardGamepadAxisRightStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisRightStickHorizontal)))
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-vertical": {
		Doc:   "Get ebiten.StandardGamepadAxisRightStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisRightStickVertical)))
			return resObj
		},
	},
	"standard-gamepad-axis-value": {
		Doc:   "ebiten.StandardGamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-axis-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadAxis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadAxis
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadAxis)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-axis-value: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadAxis(u)
				}
			}
			res0 := ebiten.StandardGamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"standard-gamepad-button-center-center": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterCenter)))
			return resObj
		},
	},
	"standard-gamepad-button-center-left": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-center-right": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterRight)))
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-left": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontBottomLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontBottomLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-right": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontBottomRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontBottomRight)))
			return resObj
		},
	},
	"standard-gamepad-button-front-top-left": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontTopLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontTopLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-front-top-right": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontTopRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontTopRight)))
			return resObj
		},
	},
	"standard-gamepad-button-left-bottom": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftBottom)))
			return resObj
		},
	},
	"standard-gamepad-button-left-left": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-left-right": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftRight)))
			return resObj
		},
	},
	"standard-gamepad-button-left-stick": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftStick)))
			return resObj
		},
	},
	"standard-gamepad-button-left-top": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftTop)))
			return resObj
		},
	},
	"standard-gamepad-button-max": {
		Doc:   "Get ebiten.StandardGamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonMax)))
			return resObj
		},
	},
	"standard-gamepad-button-right-bottom": {
		Doc:   "Get ebiten.StandardGamepadButtonRightBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightBottom)))
			return resObj
		},
	},
	"standard-gamepad-button-right-left": {
		Doc:   "Get ebiten.StandardGamepadButtonRightLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-right-right": {
		Doc:   "Get ebiten.StandardGamepadButtonRightRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightRight)))
			return resObj
		},
	},
	"standard-gamepad-button-right-stick": {
		Doc:   "Get ebiten.StandardGamepadButtonRightStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightStick)))
			return resObj
		},
	},
	"standard-gamepad-button-right-top": {
		Doc:   "Get ebiten.StandardGamepadButtonRightTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightTop)))
			return resObj
		},
	},
	"standard-gamepad-button-value": {
		Doc:   "ebiten.StandardGamepadButtonValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-button-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-button-value: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.StandardGamepadButtonValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ebiten-text-append-glyphs": {
		Doc:   "ebiten_text.AppendGlyphs",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten_text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(ebiten_text.Glyph)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-text-append-glyphs: arg 1: block item: expected native of type ebiten_text.Glyph")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-text-append-glyphs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-append-glyphs: arg 1: expected native of type []ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-append-glyphs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-append-glyphs: arg 1: expected block, native or nil")
			}
			var arg1Val font.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-append-glyphs: arg 2: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-append-glyphs: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-append-glyphs: arg 3: expected string")
			}
			res0 := ebiten_text.AppendGlyphs(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-text-glyph")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ebiten-text-bound-string": {
		Doc:   "ebiten_text.BoundString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-bound-string: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-bound-string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-bound-string: arg 2: expected string")
			}
			res0 := ebiten_text.BoundString(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ebiten-text-cache-glyphs": {
		Doc:   "ebiten_text.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-cache-glyphs: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-cache-glyphs: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-cache-glyphs: arg 2: expected string")
			}
			ebiten_text.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"ebiten-text-draw-with-options": {
		Doc:   "ebiten_text.DrawWithOptions",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 2: expected string")
			}
			var arg2Val font.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 3: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 3: expected native")
			}
			var arg3Val *ebiten.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 4: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-draw-with-options: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-draw-with-options: arg 4: expected native")
			}
			ebiten_text.DrawWithOptions(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"ebiten-text-face-with-line-height": {
		Doc:   "ebiten_text.FaceWithLineHeight",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-text-face-with-line-height: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-text-face-with-line-height: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-text-face-with-line-height: arg 2: expected decimal")
			}
			res0 := ebiten_text.FaceWithLineHeight(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "font-face")
			return res0Obj
		},
	},
	"ebiten-text-glyph": {
		Doc:   "Create a new ebiten_text.Glyph struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &ebiten_text.Glyph{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-ebiten-text-glyph")
			return resObj
		},
	},
	"touch-i-ds": {
		Doc:   "ebiten.TouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.TouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"touch-position": {
		Doc:   "ebiten.TouchPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("touch-position: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0, res1 := ebiten.TouchPosition(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"tps": {
		Doc:   "ebiten.TPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.TPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"update-standard-gamepad-layout-mappings": {
		Doc:   "ebiten.UpdateStandardGamepadLayoutMappings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("update-standard-gamepad-layout-mappings: arg 1: expected string")
			}
			res0, resErr := ebiten.UpdateStandardGamepadLayoutMappings(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vibrate": {
		Doc:   "ebiten.Vibrate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vibrate: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vibrate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate: arg 1: expected native")
			}
			ebiten.Vibrate(arg0Val)
			return nil
		},
	},
	"vibrate-gamepad": {
		Doc:   "ebiten.VibrateGamepad",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("vibrate-gamepad: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val *ebiten.VibrateGamepadOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 2: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate-gamepad: arg 2: expected native")
			}
			ebiten.VibrateGamepad(arg0Val, arg1Val)
			return nil
		},
	},
	"wheel": {
		Doc:   "ebiten.Wheel",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.Wheel()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"window-position": {
		Doc:   "ebiten.WindowPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"window-resizing-mode": {
		Doc:   "ebiten.WindowResizingMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.WindowResizingMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"window-resizing-mode-disabled": {
		Doc:   "Get ebiten.WindowResizingModeDisabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeDisabled)))
			return resObj
		},
	},
	"window-resizing-mode-enabled": {
		Doc:   "Get ebiten.WindowResizingModeEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeEnabled)))
			return resObj
		},
	},
	"window-resizing-mode-only-fullscreen-enabled": {
		Doc:   "Get ebiten.WindowResizingModeOnlyFullscreenEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeOnlyFullscreenEnabled)))
			return resObj
		},
	},
	"window-size": {
		Doc:   "ebiten.WindowSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"window-size-limits": {
		Doc:   "ebiten.WindowSizeLimits",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1, res2, res3 := ebiten.WindowSizeLimits()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"debug-print": {
		Doc:   "ebitenutil.DebugPrint",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("debug-print: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("debug-print: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("debug-print: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print: arg 2: expected string")
			}
			ebitenutil.DebugPrint(arg0Val, arg1Val)
			return nil
		},
	},
	"debug-print-at": {
		Doc:   "ebitenutil.DebugPrintAt",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("debug-print-at: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("debug-print-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 4: expected integer")
			}
			ebitenutil.DebugPrintAt(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"draw-circle": {
		Doc:   "ebitenutil.DrawCircle",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 4: expected decimal")
			}
			var arg4Val color.Color
			switch v := arg4.(type) {
			case env.RyeCtx:
				var err error
				arg4Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 5: expected native")
			}
			ebitenutil.DrawCircle(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val)
			return nil
		},
	},
	"image-from-file": {
		Doc:   "ebitenutil.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-file: arg 1: expected string")
			}
			res0, res1, resErr := ebitenutil.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			{
				typ := reflect.TypeOf(res1)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res1Obj = *env.NewNative(ps.Idx, res1, typRyeName)
				} else {
					res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-from-file-system": {
		Doc:   "ebitenutil.NewImageFromFileSystem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val fs.FS
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_fs_FS(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fs.FS)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: expected native of type fs.FS")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-file-system: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-file-system: arg 2: expected string")
			}
			res0, res1, resErr := ebitenutil.NewImageFromFileSystem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			{
				typ := reflect.TypeOf(res1)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res1Obj = *env.NewNative(ps.Idx, res1, typRyeName)
				} else {
					res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-from-reader": {
		Doc:   "ebitenutil.NewImageFromReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-reader: arg 1: expected native")
			}
			res0, res1, resErr := ebitenutil.NewImageFromReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			{
				typ := reflect.TypeOf(res1)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res1Obj = *env.NewNative(ps.Idx, res1, typRyeName)
				} else {
					res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-from-url": {
		Doc:   "ebitenutil.NewImageFromURL",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-url: arg 1: expected string")
			}
			res0, resErr := ebitenutil.NewImageFromURL(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"open-file": {
		Doc:   "ebitenutil.OpenFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("open-file: arg 1: expected string")
			}
			res0, resErr := ebitenutil.OpenFile(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "ebitenutil-read-seek-closer")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"flappy-gopher-png": {
		Doc:   "Get flappy.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Gopher_png))
				for i, it := range flappy.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"flappy-tiles-png": {
		Doc:   "Get flappy.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Tiles_png))
				for i, it := range flappy.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-m-plus-1-p-regular-ttf": {
		Doc:   "Get fonts.MPlus1pRegular_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.MPlus1pRegular_ttf))
				for i, it := range fonts.MPlus1pRegular_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-press-start-2-p-ttf": {
		Doc:   "Get fonts.PressStart2P_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.PressStart2P_ttf))
				for i, it := range fonts.PressStart2P_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"gif-decode": {
		Doc:   "gif.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-decode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-decode: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-decode: arg 1: expected native")
			}
			res0, resErr := gif.Decode(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gif-decode-all": {
		Doc:   "gif.DecodeAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-decode-all: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-decode-all: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-decode-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-decode-all: arg 1: expected native")
			}
			res0, resErr := gif.DecodeAll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-gif-gif")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gif-decode-config": {
		Doc:   "gif.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-decode-config: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-decode-config: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-decode-config: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-decode-config: arg 1: expected native")
			}
			res0, resErr := gif.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-config")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gif-encode": {
		Doc:   "gif.Encode",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 1: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode: arg 1: expected native")
			}
			var arg1Val image.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 2: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode: arg 2: expected native")
			}
			var arg2Val *gif.Options
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 3: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode: arg 3: expected native")
			}
			resErr := gif.Encode(arg0Val, arg1Val, arg2Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"gif-encode-all": {
		Doc:   "gif.EncodeAll",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 1: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode-all: arg 1: expected native")
			}
			var arg1Val *gif.GIF
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 2: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("gif-encode-all: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("gif-encode-all: arg 2: expected native")
			}
			resErr := gif.EncodeAll(arg0Val, arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"gif-gif": {
		Doc:   "Create a new gif.GIF struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gif.GIF{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-gif-gif")
			return resObj
		},
	},
	"gif-options": {
		Doc:   "Create a new gif.Options struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gif.Options{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-gif-options")
			return resObj
		},
	},
	"image-decode": {
		Doc:   "image.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-decode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-decode: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-decode: arg 1: expected native")
			}
			res0, res1, resErr := image.Decode(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewString(res1)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-decode-config": {
		Doc:   "image.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-decode-config: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-decode-config: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-decode-config: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-decode-config: arg 1: expected native")
			}
			res0, res1, resErr := image.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-config")
			var res1Obj env.Object
			res1Obj = *env.NewString(res1)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"image-image//at": {
		Doc:   "image.Image.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-image//at: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-image//at: arg 1: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-image//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-image//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-image//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-image//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"image-image//bounds": {
		Doc:   "image.Image.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-image//bounds: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-image//bounds: arg 1: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-image//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-image//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-image//color-model": {
		Doc:   "image.Image.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-image//color-model: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-image//color-model: arg 1: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-image//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-image//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"image-alpha": {
		Doc:   "image.NewAlpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-alpha: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-alpha: arg 1: expected native")
			}
			res0 := image.NewAlpha(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-alpha")
			return res0Obj
		},
	},
	"image-alpha-16": {
		Doc:   "image.NewAlpha16",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-alpha-16: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-alpha-16: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-alpha-16: arg 1: expected native")
			}
			res0 := image.NewAlpha16(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-alpha-16")
			return res0Obj
		},
	},
	"image-cmyk": {
		Doc:   "image.NewCMYK",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-cmyk: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-cmyk: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-cmyk: arg 1: expected native")
			}
			res0 := image.NewCMYK(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-cmyk")
			return res0Obj
		},
	},
	"image-config": {
		Doc:   "Create a new image.Config struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &image.Config{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-image-config")
			return resObj
		},
	},
	"image-gray": {
		Doc:   "image.NewGray",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-gray: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-gray: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-gray: arg 1: expected native")
			}
			res0 := image.NewGray(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-gray")
			return res0Obj
		},
	},
	"image-gray-16": {
		Doc:   "image.NewGray16",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-gray-16: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-gray-16: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-gray-16: arg 1: expected native")
			}
			res0 := image.NewGray16(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-gray-16")
			return res0Obj
		},
	},
	"image-nrgba": {
		Doc:   "image.NewNRGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-nrgba: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-nrgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-nrgba: arg 1: expected native")
			}
			res0 := image.NewNRGBA(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-nrgba")
			return res0Obj
		},
	},
	"image-nrgba-64": {
		Doc:   "image.NewNRGBA64",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-nrgba-64: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-nrgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-nrgba-64: arg 1: expected native")
			}
			res0 := image.NewNRGBA64(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-nrgba-64")
			return res0Obj
		},
	},
	"image-ny-cb-cr-a": {
		Doc:   "image.NewNYCbCrA",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-ny-cb-cr-a: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-ny-cb-cr-a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-ny-cb-cr-a: arg 1: expected native")
			}
			var arg1Val image.YCbCrSubsampleRatio
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("image-ny-cb-cr-a: arg 2: expected integer")
					}
					arg1Val = image.YCbCrSubsampleRatio(u)
				}
			}
			res0 := image.NewNYCbCrA(*arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-ny-cb-cr-a")
			return res0Obj
		},
	},
	"image-paletted": {
		Doc:   "image.NewPaletted",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-paletted: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-paletted: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-paletted: arg 1: expected native")
			}
			var arg1Val color.Palette
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u []color.Color
					switch v := arg1.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("image-paletted: arg 2: block item: " + err.Error() + "")
								}
							case env.Native:
								var ok bool
								u[i], ok = v.Value.(color.Color)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("image-paletted: arg 2: block item: expected native of type color.Color")
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("image-paletted: arg 2: block item: expected integer to be 0 or nil")
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("image-paletted: arg 2: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						u, ok = v.Value.([]color.Color)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("image-paletted: arg 2: expected native of type []color.Color")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("image-paletted: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("image-paletted: arg 2: expected block, native or nil")
					}
					arg1Val = color.Palette(u)
				}
			}
			res0 := image.NewPaletted(*arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-paletted")
			return res0Obj
		},
	},
	"image-point": {
		Doc:   "Create a new image.Point struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &image.Point{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-image-point")
			return resObj
		},
	},
	"image-rectangle": {
		Doc:   "Create a new image.Rectangle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &image.Rectangle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-image-rectangle")
			return resObj
		},
	},
	"image-rgba": {
		Doc:   "image.NewRGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rgba: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rgba: arg 1: expected native")
			}
			res0 := image.NewRGBA(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-rgba")
			return res0Obj
		},
	},
	"image-rgba-64": {
		Doc:   "image.NewRGBA64",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rgba-64: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rgba-64: arg 1: expected native")
			}
			res0 := image.NewRGBA64(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-rgba-64")
			return res0Obj
		},
	},
	"image-uniform": {
		Doc:   "image.NewUniform",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-uniform: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-uniform: arg 1: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-uniform: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-uniform: arg 1: expected native")
			}
			res0 := image.NewUniform(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-uniform")
			return res0Obj
		},
	},
	"image-y-cb-cr": {
		Doc:   "image.NewYCbCr",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-y-cb-cr: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-y-cb-cr: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-y-cb-cr: arg 1: expected native")
			}
			var arg1Val image.YCbCrSubsampleRatio
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("image-y-cb-cr: arg 2: expected integer")
					}
					arg1Val = image.YCbCrSubsampleRatio(u)
				}
			}
			res0 := image.NewYCbCr(*arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image-y-cb-cr")
			return res0Obj
		},
	},
	"image-paletted-image//color-index-at": {
		Doc:   "image.PalettedImage.ColorIndexAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.PalettedImage
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_PalettedImage(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-paletted-image//color-index-at: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.PalettedImage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-paletted-image//color-index-at: arg 1: expected native of type image.PalettedImage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-paletted-image//color-index-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-paletted-image//color-index-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-paletted-image//color-index-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-paletted-image//color-index-at: arg 3: expected integer")
			}
			res0 := arg0Val.ColorIndexAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"image-point//add": {
		Doc:   "image.Point.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//add: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//add: arg 1: expected native")
			}
			var arg1Val *image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//add: arg 2: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//add: arg 2: expected native")
			}
			res0 := (*arg0Val).Add(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-point//div": {
		Doc:   "image.Point.Div",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//div: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//div: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//div: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-point//div: arg 2: expected integer")
			}
			res0 := (*arg0Val).Div(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-point//eq": {
		Doc:   "image.Point.Eq",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//eq: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//eq: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//eq: arg 1: expected native")
			}
			var arg1Val *image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//eq: arg 2: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//eq: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//eq: arg 2: expected native")
			}
			res0 := (*arg0Val).Eq(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"image-point//in": {
		Doc:   "image.Point.In",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//in: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//in: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//in: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//in: arg 2: expected native")
			}
			res0 := (*arg0Val).In(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"image-point//mod": {
		Doc:   "image.Point.Mod",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//mod: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//mod: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//mod: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//mod: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//mod: arg 2: expected native")
			}
			res0 := (*arg0Val).Mod(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-point//mul": {
		Doc:   "image.Point.Mul",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//mul: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//mul: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//mul: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-point//mul: arg 2: expected integer")
			}
			res0 := (*arg0Val).Mul(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-point//string": {
		Doc:   "image.Point.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//string: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//string: arg 1: expected native")
			}
			res0 := (*arg0Val).String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"image-point//sub": {
		Doc:   "image.Point.Sub",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//sub: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//sub: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//sub: arg 1: expected native")
			}
			var arg1Val *image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-point//sub: arg 2: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-point//sub: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-point//sub: arg 2: expected native")
			}
			res0 := (*arg0Val).Sub(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-pt": {
		Doc:   "image.Pt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-pt: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-pt: arg 2: expected integer")
			}
			res0 := image.Pt(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-rect": {
		Doc:   "image.Rect",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rect: arg 4: expected integer")
			}
			res0 := image.Rect(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//add": {
		Doc:   "image.Rectangle.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//add: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//add: arg 1: expected native")
			}
			var arg1Val *image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//add: arg 2: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//add: arg 2: expected native")
			}
			res0 := (*arg0Val).Add(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//at": {
		Doc:   "image.Rectangle.At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//at: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rectangle//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rectangle//at: arg 3: expected integer")
			}
			res0 := (*arg0Val).At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"image-rectangle//bounds": {
		Doc:   "image.Rectangle.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//bounds: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//bounds: arg 1: expected native")
			}
			res0 := (*arg0Val).Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//canon": {
		Doc:   "image.Rectangle.Canon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//canon: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//canon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//canon: arg 1: expected native")
			}
			res0 := (*arg0Val).Canon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//color-model": {
		Doc:   "image.Rectangle.ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//color-model: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//color-model: arg 1: expected native")
			}
			res0 := (*arg0Val).ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"image-rectangle//dx": {
		Doc:   "image.Rectangle.Dx",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//dx: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//dx: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//dx: arg 1: expected native")
			}
			res0 := (*arg0Val).Dx()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"image-rectangle//dy": {
		Doc:   "image.Rectangle.Dy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//dy: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//dy: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//dy: arg 1: expected native")
			}
			res0 := (*arg0Val).Dy()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"image-rectangle//empty": {
		Doc:   "image.Rectangle.Empty",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//empty: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//empty: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//empty: arg 1: expected native")
			}
			res0 := (*arg0Val).Empty()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"image-rectangle//eq": {
		Doc:   "image.Rectangle.Eq",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//eq: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//eq: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//eq: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//eq: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//eq: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//eq: arg 2: expected native")
			}
			res0 := (*arg0Val).Eq(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"image-rectangle//in": {
		Doc:   "image.Rectangle.In",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//in: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//in: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//in: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//in: arg 2: expected native")
			}
			res0 := (*arg0Val).In(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"image-rectangle//inset": {
		Doc:   "image.Rectangle.Inset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//inset: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//inset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//inset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rectangle//inset: arg 2: expected integer")
			}
			res0 := (*arg0Val).Inset(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//intersect": {
		Doc:   "image.Rectangle.Intersect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//intersect: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//intersect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//intersect: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//intersect: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//intersect: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//intersect: arg 2: expected native")
			}
			res0 := (*arg0Val).Intersect(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//overlaps": {
		Doc:   "image.Rectangle.Overlaps",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//overlaps: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//overlaps: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//overlaps: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//overlaps: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//overlaps: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//overlaps: arg 2: expected native")
			}
			res0 := (*arg0Val).Overlaps(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"image-rectangle//rgba-64-at": {
		Doc:   "image.Rectangle.RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//rgba-64-at: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rectangle//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rectangle//rgba-64-at: arg 3: expected integer")
			}
			res0 := (*arg0Val).RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"image-rectangle//size": {
		Doc:   "image.Rectangle.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//size: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//size: arg 1: expected native")
			}
			res0 := (*arg0Val).Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-point")
			return res0Obj
		},
	},
	"image-rectangle//string": {
		Doc:   "image.Rectangle.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//string: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//string: arg 1: expected native")
			}
			res0 := (*arg0Val).String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"image-rectangle//sub": {
		Doc:   "image.Rectangle.Sub",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//sub: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//sub: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//sub: arg 1: expected native")
			}
			var arg1Val *image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//sub: arg 2: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//sub: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//sub: arg 2: expected native")
			}
			res0 := (*arg0Val).Sub(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-rectangle//union": {
		Doc:   "image.Rectangle.Union",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//union: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//union: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//union: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//union: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rectangle//union: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rectangle//union: arg 2: expected native")
			}
			res0 := (*arg0Val).Union(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"image-register-format": {
		Doc:   "image.RegisterFormat",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 2: expected string")
			}
			var arg2Val func(io.Reader) (image.Image, error)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 io.Reader) (image.Image, error) {
					var arg0Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typRyeName string
						var ok bool
						if typ != nil {
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						}
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "io-reader")
						}
					}
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res0 image.Image
					var res1 error
					res, ok := ps.Res.(env.Block)
					if !ok {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: expected block for multiple return values",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					if len(res.Series.S) != 2 {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: expected block with 2 return values",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[0].(type) {
					case env.RyeCtx:
						var err error
						res0, err = ctxTo_image_Image(ps, v)
						if err != nil {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: "+err.Error()+"",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
					case env.Native:
						var ok bool
						res0, ok = v.Value.(image.Image)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: expected native of type image.Image",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
					case env.Integer:
						if v.Value != 0 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: expected integer to be 0 or nil",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
						res0 = nil
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: expected native",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[1].(type) {
					case env.String:
						res1 = errors.New(v.Value)
					case env.Error:
						res1 = errors.New(v.Print(*ps.Idx))
					case env.Integer:
						if v.Value != 0 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 3: callback result: expected integer to be 0 or nil",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
						res1 = nil
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 3: callback result: expected error, string or nil",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					return res0, res1
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 3: expected function or nil")
			}
			var arg3Val func(io.Reader) (image.Config, error)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 4: function has invalid number of arguments (expected 1)")
				}
				arg3Val = func(arg0 io.Reader) (image.Config, error) {
					var arg0Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typRyeName string
						var ok bool
						if typ != nil {
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						}
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "io-reader")
						}
					}
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
					var res0 image.Config
					var res1 error
					res, ok := ps.Res.(env.Block)
					if !ok {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: expected block for multiple return values",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					if len(res.Series.S) != 2 {
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: expected block with 2 return values",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[0].(type) {
					case env.Native:
						var ok bool
						res0, ok = v.Value.(image.Config)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 4: callback result: expected native of type image.Config",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: expected native",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					switch v := res.Series.S[1].(type) {
					case env.String:
						res1 = errors.New(v.Value)
					case env.Error:
						res1 = errors.New(v.Print(*ps.Idx))
					case env.Integer:
						if v.Value != 0 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"image-register-format: arg 4: callback result: expected integer to be 0 or nil",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res0, res1
						}
						res1 = nil
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"image-register-format: arg 4: callback result: expected error, string or nil",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res0, res1
					}
					return res0, res1
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-register-format: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-register-format: arg 4: expected function or nil")
			}
			image.RegisterFormat(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"image-rgba-64-image//rgba-64-at": {
		Doc:   "image.RGBA64Image.RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.RGBA64Image
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_image_RGBA64Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("image-rgba-64-image//rgba-64-at: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.RGBA64Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-rgba-64-image//rgba-64-at: arg 1: expected native of type image.RGBA64Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-rgba-64-image//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-rgba-64-image//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rgba-64-image//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-rgba-64-image//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"image-y-cb-cr-subsample-ratio-410": {
		Doc:   "Get image.YCbCrSubsampleRatio410 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio410)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-411": {
		Doc:   "Get image.YCbCrSubsampleRatio411 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio411)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-420": {
		Doc:   "Get image.YCbCrSubsampleRatio420 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio420)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-422": {
		Doc:   "Get image.YCbCrSubsampleRatio422 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio422)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-440": {
		Doc:   "Get image.YCbCrSubsampleRatio440 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio440)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio-444": {
		Doc:   "Get image.YCbCrSubsampleRatio444 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(image.YCbCrSubsampleRatio444)))
			return resObj
		},
	},
	"image-y-cb-cr-subsample-ratio//string": {
		Doc:   "image.YCbCrSubsampleRatio.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.YCbCrSubsampleRatio
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("image-y-cb-cr-subsample-ratio//string: arg 1: expected integer")
					}
					arg0Val = image.YCbCrSubsampleRatio(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"image-zp": {
		Doc:   "Get image.ZP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, image.ZP, "image-point")
			return resObj
		},
	},
	"image-zr": {
		Doc:   "Get image.ZR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, image.ZR, "image-rectangle")
			return resObj
		},
	},
	"images-audio-alert-png": {
		Doc:   "Get images_audio.Alert_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_audio.Alert_png))
				for i, it := range images_audio.Alert_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-audio-pause-png": {
		Doc:   "Get images_audio.Pause_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_audio.Pause_png))
				for i, it := range images_audio.Pause_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-audio-play-png": {
		Doc:   "Get images_audio.Play_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_audio.Play_png))
				for i, it := range images_audio.Play_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-blocks-background-png": {
		Doc:   "Get images_blocks.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_blocks.Background_png))
				for i, it := range images_blocks.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-blocks-blocks-png": {
		Doc:   "Get images_blocks.Blocks_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_blocks.Blocks_png))
				for i, it := range images_blocks.Blocks_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ebiten-png": {
		Doc:   "Get images.Ebiten_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Ebiten_png))
				for i, it := range images.Ebiten_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-five-years-jpg": {
		Doc:   "Get images.FiveYears_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.FiveYears_jpg))
				for i, it := range images.FiveYears_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-gophers-jpg": {
		Doc:   "Get images.Gophers_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Gophers_jpg))
				for i, it := range images.Gophers_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-keyboard-keyboard-png": {
		Doc:   "Get images_keyboard.Keyboard_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_keyboard.Keyboard_png))
				for i, it := range images_keyboard.Keyboard_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-runner-png": {
		Doc:   "Get images.Runner_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Runner_png))
				for i, it := range images.Runner_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-gopher-bg-png": {
		Doc:   "Get images_shader.GopherBg_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.GopherBg_png))
				for i, it := range images_shader.GopherBg_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-gopher-png": {
		Doc:   "Get images_shader.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.Gopher_png))
				for i, it := range images_shader.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-noise-png": {
		Doc:   "Get images_shader.Noise_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.Noise_png))
				for i, it := range images_shader.Noise_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-shader-normal-png": {
		Doc:   "Get images_shader.Normal_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images_shader.Normal_png))
				for i, it := range images_shader.Normal_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-smoke-png": {
		Doc:   "Get images.Smoke_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Smoke_png))
				for i, it := range images.Smoke_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-spritesheet-png": {
		Doc:   "Get images.Spritesheet_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Spritesheet_png))
				for i, it := range images.Spritesheet_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tile-png": {
		Doc:   "Get images.Tile_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tile_png))
				for i, it := range images.Tile_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tiles-png": {
		Doc:   "Get images.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tiles_png))
				for i, it := range images.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ui-png": {
		Doc:   "Get images.UI_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.UI_png))
				for i, it := range images.UI_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"inpututil-append-just-connected-gamepad-i-ds": {
		Doc:   "inpututil.AppendJustConnectedGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadID)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.GamepadID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.GamepadID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected native of type []ebiten.GamepadID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustConnectedGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-gamepad-buttons": {
		Doc:   "inpututil.AppendJustPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-keys": {
		Doc:   "inpututil.AppendJustPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendJustPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-touch-i-ds": {
		Doc:   "inpututil.AppendJustPressedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-gamepad-buttons": {
		Doc:   "inpututil.AppendJustReleasedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-keys": {
		Doc:   "inpututil.AppendJustReleasedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendJustReleasedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-touch-i-ds": {
		Doc:   "inpututil.AppendJustReleasedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-gamepad-buttons": {
		Doc:   "inpututil.AppendPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-keys": {
		Doc:   "inpututil.AppendPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-gamepad-button-press-duration": {
		Doc:   "inpututil.GamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-gamepad-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-gamepad-button-press-duration: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.GamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-pressed": {
		Doc:   "inpututil.IsGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.IsGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-released": {
		Doc:   "inpututil.IsGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-released: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.IsGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-just-disconnected": {
		Doc:   "inpututil.IsGamepadJustDisconnected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-just-disconnected: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := inpututil.IsGamepadJustDisconnected(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-pressed": {
		Doc:   "inpututil.IsKeyJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-key-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-released": {
		Doc:   "inpututil.IsKeyJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-key-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-pressed": {
		Doc:   "inpututil.IsMouseButtonJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-mouse-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.IsMouseButtonJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-released": {
		Doc:   "inpututil.IsMouseButtonJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-mouse-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.IsMouseButtonJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-pressed": {
		Doc:   "inpututil.IsStandardGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.IsStandardGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-released": {
		Doc:   "inpututil.IsStandardGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.IsStandardGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-touch-just-released": {
		Doc:   "inpututil.IsTouchJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-touch-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0 := inpututil.IsTouchJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-just-connected-gamepad-i-ds": {
		Doc:   "inpututil.JustConnectedGamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.JustConnectedGamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-just-pressed-touch-i-ds": {
		Doc:   "inpututil.JustPressedTouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.JustPressedTouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-key-press-duration": {
		Doc:   "inpututil.KeyPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-key-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.KeyPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-mouse-button-press-duration": {
		Doc:   "inpututil.MouseButtonPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-mouse-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.MouseButtonPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-pressed-keys": {
		Doc:   "inpututil.PressedKeys",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.PressedKeys()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-standard-gamepad-button-press-duration": {
		Doc:   "inpututil.StandardGamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.StandardGamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-touch-position-in-previous-tick": {
		Doc:   "inpututil.TouchPositionInPreviousTick",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-touch-position-in-previous-tick: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0, res1 := inpututil.TouchPositionInPreviousTick(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"inpututil-touch-press-duration": {
		Doc:   "inpututil.TouchPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-touch-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0 := inpututil.TouchPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"io-byte-reader//read-byte": {
		Doc:   "io.ByteReader.ReadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ByteReader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_ByteReader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("io-byte-reader//read-byte: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.ByteReader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-byte-reader//read-byte: arg 1: expected native of type io.ByteReader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-byte-reader//read-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-byte-reader//read-byte: arg 1: expected native")
			}
			res0, resErr := arg0Val.ReadByte()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"io-closer//close": {
		Doc:   "io.Closer.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Closer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Closer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("io-closer//close: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Closer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-closer//close: arg 1: expected native of type io.Closer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-closer//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-closer//close: arg 1: expected native")
			}
			resErr := arg0Val.Close()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"io-reader//read": {
		Doc:   "io.Reader.Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-reader//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("io-reader//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("io-reader//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-reader//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"io-seeker//seek": {
		Doc:   "io.Seeker.Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Seeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Seeker(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("io-seeker//seek: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Seeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-seeker//seek: arg 1: expected native of type io.Seeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-seeker//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-seeker//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("io-seeker//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("io-seeker//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"jpeg-decode": {
		Doc:   "jpeg.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-decode: arg 1: expected native")
			}
			res0, resErr := jpeg.Decode(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"jpeg-decode-config": {
		Doc:   "jpeg.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode-config: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode-config: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-decode-config: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-decode-config: arg 1: expected native")
			}
			res0, resErr := jpeg.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-config")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"jpeg-encode": {
		Doc:   "jpeg.Encode",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 1: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-encode: arg 1: expected native")
			}
			var arg1Val image.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 2: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-encode: arg 2: expected native")
			}
			var arg2Val *jpeg.Options
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*jpeg.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 3: expected native of type *jpeg.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("jpeg-encode: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("jpeg-encode: arg 3: expected native")
			}
			resErr := jpeg.Encode(arg0Val, arg1Val, arg2Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"jpeg-format-error//error": {
		Doc:   "jpeg.FormatError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val jpeg.FormatError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal jpeg.FormatError
				if natOk {
					natVal, natValOk = nat.Value.(jpeg.FormatError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if v, ok := arg0.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("jpeg-format-error//error: arg 1: expected string")
					}
					arg0Val = jpeg.FormatError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"jpeg-options": {
		Doc:   "Create a new jpeg.Options struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &jpeg.Options{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-jpeg-options")
			return resObj
		},
	},
	"jpeg-unsupported-error//error": {
		Doc:   "jpeg.UnsupportedError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val jpeg.UnsupportedError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal jpeg.UnsupportedError
				if natOk {
					natVal, natValOk = nat.Value.(jpeg.UnsupportedError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if v, ok := arg0.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("jpeg-unsupported-error//error: arg 1: expected string")
					}
					arg0Val = jpeg.UnsupportedError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"keyboard-key-rect": {
		Doc:   "keyboard.KeyRect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("keyboard-key-rect: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, res1 := keyboard.KeyRect(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"mascot-out-01-png": {
		Doc:   "Get mascot.Out01_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out01_png))
				for i, it := range mascot.Out01_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-02-png": {
		Doc:   "Get mascot.Out02_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out02_png))
				for i, it := range mascot.Out02_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-03-png": {
		Doc:   "Get mascot.Out03_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out03_png))
				for i, it := range mascot.Out03_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mobile-set-game": {
		Doc:   "mobile.SetGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game: arg 1: expected native")
			}
			mobile.SetGame(arg0Val)
			return nil
		},
	},
	"mobile-set-game-with-options": {
		Doc:   "mobile.SetGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_ebiten_Game(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game-with-options: arg 1: expected native")
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 2: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game-with-options: arg 2: expected native")
			}
			mobile.SetGameWithOptions(arg0Val, arg1Val)
			return nil
		},
	},
	"mp-3-decode": {
		Doc:   "mp3.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode: arg 2: expected native")
			}
			res0, resErr := mp3.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"mp-3-decode-with-sample-rate": {
		Doc:   "mp3.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected native")
			}
			res0, resErr := mp3.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"mp-3-decode-without-resampling": {
		Doc:   "mp3.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-without-resampling: arg 1: expected native")
			}
			res0, resErr := mp3.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"mp-3-stream": {
		Doc:   "Create a new mp3.Stream struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &mp3.Stream{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-mp-3-stream")
			return resObj
		},
	},
	"platformer-background-png": {
		Doc:   "Get platformer.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Background_png))
				for i, it := range platformer.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-left-png": {
		Doc:   "Get platformer.Left_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Left_png))
				for i, it := range platformer.Left_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-main-char-png": {
		Doc:   "Get platformer.MainChar_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.MainChar_png))
				for i, it := range platformer.MainChar_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-right-png": {
		Doc:   "Get platformer.Right_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Right_png))
				for i, it := range platformer.Right_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"png-best-compression": {
		Doc:   "Get png.BestCompression value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.BestCompression)))
			return resObj
		},
	},
	"png-best-speed": {
		Doc:   "Get png.BestSpeed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.BestSpeed)))
			return resObj
		},
	},
	"png-decode": {
		Doc:   "png.Decode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-decode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-decode: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-decode: arg 1: expected native")
			}
			res0, resErr := png.Decode(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"png-decode-config": {
		Doc:   "png.DecodeConfig",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-decode-config: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-decode-config: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-decode-config: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-decode-config: arg 1: expected native")
			}
			res0, resErr := png.DecodeConfig(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-config")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"png-default-compression": {
		Doc:   "Get png.DefaultCompression value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.DefaultCompression)))
			return resObj
		},
	},
	"png-encode": {
		Doc:   "png.Encode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Writer
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 1: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encode: arg 1: expected native")
			}
			var arg1Val image.Image
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 2: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encode: arg 2: expected native")
			}
			resErr := png.Encode(arg0Val, arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return nil
		},
	},
	"png-encoder-buffer-pool//get": {
		Doc:   "png.EncoderBufferPool.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.EncoderBufferPool
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_png_EncoderBufferPool(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//get: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(png.EncoderBufferPool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//get: arg 1: expected native of type png.EncoderBufferPool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encoder-buffer-pool//get: arg 1: expected native")
			}
			res0 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-png-encoder-buffer")
			return res0Obj
		},
	},
	"png-encoder-buffer-pool//put": {
		Doc:   "png.EncoderBufferPool.Put",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.EncoderBufferPool
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_png_EncoderBufferPool(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//put: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(png.EncoderBufferPool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//put: arg 1: expected native of type png.EncoderBufferPool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//put: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encoder-buffer-pool//put: arg 1: expected native")
			}
			var arg1Val *png.EncoderBuffer
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*png.EncoderBuffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//put: arg 2: expected native of type *png.EncoderBuffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("png-encoder-buffer-pool//put: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("png-encoder-buffer-pool//put: arg 2: expected native")
			}
			arg0Val.Put(arg1Val)
			return arg0
		},
	},
	"png-format-error//error": {
		Doc:   "png.FormatError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.FormatError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal png.FormatError
				if natOk {
					natVal, natValOk = nat.Value.(png.FormatError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if v, ok := arg0.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("png-format-error//error: arg 1: expected string")
					}
					arg0Val = png.FormatError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"png-encoder": {
		Doc:   "Create a new png.Encoder struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &png.Encoder{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-png-encoder")
			return resObj
		},
	},
	"png-no-compression": {
		Doc:   "Get png.NoCompression value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(png.NoCompression)))
			return resObj
		},
	},
	"png-unsupported-error//error": {
		Doc:   "png.UnsupportedError.Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val png.UnsupportedError
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal png.UnsupportedError
				if natOk {
					natVal, natValOk = nat.Value.(png.UnsupportedError)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if v, ok := arg0.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("png-unsupported-error//error: arg 1: expected string")
					}
					arg0Val = png.UnsupportedError(u)
				}
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-audio-context//is-ready": {
		Doc:   "(*audio.Context).IsReady",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//is-ready: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//is-ready: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-context//is-ready: arg 1: expected native")
			}
			res0 := arg0Val.IsReady()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-audio-context//player": {
		Doc:   "(*audio.Context).NewPlayer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-context//player: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-context//player: arg 2: expected native")
			}
			res0, resErr := arg0Val.NewPlayer(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-player")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-audio-context//player-from-bytes": {
		Doc:   "(*audio.Context).NewPlayerFromBytes",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player-from-bytes: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player-from-bytes: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-context//player-from-bytes: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-audio-context//player-from-bytes: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-audio-context//player-from-bytes: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player-from-bytes: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//player-from-bytes: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-context//player-from-bytes: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.NewPlayerFromBytes(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-player")
			return res0Obj
		},
	},
	"ptr-audio-context//sample-rate": {
		Doc:   "(*audio.Context).SampleRate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//sample-rate: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-context//sample-rate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-context//sample-rate: arg 1: expected native")
			}
			res0 := arg0Val.SampleRate()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-audio-infinite-loop//read": {
		Doc:   "(*audio.InfiniteLoop).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.InfiniteLoop)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected native of type *audio.InfiniteLoop")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-audio-infinite-loop//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-audio-infinite-loop//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-audio-infinite-loop//seek": {
		Doc:   "(*audio.InfiniteLoop).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.InfiniteLoop)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected native of type *audio.InfiniteLoop")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-audio-player//close": {
		Doc:   "(*audio.Player).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//close: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//close: arg 1: expected native")
			}
			resErr := arg0Val.Close()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-audio-player//current": {
		Doc:   "(*audio.Player).Current",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//current: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//current: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//current: arg 1: expected native")
			}
			res0 := arg0Val.Current()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "time-duration")
			return res0Obj
		},
	},
	"ptr-audio-player//is-playing": {
		Doc:   "(*audio.Player).IsPlaying",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//is-playing: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//is-playing: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//is-playing: arg 1: expected native")
			}
			res0 := arg0Val.IsPlaying()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-audio-player//pause": {
		Doc:   "(*audio.Player).Pause",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//pause: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//pause: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//pause: arg 1: expected native")
			}
			arg0Val.Pause()
			return arg0
		},
	},
	"ptr-audio-player//play": {
		Doc:   "(*audio.Player).Play",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//play: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//play: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//play: arg 1: expected native")
			}
			arg0Val.Play()
			return arg0
		},
	},
	"ptr-audio-player//position": {
		Doc:   "(*audio.Player).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//position: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "time-duration")
			return res0Obj
		},
	},
	"ptr-audio-player//rewind": {
		Doc:   "(*audio.Player).Rewind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//rewind: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//rewind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//rewind: arg 1: expected native")
			}
			resErr := arg0Val.Rewind()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-audio-player//seek": {
		Doc:   "(*audio.Player).Seek",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//seek: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//seek: arg 1: expected native")
			}
			var arg1Val time.Duration
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//seek: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//seek: arg 2: expected native")
			}
			resErr := arg0Val.Seek(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-audio-player//set-buffer-size": {
		Doc:   "(*audio.Player).SetBufferSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-buffer-size: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-buffer-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//set-buffer-size: arg 1: expected native")
			}
			var arg1Val time.Duration
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-buffer-size: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//set-buffer-size: arg 2: expected native")
			}
			arg0Val.SetBufferSize(arg1Val)
			return arg0
		},
	},
	"ptr-audio-player//set-position": {
		Doc:   "(*audio.Player).SetPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-position: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//set-position: arg 1: expected native")
			}
			var arg1Val time.Duration
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-position: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//set-position: arg 2: expected native")
			}
			resErr := arg0Val.SetPosition(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-audio-player//set-volume": {
		Doc:   "(*audio.Player).SetVolume",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-volume: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//set-volume: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//set-volume: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//set-volume: arg 2: expected decimal")
			}
			arg0Val.SetVolume(arg1Val)
			return arg0
		},
	},
	"ptr-audio-player//volume": {
		Doc:   "(*audio.Player).Volume",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Player
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Player)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//volume: arg 1: expected native of type *audio.Player")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-player//volume: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-player//volume: arg 1: expected native")
			}
			res0 := arg0Val.Volume()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//absorb-piece": {
		Doc:   "(*blocks.Field).AbsorbPiece",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//absorb-piece: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbPiece(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-field//draw": {
		Doc:   "(*blocks.Field).Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 4: expected integer")
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-blocks-field//drop-piece": {
		Doc:   "(*blocks.Field).DropPiece",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//drop-piece: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.DropPiece(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//is-blocked": {
		Doc:   "(*blocks.Field).IsBlocked",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-blocked: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-blocked: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-blocked: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-blocked: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-blocked: arg 3: expected integer")
			}
			res0 := arg0Val.IsBlocked(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//is-flush-animating": {
		Doc:   "(*blocks.Field).IsFlushAnimating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-flush-animating: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-flush-animating: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-flush-animating: arg 1: expected native")
			}
			res0 := arg0Val.IsFlushAnimating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//move-piece-to-left": {
		Doc:   "(*blocks.Field).MovePieceToLeft",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//move-piece-to-left: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.MovePieceToLeft(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//move-piece-to-right": {
		Doc:   "(*blocks.Field).MovePieceToRight",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//move-piece-to-right: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.MovePieceToRight(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//piece-droppable": {
		Doc:   "(*blocks.Field).PieceDroppable",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//piece-droppable: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.PieceDroppable(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//rotate-piece-left": {
		Doc:   "(*blocks.Field).RotatePieceLeft",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//rotate-piece-left: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotatePieceLeft(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-field//rotate-piece-right": {
		Doc:   "(*blocks.Field).RotatePieceRight",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//rotate-piece-right: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotatePieceRight(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-field//set-end-flush-animating": {
		Doc:   "(*blocks.Field).SetEndFlushAnimating",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 1: expected native")
			}
			var arg1Val func(int)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 int) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, arg0Val)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 2: expected function or nil")
			}
			arg0Val.SetEndFlushAnimating(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-field//update": {
		Doc:   "(*blocks.Field).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//update: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-blocks-game-scene//draw": {
		Doc:   "(*blocks.GameScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GameScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected native of type *blocks.GameScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-game-scene//update": {
		Doc:   "(*blocks.GameScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GameScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 1: expected native of type *blocks.GameScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//update: arg 2: expected native")
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//input!": {
		Doc:   "Set *blocks.GameState Input value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//input!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Input, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 2: expected integer to be 0 or nil")
				}
				self.Input = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//input!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//input?": {
		Doc:   "Get *blocks.GameState Input value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input?: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//input?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Input, "ptr-blocks-input")
			return resObj
		},
	},
	"ptr-blocks-game-state//scene-manager!": {
		Doc:   "Set *blocks.GameState SceneManager value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SceneManager, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected integer to be 0 or nil")
				}
				self.SceneManager = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//scene-manager?": {
		Doc:   "Get *blocks.GameState SceneManager value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SceneManager, "ptr-blocks-scene-manager")
			return resObj
		},
	},
	"ptr-blocks-game//draw": {
		Doc:   "(*blocks.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-game//layout": {
		Doc:   "(*blocks.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//layout: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-blocks-game//update": {
		Doc:   "(*blocks.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//update: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//update: arg 1: expected native")
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-blocks-gamepad-scene//draw": {
		Doc:   "(*blocks.GamepadScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GamepadScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected native of type *blocks.GamepadScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-gamepad-scene//update": {
		Doc:   "(*blocks.GamepadScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GamepadScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected native of type *blocks.GamepadScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected native")
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-blocks-input//gamepad-id-button-pressed": {
		Doc:   "(*blocks.Input).GamepadIDButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected native")
			}
			res0 := arg0Val.GamepadIDButtonPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-input//is-rotate-left-just-pressed": {
		Doc:   "(*blocks.Input).IsRotateLeftJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected native")
			}
			res0 := arg0Val.IsRotateLeftJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//is-rotate-right-just-pressed": {
		Doc:   "(*blocks.Input).IsRotateRightJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected native")
			}
			res0 := arg0Val.IsRotateRightJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-down": {
		Doc:   "(*blocks.Input).StateForDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected native")
			}
			res0 := arg0Val.StateForDown()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-left": {
		Doc:   "(*blocks.Input).StateForLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected native")
			}
			res0 := arg0Val.StateForLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-right": {
		Doc:   "(*blocks.Input).StateForRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected native")
			}
			res0 := arg0Val.StateForRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//update": {
		Doc:   "(*blocks.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//update: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-blocks-piece//absorb-into": {
		Doc:   "(*blocks.Piece).AbsorbInto",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected native")
			}
			var arg1Val *blocks.Field
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-piece//absorb-into: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbInto(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-piece//draw": {
		Doc:   "(*blocks.Piece).Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-piece//draw: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-piece//initial-position": {
		Doc:   "(*blocks.Piece).InitialPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected native")
			}
			res0, res1 := arg0Val.InitialPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-blocks-scene-manager//draw": {
		Doc:   "(*blocks.SceneManager).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-scene-manager//go-to": {
		Doc:   "(*blocks.SceneManager).GoTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected native")
			}
			var arg1Val blocks.Scene
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_blocks_Scene(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(blocks.Scene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected native of type blocks.Scene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected native")
			}
			arg0Val.GoTo(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-scene-manager//update": {
		Doc:   "(*blocks.SceneManager).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected native")
			}
			var arg1Val *blocks.Input
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected native")
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-blocks-title-scene//draw": {
		Doc:   "(*blocks.TitleScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.TitleScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected native of type *blocks.TitleScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-title-scene//update": {
		Doc:   "(*blocks.TitleScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.TitleScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 1: expected native of type *blocks.TitleScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//update: arg 2: expected native")
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-bytes-buffer//bytes": {
		Doc:   "(*bytes.Buffer).Bytes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//bytes: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//bytes: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//bytes: arg 1: expected native")
			}
			res0 := arg0Val.Bytes()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//cap": {
		Doc:   "(*bytes.Buffer).Cap",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//cap: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//cap: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//cap: arg 1: expected native")
			}
			res0 := arg0Val.Cap()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-bytes-buffer//grow": {
		Doc:   "(*bytes.Buffer).Grow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//grow: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//grow: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//grow: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//grow: arg 2: expected integer")
			}
			arg0Val.Grow(arg1Val)
			return arg0
		},
	},
	"ptr-bytes-buffer//len": {
		Doc:   "(*bytes.Buffer).Len",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//len: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//len: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//len: arg 1: expected native")
			}
			res0 := arg0Val.Len()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-bytes-buffer//next": {
		Doc:   "(*bytes.Buffer).Next",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//next: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//next: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//next: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//next: arg 2: expected integer")
			}
			res0 := arg0Val.Next(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//read": {
		Doc:   "(*bytes.Buffer).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-bytes-buffer//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-bytes-buffer//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//read-byte": {
		Doc:   "(*bytes.Buffer).ReadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-byte: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-byte: arg 1: expected native")
			}
			res0, resErr := arg0Val.ReadByte()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//read-bytes": {
		Doc:   "(*bytes.Buffer).ReadBytes",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-bytes: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-bytes: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-bytes: arg 1: expected native")
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-bytes: arg 2: expected native of type byte")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-bytes: arg 2: expected native")
			}
			res0, resErr := arg0Val.ReadBytes(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//read-from": {
		Doc:   "(*bytes.Buffer).ReadFrom",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-from: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-from: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-from: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-from: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-from: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-from: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-from: arg 2: expected native")
			}
			res0, resErr := arg0Val.ReadFrom(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//read-rune": {
		Doc:   "(*bytes.Buffer).ReadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-rune: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-rune: arg 1: expected native")
			}
			res0, res1, resErr := arg0Val.ReadRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-bytes-buffer//read-string": {
		Doc:   "(*bytes.Buffer).ReadString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-string: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-string: arg 1: expected native")
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//read-string: arg 2: expected native of type byte")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//read-string: arg 2: expected native")
			}
			res0, resErr := arg0Val.ReadString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//reset": {
		Doc:   "(*bytes.Buffer).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//reset: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-bytes-buffer//string": {
		Doc:   "(*bytes.Buffer).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//string: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-bytes-buffer//truncate": {
		Doc:   "(*bytes.Buffer).Truncate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//truncate: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//truncate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//truncate: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//truncate: arg 2: expected integer")
			}
			arg0Val.Truncate(arg1Val)
			return arg0
		},
	},
	"ptr-bytes-buffer//unread-byte": {
		Doc:   "(*bytes.Buffer).UnreadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//unread-byte: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//unread-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//unread-byte: arg 1: expected native")
			}
			resErr := arg0Val.UnreadByte()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-bytes-buffer//unread-rune": {
		Doc:   "(*bytes.Buffer).UnreadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//unread-rune: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//unread-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//unread-rune: arg 1: expected native")
			}
			resErr := arg0Val.UnreadRune()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-bytes-buffer//write": {
		Doc:   "(*bytes.Buffer).Write",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-bytes-buffer//write: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-bytes-buffer//write: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Write(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//write-byte": {
		Doc:   "(*bytes.Buffer).WriteByte",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-byte: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-byte: arg 1: expected native")
			}
			var arg1Val byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-byte: arg 2: expected native of type byte")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-byte: arg 2: expected native")
			}
			resErr := arg0Val.WriteByte(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-bytes-buffer//write-rune": {
		Doc:   "(*bytes.Buffer).WriteRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-rune: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-rune: arg 2: expected native")
			}
			res0, resErr := arg0Val.WriteRune(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//write-string": {
		Doc:   "(*bytes.Buffer).WriteString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-string: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-string: arg 2: expected string")
			}
			res0, resErr := arg0Val.WriteString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-buffer//write-to": {
		Doc:   "(*bytes.Buffer).WriteTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Buffer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Buffer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-to: arg 1: expected native of type *bytes.Buffer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-to: arg 1: expected native")
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-to: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-to: arg 2: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-buffer//write-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-buffer//write-to: arg 2: expected native")
			}
			res0, resErr := arg0Val.WriteTo(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-reader//len": {
		Doc:   "(*bytes.Reader).Len",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//len: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//len: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//len: arg 1: expected native")
			}
			res0 := arg0Val.Len()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-bytes-reader//read": {
		Doc:   "(*bytes.Reader).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-bytes-reader//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-bytes-reader//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-reader//read-at": {
		Doc:   "(*bytes.Reader).ReadAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-at: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read-at: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-bytes-reader//read-at: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-bytes-reader//read-at: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-at: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-at: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read-at: arg 2: expected block, native or nil")
			}
			var arg2Val int64
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read-at: arg 3: expected integer")
			}
			res0, resErr := arg0Val.ReadAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-reader//read-byte": {
		Doc:   "(*bytes.Reader).ReadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-byte: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read-byte: arg 1: expected native")
			}
			res0, resErr := arg0Val.ReadByte()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-reader//read-rune": {
		Doc:   "(*bytes.Reader).ReadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-rune: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//read-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//read-rune: arg 1: expected native")
			}
			res0, res1, resErr := arg0Val.ReadRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-bytes-reader//reset": {
		Doc:   "(*bytes.Reader).Reset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//reset: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//reset: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-bytes-reader//reset: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-bytes-reader//reset: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//reset: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//reset: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//reset: arg 2: expected block, native or nil")
			}
			arg0Val.Reset(arg1Val)
			return arg0
		},
	},
	"ptr-bytes-reader//seek": {
		Doc:   "(*bytes.Reader).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//seek: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-bytes-reader//size": {
		Doc:   "(*bytes.Reader).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//size: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-bytes-reader//unread-byte": {
		Doc:   "(*bytes.Reader).UnreadByte",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//unread-byte: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//unread-byte: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//unread-byte: arg 1: expected native")
			}
			resErr := arg0Val.UnreadByte()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-bytes-reader//unread-rune": {
		Doc:   "(*bytes.Reader).UnreadRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//unread-rune: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//unread-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//unread-rune: arg 1: expected native")
			}
			resErr := arg0Val.UnreadRune()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-bytes-reader//write-to": {
		Doc:   "(*bytes.Reader).WriteTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *bytes.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bytes.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//write-to: arg 1: expected native of type *bytes.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//write-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//write-to: arg 1: expected native")
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//write-to: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//write-to: arg 2: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-bytes-reader//write-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-bytes-reader//write-to: arg 2: expected native")
			}
			res0, resErr := arg0Val.WriteTo(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-color-alpha-16//a!": {
		Doc:   "Set *color.Alpha16 A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha-16//a!: arg 1: expected native of type *color.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha-16//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-alpha-16//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-alpha-16//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-alpha-16//a?": {
		Doc:   "Get *color.Alpha16 A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha-16//a?: arg 1: expected native of type *color.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha-16//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-alpha-16//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-alpha//a!": {
		Doc:   "Set *color.Alpha A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha//a!: arg 1: expected native of type *color.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-alpha//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-alpha//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-alpha//a?": {
		Doc:   "Get *color.Alpha A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha//a?: arg 1: expected native of type *color.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-alpha//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-alpha//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-cmyk//c!": {
		Doc:   "Set *color.CMYK C value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//c!: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//c!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//c!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.C = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//c!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-cmyk//c?": {
		Doc:   "Get *color.CMYK C value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//c?: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//c?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//c?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.C))
			return resObj
		},
	},
	"ptr-color-cmyk//k!": {
		Doc:   "Set *color.CMYK K value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//k!: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//k!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//k!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.K = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//k!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-cmyk//k?": {
		Doc:   "Get *color.CMYK K value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//k?: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//k?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//k?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.K))
			return resObj
		},
	},
	"ptr-color-cmyk//m!": {
		Doc:   "Set *color.CMYK M value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//m!: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//m!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.M = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//m!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-cmyk//m?": {
		Doc:   "Get *color.CMYK M value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//m?: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.M))
			return resObj
		},
	},
	"ptr-color-cmyk//y!": {
		Doc:   "Set *color.CMYK Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//y!: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Y = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//y!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-cmyk//y?": {
		Doc:   "Get *color.CMYK Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//y?: arg 1: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-cmyk//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-cmyk//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"ptr-color-gray-16//y!": {
		Doc:   "Set *color.Gray16 Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray-16//y!: arg 1: expected native of type *color.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray-16//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-gray-16//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Y = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-gray-16//y!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-gray-16//y?": {
		Doc:   "Get *color.Gray16 Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray-16//y?: arg 1: expected native of type *color.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray-16//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-gray-16//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"ptr-color-gray//y!": {
		Doc:   "Set *color.Gray Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray//y!: arg 1: expected native of type *color.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-gray//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Y = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-gray//y!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-gray//y?": {
		Doc:   "Get *color.Gray Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray//y?: arg 1: expected native of type *color.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-gray//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-gray//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"ptr-color-nrgba-64//a!": {
		Doc:   "Set *color.NRGBA64 A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//a!: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba-64//a?": {
		Doc:   "Get *color.NRGBA64 A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//a?: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-nrgba-64//b!": {
		Doc:   "Set *color.NRGBA64 B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//b!: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.B = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//b!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba-64//b?": {
		Doc:   "Get *color.NRGBA64 B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//b?: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"ptr-color-nrgba-64//g!": {
		Doc:   "Set *color.NRGBA64 G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//g!: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.G = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//g!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba-64//g?": {
		Doc:   "Get *color.NRGBA64 G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//g?: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"ptr-color-nrgba-64//r!": {
		Doc:   "Set *color.NRGBA64 R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//r!: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.R = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//r!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba-64//r?": {
		Doc:   "Get *color.NRGBA64 R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//r?: arg 1: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba-64//r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba-64//r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"ptr-color-nrgba//a!": {
		Doc:   "Set *color.NRGBA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//a!: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba//a?": {
		Doc:   "Get *color.NRGBA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//a?: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-nrgba//b!": {
		Doc:   "Set *color.NRGBA B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//b!: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.B = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//b!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba//b?": {
		Doc:   "Get *color.NRGBA B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//b?: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"ptr-color-nrgba//g!": {
		Doc:   "Set *color.NRGBA G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//g!: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.G = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//g!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba//g?": {
		Doc:   "Get *color.NRGBA G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//g?: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"ptr-color-nrgba//r!": {
		Doc:   "Set *color.NRGBA R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//r!: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.R = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//r!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-nrgba//r?": {
		Doc:   "Get *color.NRGBA R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//r?: arg 1: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-nrgba//r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-nrgba//r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"ptr-color-ny-cb-cr-a//a!": {
		Doc:   "Set *color.NYCbCrA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//a!: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-ny-cb-cr-a//a?": {
		Doc:   "Get *color.NYCbCrA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//a?: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-ny-cb-cr-a//cb!": {
		Doc:   "Set *color.NYCbCrA Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cb!: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//cb!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Cb = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//cb!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-ny-cb-cr-a//cb?": {
		Doc:   "Get *color.NYCbCrA Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cb?: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//cb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cb))
			return resObj
		},
	},
	"ptr-color-ny-cb-cr-a//cr!": {
		Doc:   "Set *color.NYCbCrA Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cr!: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cr!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//cr!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Cr = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//cr!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-ny-cb-cr-a//cr?": {
		Doc:   "Get *color.NYCbCrA Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cr?: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//cr?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//cr?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cr))
			return resObj
		},
	},
	"ptr-color-ny-cb-cr-a//y!": {
		Doc:   "Set *color.NYCbCrA Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//y!: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Y = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//y!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-ny-cb-cr-a//y?": {
		Doc:   "Get *color.NYCbCrA Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//y?: arg 1: expected native of type *color.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-ny-cb-cr-a//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-ny-cb-cr-a//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"ptr-color-rgba-64//a!": {
		Doc:   "Set *color.RGBA64 A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//a!: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba-64//a?": {
		Doc:   "Get *color.RGBA64 A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//a?: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-rgba-64//b!": {
		Doc:   "Set *color.RGBA64 B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//b!: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.B = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//b!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba-64//b?": {
		Doc:   "Get *color.RGBA64 B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//b?: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"ptr-color-rgba-64//g!": {
		Doc:   "Set *color.RGBA64 G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//g!: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.G = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//g!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba-64//g?": {
		Doc:   "Get *color.RGBA64 G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//g?: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"ptr-color-rgba-64//r!": {
		Doc:   "Set *color.RGBA64 R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//r!: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.R = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//r!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba-64//r?": {
		Doc:   "Get *color.RGBA64 R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//r?: arg 1: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba-64//r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba-64//r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"ptr-color-rgba//a!": {
		Doc:   "Set *color.RGBA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//a!: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.A = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//a!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba//a?": {
		Doc:   "Get *color.RGBA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//a?: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.A))
			return resObj
		},
	},
	"ptr-color-rgba//b!": {
		Doc:   "Set *color.RGBA B value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//b!: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.B = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//b!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba//b?": {
		Doc:   "Get *color.RGBA B value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//b?: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.B))
			return resObj
		},
	},
	"ptr-color-rgba//g!": {
		Doc:   "Set *color.RGBA G value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//g!: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.G = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//g!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba//g?": {
		Doc:   "Get *color.RGBA G value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//g?: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.G))
			return resObj
		},
	},
	"ptr-color-rgba//r!": {
		Doc:   "Set *color.RGBA R value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//r!: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.R = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//r!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-rgba//r?": {
		Doc:   "Get *color.RGBA R value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//r?: arg 1: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-rgba//r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-rgba//r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.R))
			return resObj
		},
	},
	"ptr-color-y-cb-cr//cb!": {
		Doc:   "Set *color.YCbCr Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cb!: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//cb!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Cb = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//cb!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-y-cb-cr//cb?": {
		Doc:   "Get *color.YCbCr Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cb?: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//cb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cb))
			return resObj
		},
	},
	"ptr-color-y-cb-cr//cr!": {
		Doc:   "Set *color.YCbCr Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cr!: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cr!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//cr!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Cr = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//cr!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-y-cb-cr//cr?": {
		Doc:   "Get *color.YCbCr Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cr?: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//cr?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//cr?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Cr))
			return resObj
		},
	},
	"ptr-color-y-cb-cr//y!": {
		Doc:   "Set *color.YCbCr Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//y!: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Y = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//y!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-color-y-cb-cr//y?": {
		Doc:   "Get *color.YCbCr Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *color.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*color.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//y?: arg 1: expected native of type *color.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-color-y-cb-cr//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-color-y-cb-cr//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"ptr-colorm-color-m//apply": {
		Doc:   "(*colorm.ColorM).Apply",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//apply: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//apply: arg 2: expected native")
			}
			res0 := arg0Val.Apply(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-colorm-color-m//change-hsv": {
		Doc:   "(*colorm.ColorM).ChangeHSV",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//change-hsv: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//change-hsv: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 4: expected decimal")
			}
			arg0Val.ChangeHSV(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//concat": {
		Doc:   "(*colorm.ColorM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//concat: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//concat: arg 1: expected native")
			}
			var arg1Val colorm.ColorM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//concat: arg 2: expected native of type colorm.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//element": {
		Doc:   "(*colorm.ColorM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//element: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-colorm-color-m//invert": {
		Doc:   "(*colorm.ColorM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//invert: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-colorm-color-m//is-invertible": {
		Doc:   "(*colorm.ColorM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//is-invertible: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-colorm-color-m//read-elements": {
		Doc:   "(*colorm.ColorM).ReadElements",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//read-elements: arg 1: expected native")
			}
			var arg1Val []float32
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]float32, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg1Val[i] = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-color-m//read-elements: arg 2: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]float32)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 2: expected native of type []float32")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//read-elements: arg 2: expected block, native or nil")
			}
			var arg2Val []float32
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float32, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-color-m//read-elements: arg 3: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float32)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 3: expected native of type []float32")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//read-elements: arg 3: expected block, native or nil")
			}
			arg0Val.ReadElements(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//reset": {
		Doc:   "(*colorm.ColorM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//reset: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-colorm-color-m//rotate-hue": {
		Doc:   "(*colorm.ColorM).RotateHue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//rotate-hue: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//rotate-hue: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//rotate-hue: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//rotate-hue: arg 2: expected decimal")
			}
			arg0Val.RotateHue(arg1Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//scale": {
		Doc:   "(*colorm.ColorM).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//scale-with-color": {
		Doc:   "(*colorm.ColorM).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//set-element": {
		Doc:   "(*colorm.ColorM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//set-element: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//string": {
		Doc:   "(*colorm.ColorM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//string: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-colorm-color-m//translate": {
		Doc:   "(*colorm.ColorM).Translate",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//translate: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 5: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//blend!": {
		Doc:   "Set *colorm.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//blend?": {
		Doc:   "Get *colorm.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "ptr-ebiten-blend")
			return resObj
		},
	},
	"ptr-colorm-draw-image-options//filter!": {
		Doc:   "Set *colorm.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//filter?": {
		Doc:   "Get *colorm.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-colorm-draw-image-options//geo-m!": {
		Doc:   "Set *colorm.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//geo-m?": {
		Doc:   "Get *colorm.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.GeoM, "ptr-ebiten-geo-m")
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//address!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//address?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//anti-alias!": {
		Doc:   "Set *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//anti-alias?": {
		Doc:   "Get *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//blend!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//blend?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "ptr-ebiten-blend")
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//color-scale-mode!": {
		Doc:   "Set *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//color-scale-mode?": {
		Doc:   "Get *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//fill-rule!": {
		Doc:   "Set *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//fill-rule?": {
		Doc:   "Get *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//filter!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//filter?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-alpha!": {
		Doc:   "Set *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					self.BlendFactorDestinationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native")
					}
					self.BlendFactorDestinationAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-alpha?": {
		Doc:   "Get *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-rgb!": {
		Doc:   "Set *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					self.BlendFactorDestinationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native")
					}
					self.BlendFactorDestinationRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-rgb?": {
		Doc:   "Get *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-source-alpha!": {
		Doc:   "Set *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					self.BlendFactorSourceAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 2: expected native")
					}
					self.BlendFactorSourceAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-source-alpha?": {
		Doc:   "Get *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-source-rgb!": {
		Doc:   "Set *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natValOk {
					self.BlendFactorSourceRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 2: expected native")
					}
					self.BlendFactorSourceRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-source-rgb?": {
		Doc:   "Get *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-operation-alpha!": {
		Doc:   "Set *ebiten.Blend BlendOperationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natValOk {
					self.BlendOperationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 2: expected native")
					}
					self.BlendOperationAlpha = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-operation-alpha?": {
		Doc:   "Get *ebiten.Blend BlendOperationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-operation-rgb!": {
		Doc:   "Set *ebiten.Blend BlendOperationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natValOk {
					self.BlendOperationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 2: expected native")
					}
					self.BlendOperationRGB = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-operation-rgb?": {
		Doc:   "Get *ebiten.Blend BlendOperationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-color-m//apply": {
		Doc:   "(*ebiten.ColorM).Apply",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//apply: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//apply: arg 2: expected native")
			}
			res0 := arg0Val.Apply(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//change-hsv": {
		Doc:   "(*ebiten.ColorM).ChangeHSV",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//change-hsv: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//change-hsv: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 4: expected decimal")
			}
			arg0Val.ChangeHSV(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//concat": {
		Doc:   "(*ebiten.ColorM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//concat: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//concat: arg 1: expected native")
			}
			var arg1Val ebiten.ColorM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//concat: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//element": {
		Doc:   "(*ebiten.ColorM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//element: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//invert": {
		Doc:   "(*ebiten.ColorM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//invert: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-ebiten-color-m//is-invertible": {
		Doc:   "(*ebiten.ColorM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//is-invertible: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//reset": {
		Doc:   "(*ebiten.ColorM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//reset: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-color-m//rotate-hue": {
		Doc:   "(*ebiten.ColorM).RotateHue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 2: expected decimal")
			}
			arg0Val.RotateHue(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//scale": {
		Doc:   "(*ebiten.ColorM).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//scale-with-color": {
		Doc:   "(*ebiten.ColorM).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//set-element": {
		Doc:   "(*ebiten.ColorM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//set-element: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//string": {
		Doc:   "(*ebiten.ColorM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//string: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//translate": {
		Doc:   "(*ebiten.ColorM).Translate",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//translate: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 5: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//a": {
		Doc:   "(*ebiten.ColorScale).A",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected native")
			}
			res0 := arg0Val.A()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//b": {
		Doc:   "(*ebiten.ColorScale).B",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected native")
			}
			res0 := arg0Val.B()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//g": {
		Doc:   "(*ebiten.ColorScale).G",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected native")
			}
			res0 := arg0Val.G()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//r": {
		Doc:   "(*ebiten.ColorScale).R",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected native")
			}
			res0 := arg0Val.R()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//reset": {
		Doc:   "(*ebiten.ColorScale).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale": {
		Doc:   "(*ebiten.ColorScale).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-alpha": {
		Doc:   "(*ebiten.ColorScale).ScaleAlpha",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 2: expected decimal")
			}
			arg0Val.ScaleAlpha(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-with-color": {
		Doc:   "(*ebiten.ColorScale).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-with-color-scale": {
		Doc:   "(*ebiten.ColorScale).ScaleWithColorScale",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected native")
			}
			var arg1Val *ebiten.ColorScale
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected native")
			}
			arg0Val.ScaleWithColorScale(*arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-a": {
		Doc:   "(*ebiten.ColorScale).SetA",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-a: arg 2: expected decimal")
			}
			arg0Val.SetA(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-b": {
		Doc:   "(*ebiten.ColorScale).SetB",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-b: arg 2: expected decimal")
			}
			arg0Val.SetB(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-g": {
		Doc:   "(*ebiten.ColorScale).SetG",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-g: arg 2: expected decimal")
			}
			arg0Val.SetG(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-r": {
		Doc:   "(*ebiten.ColorScale).SetR",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-r: arg 2: expected decimal")
			}
			arg0Val.SetR(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//string": {
		Doc:   "(*ebiten.ColorScale).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-debug-info//graphics-library!": {
		Doc:   "Set *ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 1: expected native of type *ebiten.DebugInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-debug-info//graphics-library?": {
		Doc:   "Get *ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library?: arg 1: expected native of type *ebiten.DebugInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-debug-info//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//blend!": {
		Doc:   "Set *ebiten.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//blend?": {
		Doc:   "Get *ebiten.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "ptr-ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//color-m!": {
		Doc:   "Set *ebiten.DrawImageOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//color-m?": {
		Doc:   "Get *ebiten.DrawImageOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//color-scale!": {
		Doc:   "Set *ebiten.DrawImageOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//color-scale?": {
		Doc:   "Get *ebiten.DrawImageOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorScale, "ptr-ebiten-color-scale")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//composite-mode!": {
		Doc:   "Set *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//composite-mode?": {
		Doc:   "Get *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//filter!": {
		Doc:   "Set *ebiten.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//filter?": {
		Doc:   "Get *ebiten.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//geo-m!": {
		Doc:   "Set *ebiten.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//geo-m?": {
		Doc:   "Get *ebiten.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.GeoM, "ptr-ebiten-geo-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//address!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//address?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//anti-alias!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//anti-alias?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//blend!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//blend?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "ptr-ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//color-m!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//color-m?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//color-scale-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//color-scale-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//composite-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//composite-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//fill-rule!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//fill-rule?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//filter!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//filter?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-geo-m//apply": {
		Doc:   "(*ebiten.GeoM).Apply",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//apply: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//apply: arg 3: expected decimal")
			}
			res0, res1 := arg0Val.Apply(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-ebiten-geo-m//concat": {
		Doc:   "(*ebiten.GeoM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected native")
			}
			var arg1Val *ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(*arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//element": {
		Doc:   "(*ebiten.GeoM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//invert": {
		Doc:   "(*ebiten.GeoM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-ebiten-geo-m//is-invertible": {
		Doc:   "(*ebiten.GeoM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//reset": {
		Doc:   "(*ebiten.GeoM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-geo-m//rotate": {
		Doc:   "(*ebiten.GeoM).Rotate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//rotate: arg 2: expected decimal")
			}
			arg0Val.Rotate(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//scale": {
		Doc:   "(*ebiten.GeoM).Scale",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//scale: arg 3: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//set-element": {
		Doc:   "(*ebiten.GeoM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//skew": {
		Doc:   "(*ebiten.GeoM).Skew",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//skew: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//skew: arg 3: expected decimal")
			}
			arg0Val.Skew(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//string": {
		Doc:   "(*ebiten.GeoM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//translate": {
		Doc:   "(*ebiten.GeoM).Translate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//translate: arg 3: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-image//at": {
		Doc:   "(*ebiten.Image).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//at: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-ebiten-image//bounds": {
		Doc:   "(*ebiten.Image).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//bounds: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-ebiten-image//clear": {
		Doc:   "(*ebiten.Image).Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//clear: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//clear: arg 1: expected native")
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"ptr-ebiten-image//color-model": {
		Doc:   "(*ebiten.Image).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//color-model: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-ebiten-image//deallocate": {
		Doc:   "(*ebiten.Image).Deallocate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//deallocate: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//deallocate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//deallocate: arg 1: expected native")
			}
			arg0Val.Deallocate()
			return arg0
		},
	},
	"ptr-ebiten-image//dispose": {
		Doc:   "(*ebiten.Image).Dispose",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//dispose: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//dispose: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//dispose: arg 1: expected native")
			}
			arg0Val.Dispose()
			return arg0
		},
	},
	"ptr-ebiten-image//draw-image": {
		Doc:   "(*ebiten.Image).DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected native")
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected native")
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-image//draw-rect-shader": {
		Doc:   "(*ebiten.Image).DrawRectShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 3: expected integer")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawRectShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawRectShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 5: expected native of type *ebiten.DrawRectShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-rect-shader: arg 5: expected native")
			}
			arg0Val.DrawRectShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-image//draw-triangles": {
		Doc:   "(*ebiten.Image).DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected native")
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-image//draw-triangles-shader": {
		Doc:   "(*ebiten.Image).DrawTrianglesShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 5: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles-shader: arg 5: expected native")
			}
			arg0Val.DrawTrianglesShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-image//fill": {
		Doc:   "(*ebiten.Image).Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//fill: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//fill: arg 2: expected native")
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-image//read-pixels": {
		Doc:   "(*ebiten.Image).ReadPixels",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//read-pixels: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//read-pixels: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//read-pixels: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-image//read-pixels: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//read-pixels: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//read-pixels: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//read-pixels: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//read-pixels: arg 2: expected block, native or nil")
			}
			arg0Val.ReadPixels(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-image//replace-pixels": {
		Doc:   "(*ebiten.Image).ReplacePixels",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//replace-pixels: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//replace-pixels: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//replace-pixels: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-image//replace-pixels: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//replace-pixels: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//replace-pixels: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//replace-pixels: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//replace-pixels: arg 2: expected block, native or nil")
			}
			arg0Val.ReplacePixels(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-image//rgba-64-at": {
		Doc:   "(*ebiten.Image).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//rgba-64-at: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-ebiten-image//set": {
		Doc:   "(*ebiten.Image).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//set: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-image//size": {
		Doc:   "(*ebiten.Image).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//size: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-ebiten-image//sub-image": {
		Doc:   "(*ebiten.Image).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//sub-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-ebiten-image//write-pixels": {
		Doc:   "(*ebiten.Image).WritePixels",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//write-pixels: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//write-pixels: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//write-pixels: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-image//write-pixels: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//write-pixels: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//write-pixels: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//write-pixels: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//write-pixels: arg 2: expected block, native or nil")
			}
			arg0Val.WritePixels(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-key//unmarshal-text": {
		Doc:   "(*ebiten.Key).UnmarshalText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Key
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected native of type *ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected block, native or nil")
			}
			resErr := arg0Val.UnmarshalText(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-ebiten-monitor-type//device-scale-factor": {
		Doc:   "(*ebiten.MonitorType).DeviceScaleFactor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected native")
			}
			res0 := arg0Val.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//name": {
		Doc:   "(*ebiten.MonitorType).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//size": {
		Doc:   "(*ebiten.MonitorType).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-ebiten-new-image-from-image-options//preserve-bounds!": {
		Doc:   "Set *ebiten.NewImageFromImageOptions PreserveBounds value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.NewImageFromImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds!: arg 1: expected native of type *ebiten.NewImageFromImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.PreserveBounds = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-new-image-from-image-options//preserve-bounds?": {
		Doc:   "Get *ebiten.NewImageFromImageOptions PreserveBounds value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.NewImageFromImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds?: arg 1: expected native of type *ebiten.NewImageFromImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-from-image-options//preserve-bounds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.PreserveBounds))
			return resObj
		},
	},
	"ptr-ebiten-new-image-from-image-options//unmanaged!": {
		Doc:   "Set *ebiten.NewImageFromImageOptions Unmanaged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.NewImageFromImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged!: arg 1: expected native of type *ebiten.NewImageFromImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Unmanaged = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-new-image-from-image-options//unmanaged?": {
		Doc:   "Get *ebiten.NewImageFromImageOptions Unmanaged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageFromImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.NewImageFromImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged?: arg 1: expected native of type *ebiten.NewImageFromImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-from-image-options//unmanaged?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Unmanaged))
			return resObj
		},
	},
	"ptr-ebiten-new-image-options//unmanaged!": {
		Doc:   "Set *ebiten.NewImageOptions Unmanaged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.NewImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-options//unmanaged!: arg 1: expected native of type *ebiten.NewImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-options//unmanaged!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-options//unmanaged!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Unmanaged = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-options//unmanaged!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-new-image-options//unmanaged?": {
		Doc:   "Get *ebiten.NewImageOptions Unmanaged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.NewImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.NewImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-options//unmanaged?: arg 1: expected native of type *ebiten.NewImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-new-image-options//unmanaged?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-new-image-options//unmanaged?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Unmanaged))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//graphics-library!": {
		Doc:   "Set *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//graphics-library?": {
		Doc:   "Get *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//init-unfocused!": {
		Doc:   "Set *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.InitUnfocused = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//init-unfocused?": {
		Doc:   "Get *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.InitUnfocused))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//screen-transparent!": {
		Doc:   "Set *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScreenTransparent = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//screen-transparent?": {
		Doc:   "Get *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScreenTransparent))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//single-thread!": {
		Doc:   "Set *ebiten.RunGameOptions SingleThread value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SingleThread = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//single-thread?": {
		Doc:   "Get *ebiten.RunGameOptions SingleThread value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleThread))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//skip-taskbar!": {
		Doc:   "Set *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SkipTaskbar = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//skip-taskbar?": {
		Doc:   "Get *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SkipTaskbar))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//x-11-class-name!": {
		Doc:   "Set *ebiten.RunGameOptions X11ClassName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11ClassName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//x-11-class-name?": {
		Doc:   "Get *ebiten.RunGameOptions X11ClassName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11ClassName)
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//x-11-instance-name!": {
		Doc:   "Set *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11InstanceName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//x-11-instance-name?": {
		Doc:   "Get *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11InstanceName)
			return resObj
		},
	},
	"ptr-ebiten-shader//deallocate": {
		Doc:   "(*ebiten.Shader).Deallocate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected native")
			}
			arg0Val.Deallocate()
			return arg0
		},
	},
	"ptr-ebiten-shader//dispose": {
		Doc:   "(*ebiten.Shader).Dispose",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected native")
			}
			arg0Val.Dispose()
			return arg0
		},
	},
	"ptr-ebiten-text-glyph//image!": {
		Doc:   "Set *ebiten_text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//image!: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-text-glyph//image?": {
		Doc:   "Get *ebiten_text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//image?: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"ptr-ebiten-text-glyph//rune!": {
		Doc:   "Set *ebiten_text.Glyph Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//rune!: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//rune!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-text-glyph//rune?": {
		Doc:   "Get *ebiten_text.Glyph Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//rune?: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//rune?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"ptr-ebiten-text-glyph//x!": {
		Doc:   "Set *ebiten_text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//x!: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-text-glyph//x?": {
		Doc:   "Get *ebiten_text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//x?: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-ebiten-text-glyph//y!": {
		Doc:   "Set *ebiten_text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//y!: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-text-glyph//y?": {
		Doc:   "Get *ebiten_text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten_text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten_text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//y?: arg 1: expected native of type *ebiten_text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-text-glyph//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-text-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-a!": {
		Doc:   "Set *ebiten.Vertex ColorA value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorA = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-a!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-a?": {
		Doc:   "Get *ebiten.Vertex ColorA value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorA))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-b!": {
		Doc:   "Set *ebiten.Vertex ColorB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorB = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-b!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-b?": {
		Doc:   "Get *ebiten.Vertex ColorB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorB))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-g!": {
		Doc:   "Set *ebiten.Vertex ColorG value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorG = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-g!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-g?": {
		Doc:   "Get *ebiten.Vertex ColorG value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorG))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-r!": {
		Doc:   "Set *ebiten.Vertex ColorR value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorR = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-r!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-r?": {
		Doc:   "Get *ebiten.Vertex ColorR value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorR))
			return resObj
		},
	},
	"ptr-ebiten-vertex//dst-x!": {
		Doc:   "Set *ebiten.Vertex DstX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//dst-x?": {
		Doc:   "Get *ebiten.Vertex DstX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstX))
			return resObj
		},
	},
	"ptr-ebiten-vertex//dst-y!": {
		Doc:   "Set *ebiten.Vertex DstY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//dst-y?": {
		Doc:   "Get *ebiten.Vertex DstY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstY))
			return resObj
		},
	},
	"ptr-ebiten-vertex//src-x!": {
		Doc:   "Set *ebiten.Vertex SrcX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//src-x?": {
		Doc:   "Get *ebiten.Vertex SrcX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcX))
			return resObj
		},
	},
	"ptr-ebiten-vertex//src-y!": {
		Doc:   "Set *ebiten.Vertex SrcY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//src-y?": {
		Doc:   "Get *ebiten.Vertex SrcY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcY))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//duration!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//duration?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//strong-magnitude!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrongMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//strong-magnitude?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrongMagnitude))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//weak-magnitude!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.WeakMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//weak-magnitude?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeakMagnitude))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-options//duration!": {
		Doc:   "Set *ebiten.VibrateOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-options//duration?": {
		Doc:   "Get *ebiten.VibrateOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-ebiten-vibrate-options//magnitude!": {
		Doc:   "Set *ebiten.VibrateOptions Magnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Magnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-options//magnitude?": {
		Doc:   "Get *ebiten.VibrateOptions Magnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Magnitude))
			return resObj
		},
	},
	"ptr-gif-gif//background-index!": {
		Doc:   "Set *gif.GIF BackgroundIndex value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//background-index!: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//background-index!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//background-index!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BackgroundIndex, ok = v.Value.(byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//background-index!: arg 2: expected native of type byte")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//background-index!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-gif-gif//background-index?": {
		Doc:   "Get *gif.GIF BackgroundIndex value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//background-index?: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//background-index?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//background-index?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BackgroundIndex, "byte")
			return resObj
		},
	},
	"ptr-gif-gif//config!": {
		Doc:   "Set *gif.GIF Config value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//config!: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//config!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//config!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Config, ok = v.Value.(image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//config!: arg 2: expected native of type image.Config")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//config!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-gif-gif//config?": {
		Doc:   "Get *gif.GIF Config value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//config?: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//config?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//config?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Config, "ptr-image-config")
			return resObj
		},
	},
	"ptr-gif-gif//delay!": {
		Doc:   "Set *gif.GIF Delay value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//delay!: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//delay!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//delay!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Delay = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Delay[i] = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-gif-gif//delay!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Delay, ok = v.Value.([]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//delay!: arg 2: expected native of type []int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//delay!: arg 2: expected integer to be 0 or nil")
				}
				self.Delay = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//delay!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-gif-gif//delay?": {
		Doc:   "Get *gif.GIF Delay value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//delay?: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//delay?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//delay?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Delay))
				for i, it := range self.Delay {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-gif-gif//disposal!": {
		Doc:   "Set *gif.GIF Disposal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//disposal!: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//disposal!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//disposal!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Disposal = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Disposal[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-gif-gif//disposal!: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-gif-gif//disposal!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Disposal, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//disposal!: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//disposal!: arg 2: expected integer to be 0 or nil")
				}
				self.Disposal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//disposal!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-gif-gif//disposal?": {
		Doc:   "Get *gif.GIF Disposal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//disposal?: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//disposal?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//disposal?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Disposal))
				for i, it := range self.Disposal {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-gif-gif//image!": {
		Doc:   "Set *gif.GIF Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//image!: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Image = make([]*image.Paletted, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Image[i], ok = v.Value.(*image.Paletted)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-gif-gif//image!: arg 2: block item: expected native of type *image.Paletted")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-gif-gif//image!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Image[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-gif-gif//image!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.([]*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//image!: arg 2: expected native of type []*image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//image!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-gif-gif//image?": {
		Doc:   "Get *gif.GIF Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//image?: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//image?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Image))
				for i, it := range self.Image {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-image-paletted")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-gif-gif//loop-count!": {
		Doc:   "Set *gif.GIF LoopCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//loop-count!: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//loop-count!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//loop-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.LoopCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//loop-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-gif-gif//loop-count?": {
		Doc:   "Get *gif.GIF LoopCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.GIF
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.GIF)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//loop-count?: arg 1: expected native of type *gif.GIF")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-gif//loop-count?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-gif//loop-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.LoopCount))
			return resObj
		},
	},
	"ptr-gif-options//drawer!": {
		Doc:   "Set *gif.Options Drawer value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer!: arg 1: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//drawer!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				self.Drawer, err = ctxTo_draw_Drawer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				self.Drawer, ok = v.Value.(draw.Drawer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer!: arg 2: expected native of type draw.Drawer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer!: arg 2: expected integer to be 0 or nil")
				}
				self.Drawer = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//drawer!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-gif-options//drawer?": {
		Doc:   "Get *gif.Options Drawer value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer?: arg 1: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//drawer?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//drawer?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Drawer)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Drawer, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Drawer, "draw-drawer")
				}
			}
			return resObj
		},
	},
	"ptr-gif-options//num-colors!": {
		Doc:   "Set *gif.Options NumColors value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//num-colors!: arg 1: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//num-colors!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//num-colors!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.NumColors = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//num-colors!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-gif-options//num-colors?": {
		Doc:   "Get *gif.Options NumColors value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//num-colors?: arg 1: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//num-colors?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//num-colors?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.NumColors))
			return resObj
		},
	},
	"ptr-gif-options//quantizer!": {
		Doc:   "Set *gif.Options Quantizer value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer!: arg 1: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//quantizer!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				self.Quantizer, err = ctxTo_draw_Quantizer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				self.Quantizer, ok = v.Value.(draw.Quantizer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer!: arg 2: expected native of type draw.Quantizer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer!: arg 2: expected integer to be 0 or nil")
				}
				self.Quantizer = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//quantizer!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-gif-options//quantizer?": {
		Doc:   "Get *gif.Options Quantizer value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gif.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gif.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer?: arg 1: expected native of type *gif.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-gif-options//quantizer?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-gif-options//quantizer?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Quantizer)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Quantizer, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Quantizer, "draw-quantizer")
				}
			}
			return resObj
		},
	},
	"ptr-image-alpha-16//alpha-16-at": {
		Doc:   "(*image.Alpha16).Alpha16At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//alpha-16-at: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//alpha-16-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//alpha-16-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//alpha-16-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//alpha-16-at: arg 3: expected integer")
			}
			res0 := arg0Val.Alpha16At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-alpha-16")
			return res0Obj
		},
	},
	"ptr-image-alpha-16//at": {
		Doc:   "(*image.Alpha16).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//at: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-alpha-16//bounds": {
		Doc:   "(*image.Alpha16).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//bounds: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-alpha-16//color-model": {
		Doc:   "(*image.Alpha16).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//color-model: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-alpha-16//opaque": {
		Doc:   "(*image.Alpha16).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//opaque: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-alpha-16//pix!": {
		Doc:   "Set *image.Alpha16 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix!: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-alpha-16//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-alpha-16//pix-offset": {
		Doc:   "(*image.Alpha16).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix-offset: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-alpha-16//pix?": {
		Doc:   "Get *image.Alpha16 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix?: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-alpha-16//rect!": {
		Doc:   "Set *image.Alpha16 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rect!: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-alpha-16//rect?": {
		Doc:   "Get *image.Alpha16 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rect?: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-alpha-16//rgba-64-at": {
		Doc:   "(*image.Alpha16).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rgba-64-at: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-alpha-16//set": {
		Doc:   "(*image.Alpha16).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-alpha-16//set-alpha-16": {
		Doc:   "(*image.Alpha16).SetAlpha16",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 3: expected integer")
			}
			var arg3Val *color.Alpha16
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 4: expected native of type *color.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-alpha-16: arg 4: expected native")
			}
			arg0Val.SetAlpha16(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-alpha-16//set-rgba-64": {
		Doc:   "(*image.Alpha16).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-alpha-16//stride!": {
		Doc:   "Set *image.Alpha16 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//stride!: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-alpha-16//stride?": {
		Doc:   "Get *image.Alpha16 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//stride?: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-alpha-16//sub-image": {
		Doc:   "(*image.Alpha16).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//sub-image: arg 1: expected native of type *image.Alpha16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha-16//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha-16//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-alpha//alpha-at": {
		Doc:   "(*image.Alpha).AlphaAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//alpha-at: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//alpha-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//alpha-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//alpha-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//alpha-at: arg 3: expected integer")
			}
			res0 := arg0Val.AlphaAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-alpha")
			return res0Obj
		},
	},
	"ptr-image-alpha//at": {
		Doc:   "(*image.Alpha).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//at: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-alpha//bounds": {
		Doc:   "(*image.Alpha).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//bounds: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-alpha//color-model": {
		Doc:   "(*image.Alpha).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//color-model: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-alpha//opaque": {
		Doc:   "(*image.Alpha).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//opaque: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-alpha//pix!": {
		Doc:   "Set *image.Alpha Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix!: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-alpha//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-alpha//pix-offset": {
		Doc:   "(*image.Alpha).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix-offset: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-alpha//pix?": {
		Doc:   "Get *image.Alpha Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix?: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-alpha//rect!": {
		Doc:   "Set *image.Alpha Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rect!: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-alpha//rect?": {
		Doc:   "Get *image.Alpha Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rect?: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-alpha//rgba-64-at": {
		Doc:   "(*image.Alpha).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rgba-64-at: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-alpha//set": {
		Doc:   "(*image.Alpha).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-alpha//set-alpha": {
		Doc:   "(*image.Alpha).SetAlpha",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-alpha: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-alpha: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-alpha: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-alpha: arg 3: expected integer")
			}
			var arg3Val *color.Alpha
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-alpha: arg 4: expected native of type *color.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-alpha: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-alpha: arg 4: expected native")
			}
			arg0Val.SetAlpha(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-alpha//set-rgba-64": {
		Doc:   "(*image.Alpha).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-rgba-64: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-alpha//stride!": {
		Doc:   "Set *image.Alpha Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//stride!: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-alpha//stride?": {
		Doc:   "Get *image.Alpha Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//stride?: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-alpha//sub-image": {
		Doc:   "(*image.Alpha).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Alpha
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Alpha)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//sub-image: arg 1: expected native of type *image.Alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-alpha//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-alpha//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-cmyk//at": {
		Doc:   "(*image.CMYK).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//at: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-cmyk//bounds": {
		Doc:   "(*image.CMYK).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//bounds: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-cmyk//cmyk-at": {
		Doc:   "(*image.CMYK).CMYKAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//cmyk-at: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//cmyk-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//cmyk-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//cmyk-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//cmyk-at: arg 3: expected integer")
			}
			res0 := arg0Val.CMYKAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-cmyk")
			return res0Obj
		},
	},
	"ptr-image-cmyk//color-model": {
		Doc:   "(*image.CMYK).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//color-model: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-cmyk//opaque": {
		Doc:   "(*image.CMYK).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//opaque: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-cmyk//pix!": {
		Doc:   "Set *image.CMYK Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix!: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-cmyk//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-cmyk//pix-offset": {
		Doc:   "(*image.CMYK).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix-offset: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-cmyk//pix?": {
		Doc:   "Get *image.CMYK Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix?: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-cmyk//rect!": {
		Doc:   "Set *image.CMYK Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rect!: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-cmyk//rect?": {
		Doc:   "Get *image.CMYK Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rect?: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-cmyk//rgba-64-at": {
		Doc:   "(*image.CMYK).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rgba-64-at: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-cmyk//set": {
		Doc:   "(*image.CMYK).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-cmyk//set-cmyk": {
		Doc:   "(*image.CMYK).SetCMYK",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-cmyk: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-cmyk: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-cmyk: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-cmyk: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-cmyk: arg 3: expected integer")
			}
			var arg3Val *color.CMYK
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-cmyk: arg 4: expected native of type *color.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-cmyk: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-cmyk: arg 4: expected native")
			}
			arg0Val.SetCMYK(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-cmyk//set-rgba-64": {
		Doc:   "(*image.CMYK).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-rgba-64: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-cmyk//stride!": {
		Doc:   "Set *image.CMYK Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//stride!: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-cmyk//stride?": {
		Doc:   "Get *image.CMYK Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//stride?: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-cmyk//sub-image": {
		Doc:   "(*image.CMYK).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.CMYK
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.CMYK)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//sub-image: arg 1: expected native of type *image.CMYK")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-cmyk//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-cmyk//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-config//color-model!": {
		Doc:   "Set *image.Config ColorModel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model!: arg 1: expected native of type *image.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//color-model!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				self.ColorModel, err = ctxTo_color_Model(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				self.ColorModel, ok = v.Value.(color.Model)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model!: arg 2: expected native of type color.Model")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model!: arg 2: expected integer to be 0 or nil")
				}
				self.ColorModel = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//color-model!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-config//color-model?": {
		Doc:   "Get *image.Config ColorModel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model?: arg 1: expected native of type *image.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//color-model?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//color-model?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.ColorModel)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, self.ColorModel, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.ColorModel, "color-model")
				}
			}
			return resObj
		},
	},
	"ptr-image-config//height!": {
		Doc:   "Set *image.Config Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//height!: arg 1: expected native of type *image.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//height!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Height = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//height!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-config//height?": {
		Doc:   "Get *image.Config Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//height?: arg 1: expected native of type *image.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Height))
			return resObj
		},
	},
	"ptr-image-config//width!": {
		Doc:   "Set *image.Config Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//width!: arg 1: expected native of type *image.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Width = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//width!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-config//width?": {
		Doc:   "Get *image.Config Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//width?: arg 1: expected native of type *image.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-config//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-config//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Width))
			return resObj
		},
	},
	"ptr-image-gray-16//at": {
		Doc:   "(*image.Gray16).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//at: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-gray-16//bounds": {
		Doc:   "(*image.Gray16).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//bounds: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-gray-16//color-model": {
		Doc:   "(*image.Gray16).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//color-model: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-gray-16//gray-16-at": {
		Doc:   "(*image.Gray16).Gray16At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//gray-16-at: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//gray-16-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//gray-16-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//gray-16-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//gray-16-at: arg 3: expected integer")
			}
			res0 := arg0Val.Gray16At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-gray-16")
			return res0Obj
		},
	},
	"ptr-image-gray-16//opaque": {
		Doc:   "(*image.Gray16).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//opaque: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-gray-16//pix!": {
		Doc:   "Set *image.Gray16 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix!: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-gray-16//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-gray-16//pix-offset": {
		Doc:   "(*image.Gray16).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix-offset: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-gray-16//pix?": {
		Doc:   "Get *image.Gray16 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix?: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-gray-16//rect!": {
		Doc:   "Set *image.Gray16 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rect!: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-gray-16//rect?": {
		Doc:   "Get *image.Gray16 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rect?: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-gray-16//rgba-64-at": {
		Doc:   "(*image.Gray16).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rgba-64-at: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-gray-16//set": {
		Doc:   "(*image.Gray16).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-gray-16//set-gray-16": {
		Doc:   "(*image.Gray16).SetGray16",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-gray-16: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-gray-16: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-gray-16: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-gray-16: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-gray-16: arg 3: expected integer")
			}
			var arg3Val *color.Gray16
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-gray-16: arg 4: expected native of type *color.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-gray-16: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-gray-16: arg 4: expected native")
			}
			arg0Val.SetGray16(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-gray-16//set-rgba-64": {
		Doc:   "(*image.Gray16).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-rgba-64: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-gray-16//stride!": {
		Doc:   "Set *image.Gray16 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//stride!: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-gray-16//stride?": {
		Doc:   "Get *image.Gray16 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//stride?: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-gray-16//sub-image": {
		Doc:   "(*image.Gray16).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray16
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//sub-image: arg 1: expected native of type *image.Gray16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray-16//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray-16//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-gray//at": {
		Doc:   "(*image.Gray).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//at: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-gray//bounds": {
		Doc:   "(*image.Gray).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//bounds: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-gray//color-model": {
		Doc:   "(*image.Gray).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//color-model: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-gray//gray-at": {
		Doc:   "(*image.Gray).GrayAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//gray-at: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//gray-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//gray-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//gray-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//gray-at: arg 3: expected integer")
			}
			res0 := arg0Val.GrayAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-gray")
			return res0Obj
		},
	},
	"ptr-image-gray//opaque": {
		Doc:   "(*image.Gray).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//opaque: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-gray//pix!": {
		Doc:   "Set *image.Gray Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix!: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-gray//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-gray//pix-offset": {
		Doc:   "(*image.Gray).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix-offset: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-gray//pix?": {
		Doc:   "Get *image.Gray Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix?: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-gray//rect!": {
		Doc:   "Set *image.Gray Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rect!: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-gray//rect?": {
		Doc:   "Get *image.Gray Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rect?: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-gray//rgba-64-at": {
		Doc:   "(*image.Gray).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rgba-64-at: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-gray//set": {
		Doc:   "(*image.Gray).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-gray//set-gray": {
		Doc:   "(*image.Gray).SetGray",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-gray: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-gray: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-gray: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-gray: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-gray: arg 3: expected integer")
			}
			var arg3Val *color.Gray
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-gray: arg 4: expected native of type *color.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-gray: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-gray: arg 4: expected native")
			}
			arg0Val.SetGray(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-gray//set-rgba-64": {
		Doc:   "(*image.Gray).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-rgba-64: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-gray//stride!": {
		Doc:   "Set *image.Gray Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//stride!: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-gray//stride?": {
		Doc:   "Get *image.Gray Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//stride?: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-gray//sub-image": {
		Doc:   "(*image.Gray).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Gray
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Gray)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//sub-image: arg 1: expected native of type *image.Gray")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-gray//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-gray//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//at": {
		Doc:   "(*image.NRGBA64).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//at: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//bounds": {
		Doc:   "(*image.NRGBA64).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//bounds: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//color-model": {
		Doc:   "(*image.NRGBA64).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//color-model: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//nrgba-64-at": {
		Doc:   "(*image.NRGBA64).NRGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//nrgba-64-at: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//nrgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//nrgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//nrgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//nrgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.NRGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-nrgba-64")
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//opaque": {
		Doc:   "(*image.NRGBA64).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//opaque: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//pix!": {
		Doc:   "Set *image.NRGBA64 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix!: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-nrgba-64//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-nrgba-64//pix-offset": {
		Doc:   "(*image.NRGBA64).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix-offset: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//pix?": {
		Doc:   "Get *image.NRGBA64 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix?: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-nrgba-64//rect!": {
		Doc:   "Set *image.NRGBA64 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rect!: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-nrgba-64//rect?": {
		Doc:   "Get *image.NRGBA64 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rect?: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-nrgba-64//rgba-64-at": {
		Doc:   "(*image.NRGBA64).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rgba-64-at: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-nrgba-64//set": {
		Doc:   "(*image.NRGBA64).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-nrgba-64//set-nrgba-64": {
		Doc:   "(*image.NRGBA64).SetNRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 3: expected integer")
			}
			var arg3Val *color.NRGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 4: expected native of type *color.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-nrgba-64: arg 4: expected native")
			}
			arg0Val.SetNRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-nrgba-64//set-rgba-64": {
		Doc:   "(*image.NRGBA64).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-nrgba-64//stride!": {
		Doc:   "Set *image.NRGBA64 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//stride!: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-nrgba-64//stride?": {
		Doc:   "Get *image.NRGBA64 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//stride?: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-nrgba-64//sub-image": {
		Doc:   "(*image.NRGBA64).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//sub-image: arg 1: expected native of type *image.NRGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba-64//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba-64//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-nrgba//at": {
		Doc:   "(*image.NRGBA).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//at: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-nrgba//bounds": {
		Doc:   "(*image.NRGBA).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//bounds: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-nrgba//color-model": {
		Doc:   "(*image.NRGBA).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//color-model: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-nrgba//nrgba-at": {
		Doc:   "(*image.NRGBA).NRGBAAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//nrgba-at: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//nrgba-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//nrgba-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//nrgba-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//nrgba-at: arg 3: expected integer")
			}
			res0 := arg0Val.NRGBAAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-nrgba")
			return res0Obj
		},
	},
	"ptr-image-nrgba//opaque": {
		Doc:   "(*image.NRGBA).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//opaque: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-nrgba//pix!": {
		Doc:   "Set *image.NRGBA Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix!: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-nrgba//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-nrgba//pix-offset": {
		Doc:   "(*image.NRGBA).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix-offset: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-nrgba//pix?": {
		Doc:   "Get *image.NRGBA Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix?: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-nrgba//rect!": {
		Doc:   "Set *image.NRGBA Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rect!: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-nrgba//rect?": {
		Doc:   "Get *image.NRGBA Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rect?: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-nrgba//rgba-64-at": {
		Doc:   "(*image.NRGBA).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rgba-64-at: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-nrgba//set": {
		Doc:   "(*image.NRGBA).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-nrgba//set-nrgba": {
		Doc:   "(*image.NRGBA).SetNRGBA",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-nrgba: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-nrgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-nrgba: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-nrgba: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-nrgba: arg 3: expected integer")
			}
			var arg3Val *color.NRGBA
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-nrgba: arg 4: expected native of type *color.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-nrgba: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-nrgba: arg 4: expected native")
			}
			arg0Val.SetNRGBA(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-nrgba//set-rgba-64": {
		Doc:   "(*image.NRGBA).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-rgba-64: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-nrgba//stride!": {
		Doc:   "Set *image.NRGBA Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//stride!: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-nrgba//stride?": {
		Doc:   "Get *image.NRGBA Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//stride?: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-nrgba//sub-image": {
		Doc:   "(*image.NRGBA).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//sub-image: arg 1: expected native of type *image.NRGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-nrgba//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-nrgba//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//a!": {
		Doc:   "Set *image.NYCbCrA A value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.A = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.A[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.A, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 2: expected integer to be 0 or nil")
				}
				self.A = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//a-offset": {
		Doc:   "(*image.NYCbCrA).AOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a-offset: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a-offset: arg 3: expected integer")
			}
			res0 := arg0Val.AOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//a-stride!": {
		Doc:   "Set *image.NYCbCrA AStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a-stride!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a-stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a-stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AStride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a-stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//a-stride?": {
		Doc:   "Get *image.NYCbCrA AStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a-stride?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a-stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a-stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.AStride))
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//a?": {
		Doc:   "Get *image.NYCbCrA A value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//a?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.A))
				for i, it := range self.A {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//at": {
		Doc:   "(*image.NYCbCrA).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//at: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//bounds": {
		Doc:   "(*image.NYCbCrA).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//bounds: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//c-offset": {
		Doc:   "(*image.NYCbCrA).COffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//c-offset: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//c-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//c-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//c-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//c-offset: arg 3: expected integer")
			}
			res0 := arg0Val.COffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//c-stride!": {
		Doc:   "Set *image.NYCbCrA CStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//c-stride!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//c-stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//c-stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CStride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//c-stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//c-stride?": {
		Doc:   "Get *image.NYCbCrA CStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//c-stride?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//c-stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//c-stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CStride))
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//cb!": {
		Doc:   "Set *image.NYCbCrA Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cb = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Cb[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Cb, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 2: expected integer to be 0 or nil")
				}
				self.Cb = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//cb!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//cb?": {
		Doc:   "Get *image.NYCbCrA Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cb?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//cb?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cb))
				for i, it := range self.Cb {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//color-model": {
		Doc:   "(*image.NYCbCrA).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//color-model: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//cr!": {
		Doc:   "Set *image.NYCbCrA Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cr = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Cr[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Cr, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 2: expected integer to be 0 or nil")
				}
				self.Cr = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//cr!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//cr?": {
		Doc:   "Get *image.NYCbCrA Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cr?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//cr?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//cr?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cr))
				for i, it := range self.Cr {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//ny-cb-cr-a-at": {
		Doc:   "(*image.NYCbCrA).NYCbCrAAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//ny-cb-cr-a-at: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//ny-cb-cr-a-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//ny-cb-cr-a-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//ny-cb-cr-a-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//ny-cb-cr-a-at: arg 3: expected integer")
			}
			res0 := arg0Val.NYCbCrAAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-ny-cb-cr-a")
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//opaque": {
		Doc:   "(*image.NYCbCrA).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//opaque: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//rect!": {
		Doc:   "Set *image.NYCbCrA Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rect!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//rect?": {
		Doc:   "Get *image.NYCbCrA Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rect?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//rgba-64-at": {
		Doc:   "(*image.NYCbCrA).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rgba-64-at: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//sub-image": {
		Doc:   "(*image.NYCbCrA).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//sub-image: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//subsample-ratio!": {
		Doc:   "Set *image.NYCbCrA SubsampleRatio value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					self.SubsampleRatio = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio!: arg 2: expected integer")
					}
					self.SubsampleRatio = image.YCbCrSubsampleRatio(u)
				}
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//subsample-ratio?": {
		Doc:   "Get *image.NYCbCrA SubsampleRatio value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//subsample-ratio?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SubsampleRatio)))
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//y!": {
		Doc:   "Set *image.NYCbCrA Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Y = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Y[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Y, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 2: expected integer to be 0 or nil")
				}
				self.Y = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//y-cb-cr-at": {
		Doc:   "(*image.NYCbCrA).YCbCrAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-cb-cr-at: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-cb-cr-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-cb-cr-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-cb-cr-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-cb-cr-at: arg 3: expected integer")
			}
			res0 := arg0Val.YCbCrAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-y-cb-cr")
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//y-offset": {
		Doc:   "(*image.NYCbCrA).YOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-offset: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-offset: arg 3: expected integer")
			}
			res0 := arg0Val.YOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-ny-cb-cr-a//y-stride!": {
		Doc:   "Set *image.NYCbCrA YStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-stride!: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.YStride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-ny-cb-cr-a//y-stride?": {
		Doc:   "Get *image.NYCbCrA YStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-stride?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y-stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y-stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.YStride))
			return resObj
		},
	},
	"ptr-image-ny-cb-cr-a//y?": {
		Doc:   "Get *image.NYCbCrA Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.NYCbCrA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.NYCbCrA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y?: arg 1: expected native of type *image.NYCbCrA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-ny-cb-cr-a//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-ny-cb-cr-a//y?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Y))
				for i, it := range self.Y {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-paletted//at": {
		Doc:   "(*image.Paletted).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//at: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-paletted//bounds": {
		Doc:   "(*image.Paletted).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//bounds: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-paletted//color-index-at": {
		Doc:   "(*image.Paletted).ColorIndexAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//color-index-at: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//color-index-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//color-index-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//color-index-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//color-index-at: arg 3: expected integer")
			}
			res0 := arg0Val.ColorIndexAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-paletted//color-model": {
		Doc:   "(*image.Paletted).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//color-model: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-paletted//opaque": {
		Doc:   "(*image.Paletted).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//opaque: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-paletted//palette!": {
		Doc:   "Set *image.Paletted Palette value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//palette!: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//palette!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//palette!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal color.Palette
				if natOk {
					natVal, natValOk = nat.Value.(color.Palette)
				}
				if natValOk {
					self.Palette = natVal
				} else {
					var u []color.Color
					switch v := arg1.(type) {
					case env.Block:
						u = make([]color.Color, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.RyeCtx:
								var err error
								u[i], err = ctxTo_color_Color(ps, v)
								if err != nil {
									ps.FailureFlag = true
									return env.NewError("ptr-image-paletted//palette!: arg 2: block item: " + err.Error() + "")
								}
							case env.Native:
								var ok bool
								u[i], ok = v.Value.(color.Color)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("ptr-image-paletted//palette!: arg 2: block item: expected native of type color.Color")
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("ptr-image-paletted//palette!: arg 2: block item: expected integer to be 0 or nil")
								}
								u[i] = nil
							default:
								ps.FailureFlag = true
								return env.NewError("ptr-image-paletted//palette!: arg 2: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						u, ok = v.Value.([]color.Color)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-image-paletted//palette!: arg 2: expected native of type []color.Color")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-image-paletted//palette!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-image-paletted//palette!: arg 2: expected block, native or nil")
					}
					self.Palette = color.Palette(u)
				}
			}
			return arg0
		},
	},
	"ptr-image-paletted//palette?": {
		Doc:   "Get *image.Paletted Palette value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//palette?: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//palette?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//palette?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len([]color.Color(self.Palette)))
				for i, it := range []color.Color(self.Palette) {
					{
						typ := reflect.TypeOf(it)
						var typRyeName string
						var ok bool
						if typ != nil {
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						}
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "color-color")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-paletted//pix!": {
		Doc:   "Set *image.Paletted Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix!: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-paletted//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-paletted//pix-offset": {
		Doc:   "(*image.Paletted).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix-offset: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-paletted//pix?": {
		Doc:   "Get *image.Paletted Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix?: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-paletted//rect!": {
		Doc:   "Set *image.Paletted Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rect!: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-paletted//rect?": {
		Doc:   "Get *image.Paletted Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rect?: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-paletted//rgba-64-at": {
		Doc:   "(*image.Paletted).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rgba-64-at: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-paletted//set": {
		Doc:   "(*image.Paletted).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-paletted//set-color-index": {
		Doc:   "(*image.Paletted).SetColorIndex",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set-color-index: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set-color-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-color-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-color-index: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-color-index: arg 3: expected integer")
			}
			var arg3Val uint8
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = uint8(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-color-index: arg 4: expected integer")
			}
			arg0Val.SetColorIndex(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-paletted//set-rgba-64": {
		Doc:   "(*image.Paletted).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set-rgba-64: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-paletted//stride!": {
		Doc:   "Set *image.Paletted Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//stride!: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-paletted//stride?": {
		Doc:   "Get *image.Paletted Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//stride?: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-paletted//sub-image": {
		Doc:   "(*image.Paletted).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Paletted
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Paletted)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//sub-image: arg 1: expected native of type *image.Paletted")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-paletted//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-paletted//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-point//x!": {
		Doc:   "Set *image.Point X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//x!: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-point//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.X = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-point//x!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-point//x?": {
		Doc:   "Get *image.Point X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//x?: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-point//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.X))
			return resObj
		},
	},
	"ptr-image-point//y!": {
		Doc:   "Set *image.Point Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//y!: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-point//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Y = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-point//y!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-point//y?": {
		Doc:   "Get *image.Point Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//y?: arg 1: expected native of type *image.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-point//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-point//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"ptr-image-rectangle//max!": {
		Doc:   "Set *image.Rectangle Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//max!: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//max!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rectangle//max!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Max, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//max!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rectangle//max!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-rectangle//max?": {
		Doc:   "Get *image.Rectangle Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//max?: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//max?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rectangle//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Max, "ptr-image-point")
			return resObj
		},
	},
	"ptr-image-rectangle//min!": {
		Doc:   "Set *image.Rectangle Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//min!: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//min!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rectangle//min!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Min, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//min!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rectangle//min!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-rectangle//min?": {
		Doc:   "Get *image.Rectangle Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//min?: arg 1: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rectangle//min?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rectangle//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Min, "ptr-image-point")
			return resObj
		},
	},
	"ptr-image-rgba-64//at": {
		Doc:   "(*image.RGBA64).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//at: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-rgba-64//bounds": {
		Doc:   "(*image.RGBA64).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//bounds: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-rgba-64//color-model": {
		Doc:   "(*image.RGBA64).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//color-model: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-rgba-64//opaque": {
		Doc:   "(*image.RGBA64).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//opaque: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-rgba-64//pix!": {
		Doc:   "Set *image.RGBA64 Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix!: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-rgba-64//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-rgba-64//pix-offset": {
		Doc:   "(*image.RGBA64).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix-offset: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-rgba-64//pix?": {
		Doc:   "Get *image.RGBA64 Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix?: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-rgba-64//rect!": {
		Doc:   "Set *image.RGBA64 Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rect!: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-rgba-64//rect?": {
		Doc:   "Get *image.RGBA64 Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rect?: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-rgba-64//rgba-64-at": {
		Doc:   "(*image.RGBA64).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rgba-64-at: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-rgba-64//set": {
		Doc:   "(*image.RGBA64).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-rgba-64//set-rgba-64": {
		Doc:   "(*image.RGBA64).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-rgba-64//stride!": {
		Doc:   "Set *image.RGBA64 Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//stride!: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-rgba-64//stride?": {
		Doc:   "Get *image.RGBA64 Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//stride?: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-rgba-64//sub-image": {
		Doc:   "(*image.RGBA64).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//sub-image: arg 1: expected native of type *image.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba-64//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba-64//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-rgba//at": {
		Doc:   "(*image.RGBA).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//at: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-rgba//bounds": {
		Doc:   "(*image.RGBA).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//bounds: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-rgba//color-model": {
		Doc:   "(*image.RGBA).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//color-model: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-rgba//opaque": {
		Doc:   "(*image.RGBA).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//opaque: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-rgba//pix!": {
		Doc:   "Set *image.RGBA Pix value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix!: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//pix!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Pix = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Pix[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-rgba//pix!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Pix, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix!: arg 2: expected integer to be 0 or nil")
				}
				self.Pix = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//pix!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-rgba//pix-offset": {
		Doc:   "(*image.RGBA).PixOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix-offset: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//pix-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//pix-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//pix-offset: arg 3: expected integer")
			}
			res0 := arg0Val.PixOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-rgba//pix?": {
		Doc:   "Get *image.RGBA Pix value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix?: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//pix?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//pix?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Pix))
				for i, it := range self.Pix {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-rgba//rect!": {
		Doc:   "Set *image.RGBA Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rect!: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-rgba//rect?": {
		Doc:   "Get *image.RGBA Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rect?: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-rgba//rgba-64-at": {
		Doc:   "(*image.RGBA).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rgba-64-at: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-rgba//rgba-at": {
		Doc:   "(*image.RGBA).RGBAAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rgba-at: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//rgba-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rgba-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rgba-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//rgba-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBAAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba")
			return res0Obj
		},
	},
	"ptr-image-rgba//set": {
		Doc:   "(*image.RGBA).Set",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set: arg 3: expected integer")
			}
			var arg3Val color.Color
			switch v := arg3.(type) {
			case env.RyeCtx:
				var err error
				arg3Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set: arg 4: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set: arg 4: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set: arg 4: expected native")
			}
			arg0Val.Set(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-image-rgba//set-rgba": {
		Doc:   "(*image.RGBA).SetRGBA",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba: arg 3: expected integer")
			}
			var arg3Val *color.RGBA
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba: arg 4: expected native of type *color.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba: arg 4: expected native")
			}
			arg0Val.SetRGBA(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-rgba//set-rgba-64": {
		Doc:   "(*image.RGBA).SetRGBA64",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba-64: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba-64: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba-64: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba-64: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba-64: arg 3: expected integer")
			}
			var arg3Val *color.RGBA64
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*color.RGBA64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba-64: arg 4: expected native of type *color.RGBA64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//set-rgba-64: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//set-rgba-64: arg 4: expected native")
			}
			arg0Val.SetRGBA64(arg1Val, arg2Val, *arg3Val)
			return arg0
		},
	},
	"ptr-image-rgba//stride!": {
		Doc:   "Set *image.RGBA Stride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//stride!: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Stride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-rgba//stride?": {
		Doc:   "Get *image.RGBA Stride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//stride?: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Stride))
			return resObj
		},
	},
	"ptr-image-rgba//sub-image": {
		Doc:   "(*image.RGBA).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.RGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//sub-image: arg 1: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-rgba//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-rgba//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-uniform//at": {
		Doc:   "(*image.Uniform).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//at: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-uniform//bounds": {
		Doc:   "(*image.Uniform).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//bounds: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-uniform//c!": {
		Doc:   "Set *image.Uniform C value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c!: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//c!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				self.C, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				self.C, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c!: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c!: arg 2: expected integer to be 0 or nil")
				}
				self.C = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//c!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-uniform//c?": {
		Doc:   "Get *image.Uniform C value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c?: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//c?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//c?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.C)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, self.C, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.C, "color-color")
				}
			}
			return resObj
		},
	},
	"ptr-image-uniform//color-model": {
		Doc:   "(*image.Uniform).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//color-model: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-uniform//convert": {
		Doc:   "(*image.Uniform).Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//convert: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//convert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//convert: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_color_Color(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//convert: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//convert: arg 2: expected native of type color.Color")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//convert: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//convert: arg 2: expected native")
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-uniform//opaque": {
		Doc:   "(*image.Uniform).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//opaque: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-uniform//rgba": {
		Doc:   "(*image.Uniform).RGBA",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//rgba: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//rgba: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//rgba: arg 1: expected native")
			}
			res0, res1, res2, res3 := arg0Val.RGBA()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
			}))
		},
	},
	"ptr-image-uniform//rgba-64-at": {
		Doc:   "(*image.Uniform).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.Uniform
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.Uniform)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//rgba-64-at: arg 1: expected native of type *image.Uniform")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-uniform//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-uniform//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//at": {
		Doc:   "(*image.YCbCr).At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//at: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//at: arg 3: expected integer")
			}
			res0 := arg0Val.At(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//bounds": {
		Doc:   "(*image.YCbCr).Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//bounds: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-image-rectangle")
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//c-offset": {
		Doc:   "(*image.YCbCr).COffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//c-offset: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//c-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//c-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//c-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//c-offset: arg 3: expected integer")
			}
			res0 := arg0Val.COffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//c-stride!": {
		Doc:   "Set *image.YCbCr CStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//c-stride!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//c-stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//c-stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CStride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//c-stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//c-stride?": {
		Doc:   "Get *image.YCbCr CStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//c-stride?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//c-stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//c-stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CStride))
			return resObj
		},
	},
	"ptr-image-y-cb-cr//cb!": {
		Doc:   "Set *image.YCbCr Cb value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cb!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//cb!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cb = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Cb[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-y-cb-cr//cb!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Cb, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cb!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cb!: arg 2: expected integer to be 0 or nil")
				}
				self.Cb = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//cb!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//cb?": {
		Doc:   "Get *image.YCbCr Cb value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cb?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//cb?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cb))
				for i, it := range self.Cb {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-y-cb-cr//color-model": {
		Doc:   "(*image.YCbCr).ColorModel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//color-model: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//color-model: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//color-model: arg 1: expected native")
			}
			res0 := arg0Val.ColorModel()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "color-model")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//cr!": {
		Doc:   "Set *image.YCbCr Cr value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cr!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cr!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//cr!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cr = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Cr[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-y-cb-cr//cr!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Cr, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cr!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cr!: arg 2: expected integer to be 0 or nil")
				}
				self.Cr = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//cr!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//cr?": {
		Doc:   "Get *image.YCbCr Cr value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cr?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//cr?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//cr?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cr))
				for i, it := range self.Cr {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-image-y-cb-cr//opaque": {
		Doc:   "(*image.YCbCr).Opaque",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//opaque: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//opaque: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//opaque: arg 1: expected native")
			}
			res0 := arg0Val.Opaque()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//rect!": {
		Doc:   "Set *image.YCbCr Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rect!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//rect!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rect, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//rect!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//rect?": {
		Doc:   "Get *image.YCbCr Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rect?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Rect, "ptr-image-rectangle")
			return resObj
		},
	},
	"ptr-image-y-cb-cr//rgba-64-at": {
		Doc:   "(*image.YCbCr).RGBA64At",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rgba-64-at: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//rgba-64-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//rgba-64-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//rgba-64-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//rgba-64-at: arg 3: expected integer")
			}
			res0 := arg0Val.RGBA64At(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-rgba-64")
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//sub-image": {
		Doc:   "(*image.YCbCr).SubImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//sub-image: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//sub-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//sub-image: arg 1: expected native")
			}
			var arg1Val *image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//sub-image: arg 2: expected native of type *image.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//sub-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//sub-image: arg 2: expected native")
			}
			res0 := arg0Val.SubImage(*arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
				}
			}
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//subsample-ratio!": {
		Doc:   "Set *image.YCbCr SubsampleRatio value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//subsample-ratio!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//subsample-ratio!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//subsample-ratio!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal image.YCbCrSubsampleRatio
				if natOk {
					natVal, natValOk = nat.Value.(image.YCbCrSubsampleRatio)
				}
				if natValOk {
					self.SubsampleRatio = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-y-cb-cr//subsample-ratio!: arg 2: expected integer")
					}
					self.SubsampleRatio = image.YCbCrSubsampleRatio(u)
				}
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//subsample-ratio?": {
		Doc:   "Get *image.YCbCr SubsampleRatio value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//subsample-ratio?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//subsample-ratio?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//subsample-ratio?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SubsampleRatio)))
			return resObj
		},
	},
	"ptr-image-y-cb-cr//y!": {
		Doc:   "Set *image.YCbCr Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Y = make([]uint8, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						self.Y[i] = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-image-y-cb-cr//y!: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				self.Y, ok = v.Value.([]uint8)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y!: arg 2: expected native of type []uint8")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y!: arg 2: expected integer to be 0 or nil")
				}
				self.Y = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//y-cb-cr-at": {
		Doc:   "(*image.YCbCr).YCbCrAt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-cb-cr-at: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-cb-cr-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-cb-cr-at: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-cb-cr-at: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-cb-cr-at: arg 3: expected integer")
			}
			res0 := arg0Val.YCbCrAt(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-color-y-cb-cr")
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//y-offset": {
		Doc:   "(*image.YCbCr).YOffset",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-offset: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-offset: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-offset: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-offset: arg 3: expected integer")
			}
			res0 := arg0Val.YOffset(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-image-y-cb-cr//y-stride!": {
		Doc:   "Set *image.YCbCr YStride value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-stride!: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-stride!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-stride!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.YStride = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-stride!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-image-y-cb-cr//y-stride?": {
		Doc:   "Get *image.YCbCr YStride value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-stride?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y-stride?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y-stride?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.YStride))
			return resObj
		},
	},
	"ptr-image-y-cb-cr//y?": {
		Doc:   "Get *image.YCbCr Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *image.YCbCr
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*image.YCbCr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y?: arg 1: expected native of type *image.YCbCr")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-image-y-cb-cr//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-image-y-cb-cr//y?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Y))
				for i, it := range self.Y {
					items[i] = *env.NewInteger(int64(it))
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-jpeg-options//quality!": {
		Doc:   "Set *jpeg.Options Quality value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *jpeg.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*jpeg.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-jpeg-options//quality!: arg 1: expected native of type *jpeg.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-jpeg-options//quality!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-jpeg-options//quality!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Quality = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-jpeg-options//quality!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-jpeg-options//quality?": {
		Doc:   "Get *jpeg.Options Quality value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *jpeg.Options
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*jpeg.Options)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-jpeg-options//quality?: arg 1: expected native of type *jpeg.Options")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-jpeg-options//quality?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-jpeg-options//quality?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Quality))
			return resObj
		},
	},
	"ptr-mp-3-stream//length": {
		Doc:   "(*mp3.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//length: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-mp-3-stream//read": {
		Doc:   "(*mp3.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-mp-3-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-mp-3-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-mp-3-stream//seek": {
		Doc:   "(*mp3.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//seek: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-png-encoder//buffer-pool!": {
		Doc:   "Set *png.Encoder BufferPool value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*png.Encoder)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool!: arg 1: expected native of type *png.Encoder")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//buffer-pool!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				self.BufferPool, err = ctxTo_png_EncoderBufferPool(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				self.BufferPool, ok = v.Value.(png.EncoderBufferPool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool!: arg 2: expected native of type png.EncoderBufferPool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool!: arg 2: expected integer to be 0 or nil")
				}
				self.BufferPool = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//buffer-pool!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-png-encoder//buffer-pool?": {
		Doc:   "Get *png.Encoder BufferPool value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*png.Encoder)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool?: arg 1: expected native of type *png.Encoder")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//buffer-pool?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//buffer-pool?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.BufferPool)
				var typRyeName string
				var ok bool
				if typ != nil {
					var typPfx string
					if typ.Kind() == reflect.Pointer {
						typPfx = "*"
						typ = typ.Elem()
					}
					typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				}
				if ok {
					resObj = *env.NewNative(ps.Idx, self.BufferPool, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.BufferPool, "png-encoder-buffer-pool")
				}
			}
			return resObj
		},
	},
	"ptr-png-encoder//compression-level!": {
		Doc:   "Set *png.Encoder CompressionLevel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*png.Encoder)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//compression-level!: arg 1: expected native of type *png.Encoder")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//compression-level!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//compression-level!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal png.CompressionLevel
				if natOk {
					natVal, natValOk = nat.Value.(png.CompressionLevel)
				}
				if natValOk {
					self.CompressionLevel = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-png-encoder//compression-level!: arg 2: expected integer")
					}
					self.CompressionLevel = png.CompressionLevel(u)
				}
			}
			return arg0
		},
	},
	"ptr-png-encoder//compression-level?": {
		Doc:   "Get *png.Encoder CompressionLevel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*png.Encoder)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//compression-level?: arg 1: expected native of type *png.Encoder")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//compression-level?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//compression-level?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompressionLevel)))
			return resObj
		},
	},
	"ptr-png-encoder//encode": {
		Doc:   "(*png.Encoder).Encode",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *png.Encoder
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*png.Encoder)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 1: expected native of type *png.Encoder")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//encode: arg 1: expected native")
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Writer(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 2: expected native of type io.Writer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//encode: arg 2: expected native")
			}
			var arg2Val image.Image
			switch v := arg2.(type) {
			case env.RyeCtx:
				var err error
				arg2Val, err = ctxTo_image_Image(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 3: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 3: expected native of type image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-png-encoder//encode: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-png-encoder//encode: arg 3: expected native")
			}
			resErr := arg0Val.Encode(arg1Val, arg2Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-text-draw-options//blend!": {
		Doc:   "Set *text.DrawOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//blend!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-draw-options//blend?": {
		Doc:   "Get *text.DrawOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//blend?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Blend, "ptr-ebiten-blend")
			return resObj
		},
	},
	"ptr-text-draw-options//color-m!": {
		Doc:   "Set *text.DrawOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-m!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-draw-options//color-m?": {
		Doc:   "Get *text.DrawOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-m?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-text-draw-options//color-scale!": {
		Doc:   "Set *text.DrawOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-scale!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-draw-options//color-scale?": {
		Doc:   "Get *text.DrawOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-scale?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//color-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ColorScale, "ptr-ebiten-color-scale")
			return resObj
		},
	},
	"ptr-text-draw-options//composite-mode!": {
		Doc:   "Set *text.DrawOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//composite-mode!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-draw-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-draw-options//composite-mode?": {
		Doc:   "Get *text.DrawOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//composite-mode?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-text-draw-options//filter!": {
		Doc:   "Set *text.DrawOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//filter!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-draw-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-draw-options//filter?": {
		Doc:   "Get *text.DrawOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//filter?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-text-draw-options//geo-m!": {
		Doc:   "Set *text.DrawOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//geo-m!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-draw-options//geo-m?": {
		Doc:   "Get *text.DrawOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//geo-m?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.GeoM, "ptr-ebiten-geo-m")
			return resObj
		},
	},
	"ptr-text-draw-options//line-spacing!": {
		Doc:   "Set *text.DrawOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//line-spacing!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//line-spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-draw-options//line-spacing?": {
		Doc:   "Get *text.DrawOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//line-spacing?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//line-spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"ptr-text-draw-options//primary-align!": {
		Doc:   "Set *text.DrawOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//primary-align!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//primary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-draw-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-draw-options//primary-align?": {
		Doc:   "Get *text.DrawOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//primary-align?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//primary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"ptr-text-draw-options//secondary-align!": {
		Doc:   "Set *text.DrawOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//secondary-align!: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//secondary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-draw-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-draw-options//secondary-align?": {
		Doc:   "Get *text.DrawOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//secondary-align?: arg 1: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-draw-options//secondary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-draw-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"ptr-text-glyph//end-index-in-bytes!": {
		Doc:   "Set *text.Glyph EndIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//end-index-in-bytes!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//end-index-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//end-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.EndIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//end-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-glyph//end-index-in-bytes?": {
		Doc:   "Get *text.Glyph EndIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//end-index-in-bytes?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//end-index-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//end-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.EndIndexInBytes))
			return resObj
		},
	},
	"ptr-text-glyph//gid!": {
		Doc:   "Set *text.Glyph GID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//gid!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//gid!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//gid!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.GID = uint32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//gid!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-glyph//gid?": {
		Doc:   "Get *text.Glyph GID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//gid?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//gid?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//gid?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.GID))
			return resObj
		},
	},
	"ptr-text-glyph//image!": {
		Doc:   "Set *text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-glyph//image?": {
		Doc:   "Get *text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"ptr-text-glyph//start-index-in-bytes!": {
		Doc:   "Set *text.Glyph StartIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//start-index-in-bytes!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//start-index-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//start-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StartIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//start-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-glyph//start-index-in-bytes?": {
		Doc:   "Get *text.Glyph StartIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//start-index-in-bytes?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//start-index-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//start-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StartIndexInBytes))
			return resObj
		},
	},
	"ptr-text-glyph//x!": {
		Doc:   "Set *text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-glyph//x?": {
		Doc:   "Get *text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-text-glyph//y!": {
		Doc:   "Set *text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-glyph//y?": {
		Doc:   "Get *text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-text-go-text-face-source//metadata": {
		Doc:   "(*text.GoTextFaceSource).Metadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFaceSource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face-source//metadata: arg 1: expected native of type *text.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face-source//metadata: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face-source//metadata: arg 1: expected native")
			}
			res0 := arg0Val.Metadata()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-text-metadata")
			return res0Obj
		},
	},
	"ptr-text-go-text-face-source//unsafe-internal": {
		Doc:   "(*text.GoTextFaceSource).UnsafeInternal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFaceSource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face-source//unsafe-internal: arg 1: expected native of type *text.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face-source//unsafe-internal: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face-source//unsafe-internal: arg 1: expected native")
			}
			res0 := arg0Val.UnsafeInternal()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "typesetting-font-face")
			return res0Obj
		},
	},
	"ptr-text-go-text-face//direction!": {
		Doc:   "Set *text.GoTextFace Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//direction!: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//direction!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//direction!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Direction
				if natOk {
					natVal, natValOk = nat.Value.(text.Direction)
				}
				if natValOk {
					self.Direction = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-go-text-face//direction!: arg 2: expected integer")
					}
					self.Direction = text.Direction(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-go-text-face//direction?": {
		Doc:   "Get *text.GoTextFace Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//direction?: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//direction?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//direction?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Direction)))
			return resObj
		},
	},
	"ptr-text-go-text-face//language!": {
		Doc:   "Set *text.GoTextFace Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//language!: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//language!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//language!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Language, ok = v.Value.(language.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//language!: arg 2: expected native of type language.Tag")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//language!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-go-text-face//language?": {
		Doc:   "Get *text.GoTextFace Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//language?: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//language?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//language?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Language, "language-tag")
			return resObj
		},
	},
	"ptr-text-go-text-face//metrics": {
		Doc:   "(*text.GoTextFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//metrics: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-text-metrics")
			return res0Obj
		},
	},
	"ptr-text-go-text-face//remove-feature": {
		Doc:   "(*text.GoTextFace).RemoveFeature",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//remove-feature: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//remove-feature: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//remove-feature: arg 1: expected native")
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-go-text-face//remove-feature: arg 2: expected integer")
					}
					arg1Val = text.Tag(u)
				}
			}
			arg0Val.RemoveFeature(arg1Val)
			return arg0
		},
	},
	"ptr-text-go-text-face//remove-variation": {
		Doc:   "(*text.GoTextFace).RemoveVariation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//remove-variation: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//remove-variation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//remove-variation: arg 1: expected native")
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-go-text-face//remove-variation: arg 2: expected integer")
					}
					arg1Val = text.Tag(u)
				}
			}
			arg0Val.RemoveVariation(arg1Val)
			return arg0
		},
	},
	"ptr-text-go-text-face//script!": {
		Doc:   "Set *text.GoTextFace Script value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//script!: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//script!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//script!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Script, ok = v.Value.(language.Script)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//script!: arg 2: expected native of type language.Script")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//script!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-go-text-face//script?": {
		Doc:   "Get *text.GoTextFace Script value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//script?: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//script?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//script?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Script, "language-script")
			return resObj
		},
	},
	"ptr-text-go-text-face//set-feature": {
		Doc:   "(*text.GoTextFace).SetFeature",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//set-feature: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//set-feature: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//set-feature: arg 1: expected native")
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-go-text-face//set-feature: arg 2: expected integer")
					}
					arg1Val = text.Tag(u)
				}
			}
			var arg2Val uint32
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//set-feature: arg 3: expected integer")
			}
			arg0Val.SetFeature(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-go-text-face//set-variation": {
		Doc:   "(*text.GoTextFace).SetVariation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//set-variation: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//set-variation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//set-variation: arg 1: expected native")
			}
			var arg1Val text.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-go-text-face//set-variation: arg 2: expected integer")
					}
					arg1Val = text.Tag(u)
				}
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//set-variation: arg 3: expected decimal")
			}
			arg0Val.SetVariation(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-go-text-face//size!": {
		Doc:   "Set *text.GoTextFace Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//size!: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Size = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-go-text-face//size?": {
		Doc:   "Get *text.GoTextFace Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//size?: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Size))
			return resObj
		},
	},
	"ptr-text-go-text-face//source!": {
		Doc:   "Set *text.GoTextFace Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//source!: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(*text.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//source!: arg 2: expected native of type *text.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//source!: arg 2: expected integer to be 0 or nil")
				}
				self.Source = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-go-text-face//source?": {
		Doc:   "Get *text.GoTextFace Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//source?: arg 1: expected native of type *text.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-text-face//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-text-face//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "ptr-text-go-text-face-source")
			return resObj
		},
	},
	"ptr-text-go-x-face//metrics": {
		Doc:   "(*text.GoXFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoXFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoXFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-x-face//metrics: arg 1: expected native of type *text.GoXFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-x-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-x-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-text-metrics")
			return res0Obj
		},
	},
	"ptr-text-go-x-face//unsafe-internal": {
		Doc:   "(*text.GoXFace).UnsafeInternal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.GoXFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.GoXFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-x-face//unsafe-internal: arg 1: expected native of type *text.GoXFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-go-x-face//unsafe-internal: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-go-x-face//unsafe-internal: arg 1: expected native")
			}
			res0 := arg0Val.UnsafeInternal()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "font-face")
			return res0Obj
		},
	},
	"ptr-text-layout-options//line-spacing!": {
		Doc:   "Set *text.LayoutOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//line-spacing!: arg 1: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//line-spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-layout-options//line-spacing?": {
		Doc:   "Get *text.LayoutOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//line-spacing?: arg 1: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//line-spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"ptr-text-layout-options//primary-align!": {
		Doc:   "Set *text.LayoutOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//primary-align!: arg 1: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//primary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-layout-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-layout-options//primary-align?": {
		Doc:   "Get *text.LayoutOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//primary-align?: arg 1: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//primary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"ptr-text-layout-options//secondary-align!": {
		Doc:   "Set *text.LayoutOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//secondary-align!: arg 1: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//secondary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Align
				if natOk {
					natVal, natValOk = nat.Value.(text.Align)
				}
				if natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-layout-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-layout-options//secondary-align?": {
		Doc:   "Get *text.LayoutOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//secondary-align?: arg 1: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-layout-options//secondary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-layout-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"ptr-text-limited-face//add-unicode-range": {
		Doc:   "(*text.LimitedFace).AddUnicodeRange",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.LimitedFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-limited-face//add-unicode-range: arg 1: expected native of type *text.LimitedFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-limited-face//add-unicode-range: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-limited-face//add-unicode-range: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-limited-face//add-unicode-range: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-limited-face//add-unicode-range: arg 2: expected native")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-limited-face//add-unicode-range: arg 3: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-limited-face//add-unicode-range: arg 3: expected native")
			}
			arg0Val.AddUnicodeRange(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-limited-face//metrics": {
		Doc:   "(*text.LimitedFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.LimitedFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-limited-face//metrics: arg 1: expected native of type *text.LimitedFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-limited-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-limited-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-text-metrics")
			return res0Obj
		},
	},
	"ptr-text-metadata//family!": {
		Doc:   "Set *text.Metadata Family value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//family!: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//family!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//family!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Family = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//family!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-text-metadata//family?": {
		Doc:   "Get *text.Metadata Family value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//family?: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//family?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//family?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Family)
			return resObj
		},
	},
	"ptr-text-metadata//stretch!": {
		Doc:   "Set *text.Metadata Stretch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//stretch!: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//stretch!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//stretch!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Stretch
				if natOk {
					natVal, natValOk = nat.Value.(text.Stretch)
				}
				if natValOk {
					self.Stretch = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-metadata//stretch!: arg 2: expected decimal")
					}
					self.Stretch = text.Stretch(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-metadata//stretch?": {
		Doc:   "Get *text.Metadata Stretch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//stretch?: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//stretch?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//stretch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Stretch)))
			return resObj
		},
	},
	"ptr-text-metadata//style!": {
		Doc:   "Set *text.Metadata Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//style!: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//style!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Style
				if natOk {
					natVal, natValOk = nat.Value.(text.Style)
				}
				if natValOk {
					self.Style = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-metadata//style!: arg 2: expected integer")
					}
					self.Style = text.Style(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-metadata//style?": {
		Doc:   "Get *text.Metadata Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//style?: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Style)))
			return resObj
		},
	},
	"ptr-text-metadata//weight!": {
		Doc:   "Set *text.Metadata Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//weight!: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//weight!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//weight!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Weight
				if natOk {
					natVal, natValOk = nat.Value.(text.Weight)
				}
				if natValOk {
					self.Weight = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-metadata//weight!: arg 2: expected decimal")
					}
					self.Weight = text.Weight(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-metadata//weight?": {
		Doc:   "Get *text.Metadata Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//weight?: arg 1: expected native of type *text.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metadata//weight?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metadata//weight?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Weight)))
			return resObj
		},
	},
	"ptr-text-metrics//h-ascent!": {
		Doc:   "Set *text.Metrics HAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-ascent!: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-metrics//h-ascent?": {
		Doc:   "Get *text.Metrics HAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-ascent?: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HAscent))
			return resObj
		},
	},
	"ptr-text-metrics//h-descent!": {
		Doc:   "Set *text.Metrics HDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-descent!: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-metrics//h-descent?": {
		Doc:   "Get *text.Metrics HDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-descent?: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HDescent))
			return resObj
		},
	},
	"ptr-text-metrics//h-line-gap!": {
		Doc:   "Set *text.Metrics HLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-line-gap!: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-line-gap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-metrics//h-line-gap?": {
		Doc:   "Get *text.Metrics HLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-line-gap?: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//h-line-gap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//h-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HLineGap))
			return resObj
		},
	},
	"ptr-text-metrics//v-ascent!": {
		Doc:   "Set *text.Metrics VAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-ascent!: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-metrics//v-ascent?": {
		Doc:   "Get *text.Metrics VAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-ascent?: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VAscent))
			return resObj
		},
	},
	"ptr-text-metrics//v-descent!": {
		Doc:   "Set *text.Metrics VDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-descent!: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-metrics//v-descent?": {
		Doc:   "Get *text.Metrics VDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-descent?: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VDescent))
			return resObj
		},
	},
	"ptr-text-metrics//v-line-gap!": {
		Doc:   "Set *text.Metrics VLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-line-gap!: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-line-gap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-metrics//v-line-gap?": {
		Doc:   "Get *text.Metrics VLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-line-gap?: arg 1: expected native of type *text.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-metrics//v-line-gap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-metrics//v-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VLineGap))
			return resObj
		},
	},
	"ptr-text-multi-face//metrics": {
		Doc:   "(*text.MultiFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.MultiFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.MultiFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-multi-face//metrics: arg 1: expected native of type *text.MultiFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-multi-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-multi-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-text-metrics")
			return res0Obj
		},
	},
	"ptr-textinput-field//blur": {
		Doc:   "(*textinput.Field).Blur",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//blur: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//blur: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//blur: arg 1: expected native")
			}
			arg0Val.Blur()
			return arg0
		},
	},
	"ptr-textinput-field//composition-selection": {
		Doc:   "(*textinput.Field).CompositionSelection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//composition-selection: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//composition-selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//composition-selection: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.CompositionSelection()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(boolToInt64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"ptr-textinput-field//focus": {
		Doc:   "(*textinput.Field).Focus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//focus: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//focus: arg 1: expected native")
			}
			arg0Val.Focus()
			return arg0
		},
	},
	"ptr-textinput-field//handle-input": {
		Doc:   "(*textinput.Field).HandleInput",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//handle-input: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//handle-input: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//handle-input: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//handle-input: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//handle-input: arg 3: expected integer")
			}
			res0, resErr := arg0Val.HandleInput(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-textinput-field//is-focused": {
		Doc:   "(*textinput.Field).IsFocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//is-focused: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//is-focused: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//is-focused: arg 1: expected native")
			}
			res0 := arg0Val.IsFocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-textinput-field//selection": {
		Doc:   "(*textinput.Field).Selection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//selection: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//selection: arg 1: expected native")
			}
			res0, res1 := arg0Val.Selection()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-textinput-field//set-selection": {
		Doc:   "(*textinput.Field).SetSelection",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//set-selection: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//set-selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-selection: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-selection: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-selection: arg 3: expected integer")
			}
			arg0Val.SetSelection(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-textinput-field//set-text-and-selection": {
		Doc:   "(*textinput.Field).SetTextAndSelection",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//set-text-and-selection: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//set-text-and-selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-text-and-selection: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-text-and-selection: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-text-and-selection: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//set-text-and-selection: arg 4: expected integer")
			}
			arg0Val.SetTextAndSelection(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-textinput-field//text": {
		Doc:   "(*textinput.Field).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//text: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//text: arg 1: expected native")
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-textinput-field//text-for-rendering": {
		Doc:   "(*textinput.Field).TextForRendering",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *textinput.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*textinput.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//text-for-rendering: arg 1: expected native of type *textinput.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-field//text-for-rendering: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-field//text-for-rendering: arg 1: expected native")
			}
			res0 := arg0Val.TextForRendering()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-textinput-state//committed!": {
		Doc:   "Set *textinput.State Committed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//committed!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Committed = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//committed!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//committed?": {
		Doc:   "Get *textinput.State Committed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//committed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Committed))
			return resObj
		},
	},
	"ptr-textinput-state//composition-selection-end-in-bytes!": {
		Doc:   "Set *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionEndInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//composition-selection-end-in-bytes?": {
		Doc:   "Get *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionEndInBytes))
			return resObj
		},
	},
	"ptr-textinput-state//composition-selection-start-in-bytes!": {
		Doc:   "Set *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionStartInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//composition-selection-start-in-bytes?": {
		Doc:   "Get *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionStartInBytes))
			return resObj
		},
	},
	"ptr-textinput-state//error!": {
		Doc:   "Set *textinput.State Error value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//error!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.String:
				self.Error = errors.New(v.Value)
			case env.Error:
				self.Error = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error!: arg 2: expected integer to be 0 or nil")
				}
				self.Error = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//error!: arg 2: expected error, string or nil")
			}
			return arg0
		},
	},
	"ptr-textinput-state//error?": {
		Doc:   "Get *textinput.State Error value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//error?: arg 1: expected native")
			}
			var resObj env.Object
			if self.Error != nil {
				resObj = env.NewError(self.Error.Error())
			}
			return resObj
		},
	},
	"ptr-textinput-state//text!": {
		Doc:   "Set *textinput.State Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-textinput-state//text?": {
		Doc:   "Get *textinput.State Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-twenty-48-board//draw": {
		Doc:   "(*twenty48.Board).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Board)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//draw: arg 1: expected native of type *twenty48.Board")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-board//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-board//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-twenty-48-board//move": {
		Doc:   "(*twenty48.Board).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Board)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//move: arg 1: expected native of type *twenty48.Board")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-board//move: arg 1: expected native")
			}
			var arg1Val twenty48.Dir
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-twenty-48-board//move: arg 2: expected integer")
					}
					arg1Val = twenty48.Dir(u)
				}
			}
			resErr := arg0Val.Move(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-twenty-48-board//size": {
		Doc:   "(*twenty48.Board).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Board)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//size: arg 1: expected native of type *twenty48.Board")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-board//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-twenty-48-board//update": {
		Doc:   "(*twenty48.Board).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Board
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Board)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//update: arg 1: expected native of type *twenty48.Board")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-board//update: arg 1: expected native")
			}
			var arg1Val *twenty48.Input
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//update: arg 2: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-board//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-board//update: arg 2: expected native")
			}
			resErr := arg0Val.Update(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-twenty-48-game//draw": {
		Doc:   "(*twenty48.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-twenty-48-game//layout": {
		Doc:   "(*twenty48.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//layout: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-twenty-48-game//update": {
		Doc:   "(*twenty48.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//update: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//update: arg 1: expected native")
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-twenty-48-input//dir": {
		Doc:   "(*twenty48.Input).Dir",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//dir: arg 1: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//dir: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-input//dir: arg 1: expected native")
			}
			res0, res1 := arg0Val.Dir()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-twenty-48-input//update": {
		Doc:   "(*twenty48.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//update: arg 1: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-input//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-twenty-48-tile//draw": {
		Doc:   "(*twenty48.Tile).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//draw: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-twenty-48-tile//is-moving": {
		Doc:   "(*twenty48.Tile).IsMoving",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected native")
			}
			res0 := arg0Val.IsMoving()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-twenty-48-tile//next-pos": {
		Doc:   "(*twenty48.Tile).NextPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.NextPos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-twenty-48-tile//next-value": {
		Doc:   "(*twenty48.Tile).NextValue",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected native")
			}
			res0 := arg0Val.NextValue()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-twenty-48-tile//pos": {
		Doc:   "(*twenty48.Tile).Pos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.Pos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-twenty-48-tile//update": {
		Doc:   "(*twenty48.Tile).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//update: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//update: arg 1: expected native")
			}
			resErr := arg0Val.Update()
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"ptr-twenty-48-tile//value": {
		Doc:   "(*twenty48.Tile).Value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//value: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//value: arg 1: expected native")
			}
			res0 := arg0Val.Value()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-vector-path//append-vertices-and-indices-for-filling": {
		Doc:   "(*vector.Path).AppendVerticesAndIndicesForFilling",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected block, native or nil")
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForFilling(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-vertex")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-vector-path//append-vertices-and-indices-for-stroke": {
		Doc:   "(*vector.Path).AppendVerticesAndIndicesForStroke",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected block, native or nil")
			}
			var arg3Val *vector.StrokeOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected native")
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForStroke(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-vertex")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"ptr-vector-path//close": {
		Doc:   "(*vector.Path).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//close: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//close: arg 1: expected native")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"ptr-vector-path//line-to": {
		Doc:   "(*vector.Path).LineTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//line-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//line-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//line-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//line-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//line-to: arg 3: expected decimal")
			}
			arg0Val.LineTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-vector-path//move-to": {
		Doc:   "(*vector.Path).MoveTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//move-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//move-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//move-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//move-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//move-to: arg 3: expected decimal")
			}
			arg0Val.MoveTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-vector-path//quad-to": {
		Doc:   "(*vector.Path).QuadTo",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//quad-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//quad-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 5: expected decimal")
			}
			arg0Val.QuadTo(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-cap!": {
		Doc:   "Set *vector.StrokeOptions LineCap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineCap
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineCap)
				}
				if natValOk {
					self.LineCap = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-stroke-options//line-cap!: arg 2: expected integer")
					}
					self.LineCap = vector.LineCap(u)
				}
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-cap?": {
		Doc:   "Get *vector.StrokeOptions LineCap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineCap)))
			return resObj
		},
	},
	"ptr-vector-stroke-options//line-join!": {
		Doc:   "Set *vector.StrokeOptions LineJoin value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineJoin
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineJoin)
				}
				if natValOk {
					self.LineJoin = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-stroke-options//line-join!: arg 2: expected integer")
					}
					self.LineJoin = vector.LineJoin(u)
				}
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-join?": {
		Doc:   "Get *vector.StrokeOptions LineJoin value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineJoin)))
			return resObj
		},
	},
	"ptr-vector-stroke-options//miter-limit!": {
		Doc:   "Set *vector.StrokeOptions MiterLimit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.MiterLimit = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//miter-limit?": {
		Doc:   "Get *vector.StrokeOptions MiterLimit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.MiterLimit))
			return resObj
		},
	},
	"ptr-vector-stroke-options//width!": {
		Doc:   "Set *vector.StrokeOptions Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//width?": {
		Doc:   "Get *vector.StrokeOptions Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"ptr-vorbis-stream//length": {
		Doc:   "(*vorbis.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//length: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-vorbis-stream//read": {
		Doc:   "(*vorbis.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-vorbis-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-vorbis-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-vorbis-stream//seek": {
		Doc:   "(*vorbis.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//seek: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-wav-stream//length": {
		Doc:   "(*wav.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//length: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-wav-stream//read": {
		Doc:   "(*wav.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-wav-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-wav-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"ptr-wav-stream//seek": {
		Doc:   "(*wav.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//seek: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"resources-audio-jab-wav": {
		Doc:   "Get resources_audio.Jab_wav value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Jab_wav))
				for i, it := range resources_audio.Jab_wav {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"resources-audio-jump-ogg": {
		Doc:   "Get resources_audio.Jump_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Jump_ogg))
				for i, it := range resources_audio.Jump_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"resources-audio-ragtime-mp-3": {
		Doc:   "Get resources_audio.Ragtime_mp3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Ragtime_mp3))
				for i, it := range resources_audio.Ragtime_mp3 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"resources-audio-ragtime-ogg": {
		Doc:   "Get resources_audio.Ragtime_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(resources_audio.Ragtime_ogg))
				for i, it := range resources_audio.Ragtime_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"text-advance": {
		Doc:   "text.Advance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-advance: arg 1: expected string")
			}
			var arg1Val text.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-advance: arg 2: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-advance: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-advance: arg 2: expected native")
			}
			res0 := text.Advance(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-align-center": {
		Doc:   "Get text.AlignCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.AlignCenter)))
			return resObj
		},
	},
	"text-align-end": {
		Doc:   "Get text.AlignEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.AlignEnd)))
			return resObj
		},
	},
	"text-align-start": {
		Doc:   "Get text.AlignStart value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.AlignStart)))
			return resObj
		},
	},
	"text-append-glyphs": {
		Doc:   "text.AppendGlyphs",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text.Glyph)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("text-append-glyphs: arg 1: block item: expected native of type text.Glyph")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("text-append-glyphs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 1: expected native of type []text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 2: expected string")
			}
			var arg2Val text.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 3: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 3: expected native")
			}
			var arg3Val *text.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 4: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 4: expected native")
			}
			res0 := text.AppendGlyphs(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "text-glyph")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"text-append-vector-path": {
		Doc:   "text.AppendVectorPath",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 2: expected string")
			}
			var arg2Val text.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 3: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 3: expected native")
			}
			var arg3Val *text.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 4: expected native of type *text.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-vector-path: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-vector-path: arg 4: expected native")
			}
			text.AppendVectorPath(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-cache-glyphs": {
		Doc:   "text.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-cache-glyphs: arg 1: expected string")
			}
			var arg1Val text.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-cache-glyphs: arg 2: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-cache-glyphs: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-cache-glyphs: arg 2: expected native")
			}
			text.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"text-direction-left-to-right": {
		Doc:   "Get text.DirectionLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionLeftToRight)))
			return resObj
		},
	},
	"text-direction-right-to-left": {
		Doc:   "Get text.DirectionRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionRightToLeft)))
			return resObj
		},
	},
	"text-direction-top-to-bottom-and-left-to-right": {
		Doc:   "Get text.DirectionTopToBottomAndLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionTopToBottomAndLeftToRight)))
			return resObj
		},
	},
	"text-direction-top-to-bottom-and-right-to-left": {
		Doc:   "Get text.DirectionTopToBottomAndRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text.DirectionTopToBottomAndRightToLeft)))
			return resObj
		},
	},
	"text-draw": {
		Doc:   "text.Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 2: expected string")
			}
			var arg2Val text.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 3: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 3: expected native")
			}
			var arg3Val *text.DrawOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 4: expected native of type *text.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw: arg 4: expected native")
			}
			text.Draw(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-face//metrics": {
		Doc:   "text.Face.Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-face//metrics: arg 1: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "ptr-text-metrics")
			return res0Obj
		},
	},
	"text-measure": {
		Doc:   "text.Measure",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-measure: arg 1: expected string")
			}
			var arg1Val text.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-measure: arg 2: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-measure: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-measure: arg 2: expected native")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-measure: arg 3: expected decimal")
			}
			res0, res1 := text.Measure(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"text-must-parse-tag": {
		Doc:   "text.MustParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-must-parse-tag: arg 1: expected string")
			}
			res0 := text.MustParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			return res0Obj
		},
	},
	"text-draw-options": {
		Doc:   "Create a new text.DrawOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.DrawOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-text-draw-options")
			return resObj
		},
	},
	"text-glyph": {
		Doc:   "Create a new text.Glyph struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Glyph{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-text-glyph")
			return resObj
		},
	},
	"text-go-text-face": {
		Doc:   "Create a new text.GoTextFace struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.GoTextFace{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-text-go-text-face")
			return resObj
		},
	},
	"text-go-text-face-source": {
		Doc:   "text.NewGoTextFaceSource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-source: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-source: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-source: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-go-text-face-source: arg 1: expected native")
			}
			res0, resErr := text.NewGoTextFaceSource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-go-text-face-source")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-go-text-face-sources-from-collection": {
		Doc:   "text.NewGoTextFaceSourcesFromCollection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-sources-from-collection: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-sources-from-collection: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-go-text-face-sources-from-collection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-go-text-face-sources-from-collection: arg 1: expected native")
			}
			res0, resErr := text.NewGoTextFaceSourcesFromCollection(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-text-go-text-face-source")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-go-x-face": {
		Doc:   "text.NewGoXFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-go-x-face: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-go-x-face: arg 1: expected native")
			}
			res0 := text.NewGoXFace(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-go-x-face")
			return res0Obj
		},
	},
	"text-layout-options": {
		Doc:   "Create a new text.LayoutOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.LayoutOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-text-layout-options")
			return resObj
		},
	},
	"text-limited-face": {
		Doc:   "text.NewLimitedFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-limited-face: arg 1: expected native of type text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-limited-face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-limited-face: arg 1: expected native")
			}
			res0 := text.NewLimitedFace(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-limited-face")
			return res0Obj
		},
	},
	"text-metadata": {
		Doc:   "Create a new text.Metadata struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Metadata{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-text-metadata")
			return resObj
		},
	},
	"text-metrics": {
		Doc:   "Create a new text.Metrics struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Metrics{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-text-metrics")
			return resObj
		},
	},
	"text-multi-face": {
		Doc:   "text.NewMultiFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.Face
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.Face, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text.Face)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("text-multi-face: arg 1: block item: expected native of type text.Face")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("text-multi-face: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("text-multi-face: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-multi-face: arg 1: expected native of type []text.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-multi-face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-multi-face: arg 1: expected block, native or nil")
			}
			res0, resErr := text.NewMultiFace(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-multi-face")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-parse-tag": {
		Doc:   "text.ParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-parse-tag: arg 1: expected string")
			}
			res0, resErr := text.ParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"text-stretch-condensed": {
		Doc:   "Get text.StretchCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchCondensed)))
			return resObj
		},
	},
	"text-stretch-expanded": {
		Doc:   "Get text.StretchExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchExpanded)))
			return resObj
		},
	},
	"text-stretch-extra-condensed": {
		Doc:   "Get text.StretchExtraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchExtraCondensed)))
			return resObj
		},
	},
	"text-stretch-extra-expanded": {
		Doc:   "Get text.StretchExtraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchExtraExpanded)))
			return resObj
		},
	},
	"text-stretch-normal": {
		Doc:   "Get text.StretchNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchNormal)))
			return resObj
		},
	},
	"text-stretch-semi-condensed": {
		Doc:   "Get text.StretchSemiCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchSemiCondensed)))
			return resObj
		},
	},
	"text-stretch-semi-expanded": {
		Doc:   "Get text.StretchSemiExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchSemiExpanded)))
			return resObj
		},
	},
	"text-stretch-ultra-condensed": {
		Doc:   "Get text.StretchUltraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchUltraCondensed)))
			return resObj
		},
	},
	"text-stretch-ultra-expanded": {
		Doc:   "Get text.StretchUltraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.StretchUltraExpanded)))
			return resObj
		},
	},
	"text-style-italic": {
		Doc:   "Get text.StyleItalic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.StyleItalic)))
			return resObj
		},
	},
	"text-style-normal": {
		Doc:   "Get text.StyleNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.StyleNormal)))
			return resObj
		},
	},
	"text-tag//string": {
		Doc:   "text.Tag.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Tag
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text.Tag)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint32
					if v, ok := arg0.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-tag//string: arg 1: expected integer")
					}
					arg0Val = text.Tag(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"text-weight-black": {
		Doc:   "Get text.WeightBlack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightBlack)))
			return resObj
		},
	},
	"text-weight-bold": {
		Doc:   "Get text.WeightBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightBold)))
			return resObj
		},
	},
	"text-weight-extra-bold": {
		Doc:   "Get text.WeightExtraBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightExtraBold)))
			return resObj
		},
	},
	"text-weight-extra-light": {
		Doc:   "Get text.WeightExtraLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightExtraLight)))
			return resObj
		},
	},
	"text-weight-light": {
		Doc:   "Get text.WeightLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightLight)))
			return resObj
		},
	},
	"text-weight-medium": {
		Doc:   "Get text.WeightMedium value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightMedium)))
			return resObj
		},
	},
	"text-weight-normal": {
		Doc:   "Get text.WeightNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightNormal)))
			return resObj
		},
	},
	"text-weight-semibold": {
		Doc:   "Get text.WeightSemibold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightSemibold)))
			return resObj
		},
	},
	"text-weight-thin": {
		Doc:   "Get text.WeightThin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text.WeightThin)))
			return resObj
		},
	},
	"textinput-field": {
		Doc:   "Create a new textinput.Field struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &textinput.Field{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-textinput-field")
			return resObj
		},
	},
	"textinput-state": {
		Doc:   "Create a new textinput.State struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &textinput.State{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-textinput-state")
			return resObj
		},
	},
	"textinput-start": {
		Doc:   "textinput.Start",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-start: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-start: arg 2: expected integer")
			}
			res0, res1 := textinput.Start(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "chan_sr_textinput-state")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "func()")
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"twenty-48-dir-down": {
		Doc:   "Get twenty48.DirDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirDown)))
			return resObj
		},
	},
	"twenty-48-dir-left": {
		Doc:   "Get twenty48.DirLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirLeft)))
			return resObj
		},
	},
	"twenty-48-dir-right": {
		Doc:   "Get twenty48.DirRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirRight)))
			return resObj
		},
	},
	"twenty-48-dir-up": {
		Doc:   "Get twenty48.DirUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirUp)))
			return resObj
		},
	},
	"twenty-48-dir//string": {
		Doc:   "twenty48.Dir.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("twenty-48-dir//string: arg 1: expected integer")
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"twenty-48-dir//vector": {
		Doc:   "twenty48.Dir.Vector",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("twenty-48-dir//vector: arg 1: expected integer")
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0, res1 := arg0Val.Vector()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"twenty-48-board": {
		Doc:   "twenty48.NewBoard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-board: arg 1: expected integer")
			}
			res0, resErr := twenty48.NewBoard(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-board")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"twenty-48-game": {
		Doc:   "twenty48.NewGame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, resErr := twenty48.NewGame()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-game")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"twenty-48-input": {
		Doc:   "twenty48.NewInput",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := twenty48.NewInput()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-input")
			return res0Obj
		},
	},
	"twenty-48-tile": {
		Doc:   "twenty48.NewTile",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 3: expected integer")
			}
			res0 := twenty48.NewTile(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-tile")
			return res0Obj
		},
	},
	"twenty-48-tile-data": {
		Doc:   "Create a new twenty48.TileData struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &twenty48.TileData{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-twenty-48-tile-data")
			return resObj
		},
	},
	"vector-clockwise": {
		Doc:   "Get vector.Clockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.Clockwise)))
			return resObj
		},
	},
	"vector-counter-clockwise": {
		Doc:   "Get vector.CounterClockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.CounterClockwise)))
			return resObj
		},
	},
	"vector-line-cap-butt": {
		Doc:   "Get vector.LineCapButt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapButt)))
			return resObj
		},
	},
	"vector-line-cap-round": {
		Doc:   "Get vector.LineCapRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapRound)))
			return resObj
		},
	},
	"vector-line-cap-square": {
		Doc:   "Get vector.LineCapSquare value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapSquare)))
			return resObj
		},
	},
	"vector-line-join-bevel": {
		Doc:   "Get vector.LineJoinBevel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinBevel)))
			return resObj
		},
	},
	"vector-line-join-miter": {
		Doc:   "Get vector.LineJoinMiter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinMiter)))
			return resObj
		},
	},
	"vector-line-join-round": {
		Doc:   "Get vector.LineJoinRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinRound)))
			return resObj
		},
	},
	"vector-path": {
		Doc:   "Create a new vector.Path struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &vector.Path{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-vector-path")
			return resObj
		},
	},
	"vector-stroke-options": {
		Doc:   "Create a new vector.StrokeOptions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &vector.StrokeOptions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-vector-stroke-options")
			return resObj
		},
	},
	"vorbis-decode": {
		Doc:   "vorbis.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode: arg 2: expected native")
			}
			res0, resErr := vorbis.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vorbis-decode-with-sample-rate": {
		Doc:   "vorbis.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected native")
			}
			res0, resErr := vorbis.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vorbis-decode-without-resampling": {
		Doc:   "vorbis.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-without-resampling: arg 1: expected native")
			}
			res0, resErr := vorbis.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"vorbis-stream": {
		Doc:   "Create a new vorbis.Stream struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &vorbis.Stream{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-vorbis-stream")
			return resObj
		},
	},
	"wav-decode": {
		Doc:   "wav.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode: arg 2: expected native")
			}
			res0, resErr := wav.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"wav-decode-with-sample-rate": {
		Doc:   "wav.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("wav-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode-with-sample-rate: arg 2: expected native")
			}
			res0, resErr := wav.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"wav-decode-without-resampling": {
		Doc:   "wav.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_io_Reader(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode-without-resampling: arg 1: expected native")
			}
			res0, resErr := wav.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"wav-stream": {
		Doc:   "Create a new wav.Stream struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &wav.Stream{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "ptr-wav-stream")
			return resObj
		},
	},
}
