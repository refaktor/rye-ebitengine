// Code generated by ryegen. DO NOT EDIT.

//go:build b_ebiten

package ebiten

import (
	"errors"
	"fmt"
	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/audio"
	"github.com/hajimehoshi/ebiten/v2/audio/mp3"
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis"
	"github.com/hajimehoshi/ebiten/v2/audio/wav"
	"github.com/hajimehoshi/ebiten/v2/colorm"
	"github.com/hajimehoshi/ebiten/v2/ebitenutil"
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048"
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/keyboard/keyboard"
	audio_1 "github.com/hajimehoshi/ebiten/v2/examples/resources/audio"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/fonts"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images"
	audio_2 "github.com/hajimehoshi/ebiten/v2/examples/resources/images/audio"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/blend"
	blocks_1 "github.com/hajimehoshi/ebiten/v2/examples/resources/images/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/flappy"
	keyboard_1 "github.com/hajimehoshi/ebiten/v2/examples/resources/images/keyboard"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/mascot"
	"github.com/hajimehoshi/ebiten/v2/examples/resources/images/platformer"
	shader_1 "github.com/hajimehoshi/ebiten/v2/examples/resources/images/shader"
	"github.com/hajimehoshi/ebiten/v2/exp/textinput"
	"github.com/hajimehoshi/ebiten/v2/inpututil"
	"github.com/hajimehoshi/ebiten/v2/mobile"
	"github.com/hajimehoshi/ebiten/v2/text"
	text_1 "github.com/hajimehoshi/ebiten/v2/text/v2"
	"github.com/hajimehoshi/ebiten/v2/vector"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"golang.org/x/image/font"
	"golang.org/x/text/language"
	"image"
	"image/color"
	"io"
	"io/fs"
	"reflect"
	"time"
)

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

var ryeStructNameLookup = map[string]string{
	"github.com/hajimehoshi/ebiten/v2.*Blend": "ptr-ebiten-blend",
	"github.com/hajimehoshi/ebiten/v2.*ColorScale": "ptr-ebiten-color-scale",
	"github.com/hajimehoshi/ebiten/v2.*DrawImageOptions": "ptr-ebiten-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2.*DrawTrianglesOptions": "ptr-ebiten-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2.*GeoM": "ptr-ebiten-geo-m",
	"github.com/hajimehoshi/ebiten/v2.*Image": "ptr-ebiten-image",
	"github.com/hajimehoshi/ebiten/v2.*RunGameOptions": "ptr-ebiten-run-game-options",
	"github.com/hajimehoshi/ebiten/v2.*Shader": "ptr-ebiten-shader",
	"github.com/hajimehoshi/ebiten/v2.*Vertex": "ptr-ebiten-vertex",
	"github.com/hajimehoshi/ebiten/v2.*VibrateGamepadOptions": "ptr-ebiten-vibrate-gamepad-options",
	"github.com/hajimehoshi/ebiten/v2.*VibrateOptions": "ptr-ebiten-vibrate-options",
	"github.com/hajimehoshi/ebiten/v2.Blend": "ebiten-blend",
	"github.com/hajimehoshi/ebiten/v2.ColorScale": "ebiten-color-scale",
	"github.com/hajimehoshi/ebiten/v2.DrawImageOptions": "ebiten-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2.DrawTrianglesOptions": "ebiten-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2.GeoM": "ebiten-geo-m",
	"github.com/hajimehoshi/ebiten/v2.Image": "ebiten-image",
	"github.com/hajimehoshi/ebiten/v2.RunGameOptions": "ebiten-run-game-options",
	"github.com/hajimehoshi/ebiten/v2.Shader": "ebiten-shader",
	"github.com/hajimehoshi/ebiten/v2.Vertex": "ebiten-vertex",
	"github.com/hajimehoshi/ebiten/v2.VibrateGamepadOptions": "ebiten-vibrate-gamepad-options",
	"github.com/hajimehoshi/ebiten/v2.VibrateOptions": "ebiten-vibrate-options",
	"github.com/hajimehoshi/ebiten/v2/audio.*InfiniteLoop": "ptr-audio-infinite-loop",
	"github.com/hajimehoshi/ebiten/v2/audio.InfiniteLoop": "audio-infinite-loop",
	"github.com/hajimehoshi/ebiten/v2/audio/mp3.*Stream": "ptr-mp-3-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/mp3.Stream": "mp-3-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis.*Stream": "ptr-vorbis-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis.Stream": "vorbis-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/wav.*Stream": "ptr-wav-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/wav.Stream": "wav-stream",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawImageOptions": "ptr-colorm-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawTrianglesOptions": "ptr-colorm-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.DrawImageOptions": "colorm-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.DrawTrianglesOptions": "colorm-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Game": "ptr-twenty-48-game",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Input": "ptr-twenty-48-input",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Tile": "ptr-twenty-48-tile",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*TileData": "ptr-twenty-48-tile-data",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.Game": "twenty-48-game",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.Input": "twenty-48-input",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.Tile": "twenty-48-tile",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.TileData": "twenty-48-tile-data",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Game": "ptr-blocks-game",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameScene": "ptr-blocks-game-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameState": "ptr-blocks-game-state",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GamepadScene": "ptr-blocks-gamepad-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Input": "ptr-blocks-input",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Piece": "ptr-blocks-piece",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*SceneManager": "ptr-blocks-scene-manager",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*TitleScene": "ptr-blocks-title-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Game": "blocks-game",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.GameScene": "blocks-game-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.GameState": "blocks-game-state",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.GamepadScene": "blocks-gamepad-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Input": "blocks-input",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Piece": "blocks-piece",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.SceneManager": "blocks-scene-manager",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.TitleScene": "blocks-title-scene",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.*State": "ptr-textinput-state",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.State": "textinput-state",
	"github.com/hajimehoshi/ebiten/v2/text.*Glyph": "ptr-text-glyph",
	"github.com/hajimehoshi/ebiten/v2/text.Glyph": "text-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*DrawOptions": "ptr-text-1-draw-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Glyph": "ptr-text-1-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*GoTextFace": "ptr-text-1-go-text-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LayoutOptions": "ptr-text-1-layout-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LimitedFace": "ptr-text-1-limited-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metadata": "ptr-text-1-metadata",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metrics": "ptr-text-1-metrics",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*MultiFace": "ptr-text-1-multi-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.DrawOptions": "text-1-draw-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.Glyph": "text-1-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.GoTextFace": "text-1-go-text-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.LayoutOptions": "text-1-layout-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.LimitedFace": "text-1-limited-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.Metadata": "text-1-metadata",
	"github.com/hajimehoshi/ebiten/v2/text/v2.Metrics": "text-1-metrics",
	"github.com/hajimehoshi/ebiten/v2/text/v2.MultiFace": "text-1-multi-face",
	"github.com/hajimehoshi/ebiten/v2/vector.*Path": "ptr-vector-path",
	"github.com/hajimehoshi/ebiten/v2/vector.*StrokeOptions": "ptr-vector-stroke-options",
	"github.com/hajimehoshi/ebiten/v2/vector.Path": "vector-path",
	"github.com/hajimehoshi/ebiten/v2/vector.StrokeOptions": "vector-stroke-options",
	"io.*LimitedReader": "ptr-io-limited-reader",
	"io.*PipeReader": "ptr-io-pipe-reader",
	"io.*PipeWriter": "ptr-io-pipe-writer",
	"io.*SectionReader": "ptr-io-section-reader",
	"io.LimitedReader": "io-limited-reader",
	"io.PipeReader": "io-pipe-reader",
	"io.PipeWriter": "io-pipe-writer",
	"io.SectionReader": "io-section-reader",
	"io/fs.*PathError": "ptr-fs-path-error",
	"io/fs.PathError": "fs-path-error",
}

type ryegen_blocks_Scene struct {
	self env.RyeCtx
	fn_Update func(self env.RyeCtx, arg0 *blocks.GameState) (error)
	fn_Draw func(self env.RyeCtx, arg0 *ebiten.Image)
}
func (self *ryegen_blocks_Scene) Update(arg0 *blocks.GameState) (error) {
	return self.fn_Update(self.self, arg0)
}
func (self *ryegen_blocks_Scene) Draw(arg0 *ebiten.Image) {
	self.fn_Draw(self.self, arg0)
}

type ryegen_ebiten_FinalScreenDrawer struct {
	self env.RyeCtx
	fn_DrawFinalScreen func(self env.RyeCtx, arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM)
}
func (self *ryegen_ebiten_FinalScreenDrawer) DrawFinalScreen(arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM) {
	self.fn_DrawFinalScreen(self.self, arg0, arg1, arg2)
}

type ryegen_ebiten_Game struct {
	self env.RyeCtx
	fn_Update func(self env.RyeCtx) (error)
	fn_Draw func(self env.RyeCtx, arg0 *ebiten.Image)
	fn_Layout func(self env.RyeCtx, arg0 int, arg1 int) (int, int)
}
func (self *ryegen_ebiten_Game) Update() (error) {
	return self.fn_Update(self.self)
}
func (self *ryegen_ebiten_Game) Draw(arg0 *ebiten.Image) {
	self.fn_Draw(self.self, arg0)
}
func (self *ryegen_ebiten_Game) Layout(arg0 int, arg1 int) (int, int) {
	return self.fn_Layout(self.self, arg0, arg1)
}

type ryegen_ebiten_LayoutFer struct {
	self env.RyeCtx
	fn_LayoutF func(self env.RyeCtx, arg0 float64, arg1 float64) (float64, float64)
}
func (self *ryegen_ebiten_LayoutFer) LayoutF(arg0 float64, arg1 float64) (float64, float64) {
	return self.fn_LayoutF(self.self, arg0, arg1)
}

type ryegen_fs_FS struct {
	self env.RyeCtx
	fn_Open func(self env.RyeCtx, arg0 string) (fs.File, error)
}
func (self *ryegen_fs_FS) Open(arg0 string) (fs.File, error) {
	return self.fn_Open(self.self, arg0)
}

type ryegen_fs_File struct {
	self env.RyeCtx
	fn_Stat func(self env.RyeCtx) (fs.FileInfo, error)
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Close func(self env.RyeCtx) (error)
}
func (self *ryegen_fs_File) Stat() (fs.FileInfo, error) {
	return self.fn_Stat(self.self)
}
func (self *ryegen_fs_File) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *ryegen_fs_File) Close() (error) {
	return self.fn_Close(self.self)
}

type ryegen_fs_FileInfo struct {
	self env.RyeCtx
	fn_Name func(self env.RyeCtx) (string)
	fn_Size func(self env.RyeCtx) (int64)
	fn_Mode func(self env.RyeCtx) (fs.FileMode)
	fn_ModTime func(self env.RyeCtx) (time.Time)
	fn_IsDir func(self env.RyeCtx) (bool)
	fn_Sys func(self env.RyeCtx) (any)
}
func (self *ryegen_fs_FileInfo) Name() (string) {
	return self.fn_Name(self.self)
}
func (self *ryegen_fs_FileInfo) Size() (int64) {
	return self.fn_Size(self.self)
}
func (self *ryegen_fs_FileInfo) Mode() (fs.FileMode) {
	return self.fn_Mode(self.self)
}
func (self *ryegen_fs_FileInfo) ModTime() (time.Time) {
	return self.fn_ModTime(self.self)
}
func (self *ryegen_fs_FileInfo) IsDir() (bool) {
	return self.fn_IsDir(self.self)
}
func (self *ryegen_fs_FileInfo) Sys() (any) {
	return self.fn_Sys(self.self)
}

type ryegen_io_Closer struct {
	self env.RyeCtx
	fn_Close func(self env.RyeCtx) (error)
}
func (self *ryegen_io_Closer) Close() (error) {
	return self.fn_Close(self.self)
}

type ryegen_io_ReadSeeker struct {
	self env.RyeCtx
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
	fn_Seek func(self env.RyeCtx, arg0 int64, arg1 int) (int64, error)
}
func (self *ryegen_io_ReadSeeker) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}
func (self *ryegen_io_ReadSeeker) Seek(arg0 int64, arg1 int) (int64, error) {
	return self.fn_Seek(self.self, arg0, arg1)
}

type ryegen_io_Reader struct {
	self env.RyeCtx
	fn_Read func(self env.RyeCtx, arg0 []byte) (int, error)
}
func (self *ryegen_io_Reader) Read(arg0 []byte) (int, error) {
	return self.fn_Read(self.self, arg0)
}

type ryegen_io_Seeker struct {
	self env.RyeCtx
	fn_Seek func(self env.RyeCtx, arg0 int64, arg1 int) (int64, error)
}
func (self *ryegen_io_Seeker) Seek(arg0 int64, arg1 int) (int64, error) {
	return self.fn_Seek(self.self, arg0, arg1)
}

var Builtins = map[string]*env.Builtin{
	"nil": {
		Doc: "nil value for go types",
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			return *env.NewInteger(0)
		},
	},
	"audio-1-jab-wav": {
		Doc: "Get audio_1.Jab_wav value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Jab_wav))
				for i, it := range audio_1.Jab_wav {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-1-jump-ogg": {
		Doc: "Get audio_1.Jump_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Jump_ogg))
				for i, it := range audio_1.Jump_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-1-ragtime-mp-3": {
		Doc: "Get audio_1.Ragtime_mp3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Ragtime_mp3))
				for i, it := range audio_1.Ragtime_mp3 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-1-ragtime-ogg": {
		Doc: "Get audio_1.Ragtime_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Ragtime_ogg))
				for i, it := range audio_1.Ragtime_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-2-alert-png": {
		Doc: "Get audio_2.Alert_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_2.Alert_png))
				for i, it := range audio_2.Alert_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-2-pause-png": {
		Doc: "Get audio_2.Pause_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_2.Pause_png))
				for i, it := range audio_2.Pause_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-2-play-png": {
		Doc: "Get audio_2.Play_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_2.Play_png))
				for i, it := range audio_2.Play_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-infinite-loop": {
		Doc: "audio.NewInfiniteLoop",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_ReadSeeker{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: context fn read: expected function or nil")
					}
					ctxObj1, ok := wordToObj["seek"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: expected context to have function seek")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: context fn seek: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Seek = func(ctx env.RyeCtx, arg0 int64, arg1 int) (int64, error) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int64
							var res1 error
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int64(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							switch v := res.Series.S[1].(type) {
							case env.String:
								res1 = errors.New(v.Value)
							case env.Error:
								res1 = errors.New(v.Print(*ps.Idx))
							case env.Integer:
								if v.Value != 0 {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								res1 = nil
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								return res0, res1
							}
						case env.Integer:
							if fn.Value != 0 {
								ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: context fn seek: expected integer to be 0 or nil")
							}
							impl.fn_Seek = nil
						default:
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: context to io.ReadSeeker: context fn seek: expected function or nil")
						}
						arg0Val = impl
					case env.Native:
						var ok bool
						arg0Val, ok = v.Value.(io.ReadSeeker)
						if !ok {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: expected native of type io.ReadSeeker")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: expected integer to be 0 or nil")
						}
						arg0Val = nil
					default:
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 1: expected native")
					}
					var arg1Val int64
					if v, ok := arg1.(env.Integer); ok {
						arg1Val = int64(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop: arg 2: expected integer")
					}
					res0 := audio.NewInfiniteLoop(arg0Val, arg1Val)
					var res0Obj env.Object
					res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-infinite-loop")
					return res0Obj
		},
	},
	"audio-infinite-loop-with-intro": {
		Doc: "audio.NewInfiniteLoopWithIntro",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_ReadSeeker{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: context fn read: expected function or nil")
					}
					ctxObj1, ok := wordToObj["seek"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: expected context to have function seek")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: context fn seek: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Seek = func(ctx env.RyeCtx, arg0 int64, arg1 int) (int64, error) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int64
							var res1 error
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int64(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							switch v := res.Series.S[1].(type) {
							case env.String:
								res1 = errors.New(v.Value)
							case env.Error:
								res1 = errors.New(v.Print(*ps.Idx))
							case env.Integer:
								if v.Value != 0 {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								res1 = nil
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"audio-infinite-loop-with-intro: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								return res0, res1
							}
						case env.Integer:
							if fn.Value != 0 {
								ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: context fn seek: expected integer to be 0 or nil")
							}
							impl.fn_Seek = nil
						default:
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: context to io.ReadSeeker: context fn seek: expected function or nil")
						}
						arg0Val = impl
					case env.Native:
						var ok bool
						arg0Val, ok = v.Value.(io.ReadSeeker)
						if !ok {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: expected native of type io.ReadSeeker")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: expected integer to be 0 or nil")
						}
						arg0Val = nil
					default:
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 1: expected native")
					}
					var arg1Val int64
					if v, ok := arg1.(env.Integer); ok {
						arg1Val = int64(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 2: expected integer")
					}
					var arg2Val int64
					if v, ok := arg2.(env.Integer); ok {
						arg2Val = int64(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("audio-infinite-loop-with-intro: arg 3: expected integer")
					}
					res0 := audio.NewInfiniteLoopWithIntro(arg0Val, arg1Val, arg2Val)
					var res0Obj env.Object
					res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-infinite-loop")
					return res0Obj
		},
	},
	"blend-dest-png": {
		Doc: "Get blend.Dest_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Dest_png))
				for i, it := range blend.Dest_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blend-source-png": {
		Doc: "Get blend.Source_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Source_png))
				for i, it := range blend.Source_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-1-background-png": {
		Doc: "Get blocks_1.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blocks_1.Background_png))
				for i, it := range blocks_1.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-1-blocks-png": {
		Doc: "Get blocks_1.Blocks_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blocks_1.Blocks_png))
				for i, it := range blocks_1.Blocks_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-angle-0": {
		Doc: "Get blocks.Angle0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle0)))
			return resObj
		},
	},
	"blocks-angle-180": {
		Doc: "Get blocks.Angle180 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle180)))
			return resObj
		},
	},
	"blocks-angle-270": {
		Doc: "Get blocks.Angle270 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle270)))
			return resObj
		},
	},
	"blocks-angle-90": {
		Doc: "Get blocks.Angle90 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle90)))
			return resObj
		},
	},
	"blocks-angle//rotate-left": {
		Doc: "blocks.Angle.RotateLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("blocks-angle//rotate-left: arg 1: expected integer")
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"blocks-angle//rotate-right": {
		Doc: "blocks.Angle.RotateRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("blocks-angle//rotate-right: arg 1: expected integer")
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"blocks-block-type-1": {
		Doc: "Get blocks.BlockType1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType1)))
			return resObj
		},
	},
	"blocks-block-type-2": {
		Doc: "Get blocks.BlockType2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType2)))
			return resObj
		},
	},
	"blocks-block-type-3": {
		Doc: "Get blocks.BlockType3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType3)))
			return resObj
		},
	},
	"blocks-block-type-4": {
		Doc: "Get blocks.BlockType4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType4)))
			return resObj
		},
	},
	"blocks-block-type-5": {
		Doc: "Get blocks.BlockType5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType5)))
			return resObj
		},
	},
	"blocks-block-type-6": {
		Doc: "Get blocks.BlockType6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType6)))
			return resObj
		},
	},
	"blocks-block-type-7": {
		Doc: "Get blocks.BlockType7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType7)))
			return resObj
		},
	},
	"blocks-block-type-max": {
		Doc: "Get blocks.BlockTypeMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeMax)))
			return resObj
		},
	},
	"blocks-block-type-none": {
		Doc: "Get blocks.BlockTypeNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeNone)))
			return resObj
		},
	},
	"blocks-game-state//input!": {
		Doc: "Set blocks.GameState Input value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//input!: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
return env.NewError("blocks-game-state//input!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Input, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//input!: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//input!: arg 2: expected integer to be 0 or nil")
				}
				self.Input = nil
			default:
				ps.FailureFlag = true
return env.NewError("blocks-game-state//input!: arg 2: expected native")
			}
			return arg0
		},
	},
	"blocks-game-state//input?": {
		Doc: "Get blocks.GameState Input value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//input?: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
return env.NewError("blocks-game-state//input?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Input, "ptr-blocks-input")
			return resObj
		},
	},
	"blocks-game-state//scene-manager!": {
		Doc: "Set blocks.GameState SceneManager value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager!: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SceneManager, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager!: arg 2: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager!: arg 2: expected integer to be 0 or nil")
				}
				self.SceneManager = nil
			default:
				ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager!: arg 2: expected native")
			}
			return arg0
		},
	},
	"blocks-game-state//scene-manager?": {
		Doc: "Get blocks.GameState SceneManager value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager?: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
return env.NewError("blocks-game-state//scene-manager?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SceneManager, "ptr-blocks-scene-manager")
			return resObj
		},
	},
	"blocks-game-scene": {
		Doc: "blocks.NewGameScene",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := blocks.NewGameScene()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-blocks-game-scene")
			return res0Obj
		},
	},
	"blocks-pieces": {
		Doc: "Get blocks.Pieces value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, blocks.Pieces, "map(blocks-block-type)ptr-blocks-piece")
			return resObj
		},
	},
	"blocks-scene//draw": {
		Doc: "blocks.Scene.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_blocks_Scene{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: context fn update: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Update = func(ctx env.RyeCtx, arg0 *blocks.GameState) (error) {
						var arg0Val env.Object
						arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-blocks-game-state")
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"blocks-scene//draw: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"blocks-scene//draw: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: context to blocks.Scene: context fn draw: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(blocks.Scene)
					if !ok {
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: expected native of type blocks.Scene")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 1: expected native")
				}
				var arg1Val *ebiten.Image
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*ebiten.Image)
					if !ok {
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 2: expected native of type *ebiten.Image")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("blocks-scene//draw: arg 2: expected native")
				}
				arg0Val.Draw(arg1Val)
				return arg0
		},
	},
	"blocks-scene//update": {
		Doc: "blocks.Scene.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_blocks_Scene{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: context fn update: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Update = func(ctx env.RyeCtx, arg0 *blocks.GameState) (error) {
						var arg0Val env.Object
						arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-blocks-game-state")
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"blocks-scene//update: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"blocks-scene//update: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: context to blocks.Scene: context fn draw: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(blocks.Scene)
					if !ok {
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: expected native of type blocks.Scene")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 1: expected native")
				}
				var arg1Val *blocks.GameState
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*blocks.GameState)
					if !ok {
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 2: expected native of type *blocks.GameState")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("blocks-scene//update: arg 2: expected native")
				}
				res0 := arg0Val.Update(arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewError(res0.Error())
				return res0Obj
		},
	},
	"colorm-draw-image": {
		Doc: "colorm.DrawImage",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 2: expected native")
			}
			var arg2Val colorm.ColorM
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 3: expected native of type colorm.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 3: expected native")
			}
			var arg3Val *colorm.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 4: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image: arg 4: expected native")
			}
			colorm.DrawImage(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"colorm-draw-image-options//blend!": {
		Doc: "Set colorm.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//blend!: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"colorm-draw-image-options//blend?": {
		Doc: "Get colorm.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//blend?: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"colorm-draw-image-options//filter!": {
		Doc: "Set colorm.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//filter!: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-image-options//filter?": {
		Doc: "Get colorm.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//filter?: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"colorm-draw-image-options//geo-m!": {
		Doc: "Set colorm.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//geo-m!: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"colorm-draw-image-options//geo-m?": {
		Doc: "Get colorm.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//geo-m?: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"colorm-draw-triangles-options//address!": {
		Doc: "Set colorm.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//address!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//address?": {
		Doc: "Get colorm.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//address?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"colorm-draw-triangles-options//anti-alias!": {
		Doc: "Set colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//anti-alias!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//anti-alias?": {
		Doc: "Get colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//anti-alias?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"colorm-draw-triangles-options//blend!": {
		Doc: "Set colorm.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//blend!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//blend?": {
		Doc: "Get colorm.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//blend?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"colorm-draw-triangles-options//color-scale-mode!": {
		Doc: "Set colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//color-scale-mode?": {
		Doc: "Get colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"colorm-draw-triangles-options//fill-rule!": {
		Doc: "Set colorm.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//fill-rule!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//fill-rule?": {
		Doc: "Get colorm.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//fill-rule?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"colorm-draw-triangles-options//filter!": {
		Doc: "Set colorm.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//filter!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//filter?": {
		Doc: "Get colorm.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//filter?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("colorm-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"actual-fps": {
		Doc: "ebiten.ActualFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.ActualFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"actual-tps": {
		Doc: "ebiten.ActualTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.ActualTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"address-clamp-to-zero": {
		Doc: "Get ebiten.AddressClampToZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressClampToZero)))
			return resObj
		},
	},
	"address-repeat": {
		Doc: "Get ebiten.AddressRepeat value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressRepeat)))
			return resObj
		},
	},
	"address-unsafe": {
		Doc: "Get ebiten.AddressUnsafe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressUnsafe)))
			return resObj
		},
	},
	"append-gamepad-i-ds": {
		Doc: "ebiten.AppendGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("append-gamepad-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.GamepadID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.GamepadID)
				if !ok {
					ps.FailureFlag = true
return env.NewError("append-gamepad-i-ds: arg 1: expected native of type []ebiten.GamepadID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("append-gamepad-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("append-gamepad-i-ds: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-input-chars": {
		Doc: "ebiten.AppendInputChars",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []rune
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(rune)
						if !ok {
							ps.FailureFlag = true
return env.NewError("append-input-chars: arg 1: block item: expected native of type rune")
						}
					default:
						ps.FailureFlag = true
return env.NewError("append-input-chars: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]rune)
				if !ok {
					ps.FailureFlag = true
return env.NewError("append-input-chars: arg 1: expected native of type []rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("append-input-chars: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("append-input-chars: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendInputChars(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-monitors": {
		Doc: "ebiten.AppendMonitors",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []*ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*ebiten.MonitorType, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*ebiten.MonitorType)
						if !ok {
							ps.FailureFlag = true
return env.NewError("append-monitors: arg 1: block item: expected native of type *ebiten.MonitorType")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
return env.NewError("append-monitors: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
return env.NewError("append-monitors: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
return env.NewError("append-monitors: arg 1: expected native of type []*ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("append-monitors: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("append-monitors: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendMonitors(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-ebiten-monitor-type")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-touch-i-ds": {
		Doc: "ebiten.AppendTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("append-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
return env.NewError("append-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("append-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("append-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"blend-factor-default": {
		Doc: "Get ebiten.BlendFactorDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDefault), "byte")
			return resObj
		},
	},
	"blend-factor-destination-alpha": {
		Doc: "Get ebiten.BlendFactorDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-destination-color": {
		Doc: "Get ebiten.BlendFactorDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationColor), "byte")
			return resObj
		},
	},
	"blend-factor-one": {
		Doc: "Get ebiten.BlendFactorOne value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOne), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-alpha": {
		Doc: "Get ebiten.BlendFactorOneMinusDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-color": {
		Doc: "Get ebiten.BlendFactorOneMinusDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationColor), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-source-alpha": {
		Doc: "Get ebiten.BlendFactorOneMinusSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-source-color": {
		Doc: "Get ebiten.BlendFactorOneMinusSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceColor), "byte")
			return resObj
		},
	},
	"blend-factor-source-alpha": {
		Doc: "Get ebiten.BlendFactorSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-source-color": {
		Doc: "Get ebiten.BlendFactorSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceColor), "byte")
			return resObj
		},
	},
	"blend-factor-zero": {
		Doc: "Get ebiten.BlendFactorZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorZero), "byte")
			return resObj
		},
	},
	"blend-operation-add": {
		Doc: "Get ebiten.BlendOperationAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationAdd), "byte")
			return resObj
		},
	},
	"blend-operation-max": {
		Doc: "Get ebiten.BlendOperationMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMax), "byte")
			return resObj
		},
	},
	"blend-operation-min": {
		Doc: "Get ebiten.BlendOperationMin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMin), "byte")
			return resObj
		},
	},
	"blend-operation-reverse-subtract": {
		Doc: "Get ebiten.BlendOperationReverseSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationReverseSubtract), "byte")
			return resObj
		},
	},
	"blend-operation-subtract": {
		Doc: "Get ebiten.BlendOperationSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationSubtract), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-destination-alpha!": {
		Doc: "Set ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native")
					}
					self.BlendFactorDestinationAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-destination-alpha?": {
		Doc: "Get ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-destination-rgb!": {
		Doc: "Set ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native")
					}
					self.BlendFactorDestinationRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-destination-rgb?": {
		Doc: "Get ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationRGB), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-source-alpha!": {
		Doc: "Set ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 2: expected native")
					}
					self.BlendFactorSourceAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-source-alpha?": {
		Doc: "Get ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-alpha?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-source-rgb!": {
		Doc: "Set ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 2: expected native")
					}
					self.BlendFactorSourceRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-source-rgb?": {
		Doc: "Get ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-rgb?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-factor-source-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceRGB), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-operation-alpha!": {
		Doc: "Set ebiten.Blend BlendOperationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-alpha!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-alpha!: arg 2: expected native")
					}
					self.BlendOperationAlpha = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-operation-alpha?": {
		Doc: "Get ebiten.Blend BlendOperationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-alpha?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationAlpha), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-operation-rgb!": {
		Doc: "Set ebiten.Blend BlendOperationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-rgb!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-rgb!: arg 2: expected native")
					}
					self.BlendOperationRGB = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-operation-rgb?": {
		Doc: "Get ebiten.Blend BlendOperationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-rgb?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-blend//blend-operation-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationRGB), "byte")
			return resObj
		},
	},
	"color-scale-mode-premultiplied-alpha": {
		Doc: "Get ebiten.ColorScaleModePremultipliedAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModePremultipliedAlpha)))
			return resObj
		},
	},
	"color-scale-mode-straight-alpha": {
		Doc: "Get ebiten.ColorScaleModeStraightAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModeStraightAlpha)))
			return resObj
		},
	},
	"composite-mode-clear": {
		Doc: "Get ebiten.CompositeModeClear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeClear)))
			return resObj
		},
	},
	"composite-mode-copy": {
		Doc: "Get ebiten.CompositeModeCopy value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCopy)))
			return resObj
		},
	},
	"composite-mode-custom": {
		Doc: "Get ebiten.CompositeModeCustom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCustom)))
			return resObj
		},
	},
	"composite-mode-destination": {
		Doc: "Get ebiten.CompositeModeDestination value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestination)))
			return resObj
		},
	},
	"composite-mode-destination-atop": {
		Doc: "Get ebiten.CompositeModeDestinationAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationAtop)))
			return resObj
		},
	},
	"composite-mode-destination-in": {
		Doc: "Get ebiten.CompositeModeDestinationIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationIn)))
			return resObj
		},
	},
	"composite-mode-destination-out": {
		Doc: "Get ebiten.CompositeModeDestinationOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOut)))
			return resObj
		},
	},
	"composite-mode-destination-over": {
		Doc: "Get ebiten.CompositeModeDestinationOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOver)))
			return resObj
		},
	},
	"composite-mode-lighter": {
		Doc: "Get ebiten.CompositeModeLighter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeLighter)))
			return resObj
		},
	},
	"composite-mode-multiply": {
		Doc: "Get ebiten.CompositeModeMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeMultiply)))
			return resObj
		},
	},
	"composite-mode-source-atop": {
		Doc: "Get ebiten.CompositeModeSourceAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceAtop)))
			return resObj
		},
	},
	"composite-mode-source-in": {
		Doc: "Get ebiten.CompositeModeSourceIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceIn)))
			return resObj
		},
	},
	"composite-mode-source-out": {
		Doc: "Get ebiten.CompositeModeSourceOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOut)))
			return resObj
		},
	},
	"composite-mode-source-over": {
		Doc: "Get ebiten.CompositeModeSourceOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOver)))
			return resObj
		},
	},
	"composite-mode-xor": {
		Doc: "Get ebiten.CompositeModeXor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeXor)))
			return resObj
		},
	},
	"current-fps": {
		Doc: "ebiten.CurrentFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"current-tps": {
		Doc: "ebiten.CurrentTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"cursor-mode": {
		Doc: "ebiten.CursorMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CursorMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"cursor-mode-captured": {
		Doc: "Get ebiten.CursorModeCaptured value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeCaptured)))
			return resObj
		},
	},
	"cursor-mode-hidden": {
		Doc: "Get ebiten.CursorModeHidden value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeHidden)))
			return resObj
		},
	},
	"cursor-mode-visible": {
		Doc: "Get ebiten.CursorModeVisible value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeVisible)))
			return resObj
		},
	},
	"cursor-position": {
		Doc: "ebiten.CursorPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.CursorPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"x": res0Obj,
				"y": res1Obj,
			})
		},
	},
	"cursor-shape": {
		Doc: "ebiten.CursorShape",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.CursorShape()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"cursor-shape-crosshair": {
		Doc: "Get ebiten.CursorShapeCrosshair value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeCrosshair)))
			return resObj
		},
	},
	"cursor-shape-default": {
		Doc: "Get ebiten.CursorShapeDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeDefault)))
			return resObj
		},
	},
	"cursor-shape-ew-resize": {
		Doc: "Get ebiten.CursorShapeEWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeEWResize)))
			return resObj
		},
	},
	"cursor-shape-move": {
		Doc: "Get ebiten.CursorShapeMove value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeMove)))
			return resObj
		},
	},
	"cursor-shape-nesw-resize": {
		Doc: "Get ebiten.CursorShapeNESWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNESWResize)))
			return resObj
		},
	},
	"cursor-shape-not-allowed": {
		Doc: "Get ebiten.CursorShapeNotAllowed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNotAllowed)))
			return resObj
		},
	},
	"cursor-shape-ns-resize": {
		Doc: "Get ebiten.CursorShapeNSResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNSResize)))
			return resObj
		},
	},
	"cursor-shape-nwse-resize": {
		Doc: "Get ebiten.CursorShapeNWSEResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNWSEResize)))
			return resObj
		},
	},
	"cursor-shape-pointer": {
		Doc: "Get ebiten.CursorShapePointer value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapePointer)))
			return resObj
		},
	},
	"cursor-shape-text": {
		Doc: "Get ebiten.CursorShapeText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeText)))
			return resObj
		},
	},
	"device-scale-factor": {
		Doc: "ebiten.DeviceScaleFactor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ebiten-draw-image-options//blend!": {
		Doc: "Set ebiten.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//blend!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//blend?": {
		Doc: "Get ebiten.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//blend?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ebiten-draw-image-options//color-m!": {
		Doc: "Set ebiten.DrawImageOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-m!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//color-m?": {
		Doc: "Get ebiten.DrawImageOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-m?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ebiten-draw-image-options//color-scale!": {
		Doc: "Set ebiten.DrawImageOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-scale!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//color-scale?": {
		Doc: "Get ebiten.DrawImageOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-scale?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"ebiten-draw-image-options//composite-mode!": {
		Doc: "Set ebiten.DrawImageOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//composite-mode!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//composite-mode?": {
		Doc: "Get ebiten.DrawImageOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//composite-mode?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ebiten-draw-image-options//filter!": {
		Doc: "Set ebiten.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//filter!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//filter?": {
		Doc: "Get ebiten.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//filter?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ebiten-draw-image-options//geo-m!": {
		Doc: "Set ebiten.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//geo-m!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//geo-m?": {
		Doc: "Get ebiten.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//geo-m?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ebiten-draw-triangles-options//address!": {
		Doc: "Set ebiten.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//address!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//address?": {
		Doc: "Get ebiten.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//address?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//anti-alias!": {
		Doc: "Set ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//anti-alias!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//anti-alias?": {
		Doc: "Get ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//anti-alias?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//blend!": {
		Doc: "Set ebiten.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//blend!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//blend?": {
		Doc: "Get ebiten.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//blend?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ebiten-draw-triangles-options//color-m!": {
		Doc: "Set ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-m!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//color-m?": {
		Doc: "Get ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-m?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ebiten-draw-triangles-options//color-scale-mode!": {
		Doc: "Set ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//color-scale-mode?": {
		Doc: "Get ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//composite-mode!": {
		Doc: "Set ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//composite-mode!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//composite-mode?": {
		Doc: "Get ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//composite-mode?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//fill-rule!": {
		Doc: "Set ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//fill-rule!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//fill-rule?": {
		Doc: "Get ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//fill-rule?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//filter!": {
		Doc: "Set ebiten.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//filter!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//filter?": {
		Doc: "Get ebiten.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//filter?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"dropped-files": {
		Doc: "ebiten.DroppedFiles",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.DroppedFiles()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath() + "." + typPfx + typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fs-fs")
				}
			}
			return res0Obj
		},
	},
	"even-odd": {
		Doc: "Get ebiten.EvenOdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.EvenOdd)))
			return resObj
		},
	},
	"fill-all": {
		Doc: "Get ebiten.FillAll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FillAll)))
			return resObj
		},
	},
	"filter-linear": {
		Doc: "Get ebiten.FilterLinear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterLinear)))
			return resObj
		},
	},
	"filter-nearest": {
		Doc: "Get ebiten.FilterNearest value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterNearest)))
			return resObj
		},
	},
	"ebiten-final-screen-drawer//draw-final-screen": {
		Doc: "ebiten.FinalScreenDrawer.DrawFinalScreen",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreenDrawer
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_FinalScreenDrawer{
					self: v,
				}
				ctxObj0, ok := wordToObj["draw-final-screen"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: context to ebiten.FinalScreenDrawer: expected context to have function draw-final-screen")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 3 {
						ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: context to ebiten.FinalScreenDrawer: context fn draw-final-screen: function has invalid number of arguments (expected 3)")
					}
					impl.fn_DrawFinalScreen = func(ctx env.RyeCtx, arg0 ebiten.FinalScreen, arg1 *ebiten.Image, arg2 ebiten.GeoM) {
						var arg0Val, arg1Val, arg2Val env.Object
						{
							typ := reflect.TypeOf(arg0)
							var typPfx string
							if typ.Kind() == reflect.Pointer {
								typPfx = "*"
								typ = typ.Elem()
							}
							typRyeName, ok := ryeStructNameLookup[typ.PkgPath() + "." + typPfx + typ.Name()]
							if ok {
								arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
							} else {
								arg0Val = *env.NewNative(ps.Idx, arg0, "ebiten-final-screen")
							}
						}
						arg1Val = *env.NewNative(ps.Idx, arg1, "ptr-ebiten-image")
						arg2Val = *env.NewNative(ps.Idx, arg2, "ebiten-geo-m")
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val, arg2Val)
					}
				case env.Integer:
					if fn.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: context to ebiten.FinalScreenDrawer: context fn draw-final-screen: expected integer to be 0 or nil")
					}
					impl.fn_DrawFinalScreen = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: context to ebiten.FinalScreenDrawer: context fn draw-final-screen: expected function or nil")
				}
				arg0Val = impl
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreenDrawer)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected native of type ebiten.FinalScreenDrawer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected native")
			}
			var arg1Val ebiten.FinalScreen
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected native")
			}
			var arg2Val *ebiten.Image
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected native")
			}
			var arg3Val ebiten.GeoM
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected native")
			}
			arg0Val.DrawFinalScreen(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ebiten-final-screen//bounds": {
		Doc: "ebiten.FinalScreen.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//bounds: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-rectangle")
			return res0Obj
		},
	},
	"ebiten-final-screen//clear": {
		Doc: "ebiten.FinalScreen.Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//clear: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//clear: arg 1: expected native")
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"ebiten-final-screen//draw-image": {
		Doc: "ebiten.FinalScreen.DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 2: expected native")
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 3: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-image: arg 3: expected native")
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-rect-shader": {
		Doc: "ebiten.FinalScreen.DrawRectShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 3: expected integer")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawRectShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawRectShaderOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected native of type *ebiten.DrawRectShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected native")
			}
			arg0Val.DrawRectShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-triangles": {
		Doc: "ebiten.FinalScreen.DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected native")
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-triangles-shader": {
		Doc: "ebiten.FinalScreen.DrawTrianglesShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected native")
			}
			arg0Val.DrawTrianglesShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//fill": {
		Doc: "ebiten.FinalScreen.Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//fill: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//fill: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-final-screen//fill: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-final-screen//fill: arg 2: expected native")
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"fps-mode": {
		Doc: "ebiten.FPSMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.FPSMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"fps-mode-vsync-off-maximum": {
		Doc: "Get ebiten.FPSModeVsyncOffMaximum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOffMaximum)))
			return resObj
		},
	},
	"fps-mode-vsync-off-minimum": {
		Doc: "Get ebiten.FPSModeVsyncOffMinimum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOffMinimum)))
			return resObj
		},
	},
	"fps-mode-vsync-on": {
		Doc: "Get ebiten.FPSModeVsyncOn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOn)))
			return resObj
		},
	},
	"ebiten-game//draw": {
		Doc: "ebiten.Game.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//draw: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//draw: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//draw: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//draw: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//draw: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//draw: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 1: expected native")
				}
				var arg1Val *ebiten.Image
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*ebiten.Image)
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 2: expected native of type *ebiten.Image")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebiten-game//draw: arg 2: expected native")
				}
				arg0Val.Draw(arg1Val)
				return arg0
		},
	},
	"ebiten-game//layout": {
		Doc: "ebiten.Game.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//layout: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//layout: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//layout: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//layout: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//layout: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//layout: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 1: expected native")
				}
				var arg1Val int
				if v, ok := arg1.(env.Integer); ok {
					arg1Val = int(v.Value)
				} else {
					ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 2: expected integer")
				}
				var arg2Val int
				if v, ok := arg2.(env.Integer); ok {
					arg2Val = int(v.Value)
				} else {
					ps.FailureFlag = true
return env.NewError("ebiten-game//layout: arg 3: expected integer")
				}
				res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
				var res0Obj env.Object
				res0Obj = *env.NewInteger(int64(res0))
				var res1Obj env.Object
				res1Obj = *env.NewInteger(int64(res1))
				return env.NewDict(map[string]any{
					"screen-width": res0Obj,
					"screen-height": res1Obj,
				})
		},
	},
	"ebiten-game//update": {
		Doc: "ebiten.Game.Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//update: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//update: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//update: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//update: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//update: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-game//update: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebiten-game//update: arg 1: expected native")
				}
				res0 := arg0Val.Update()
				var res0Obj env.Object
				res0Obj = *env.NewError(res0.Error())
				return res0Obj
		},
	},
	"gamepad-axis": {
		Doc: "ebiten.GamepadAxis",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-axis: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-axis: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxis(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-count": {
		Doc: "ebiten.GamepadAxisCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-axis-count: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadAxisCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-num": {
		Doc: "ebiten.GamepadAxisNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-axis-num: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadAxisNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-value": {
		Doc: "ebiten.GamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-axis-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-axis-value: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-button-0": {
		Doc: "Get ebiten.GamepadButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton0)))
			return resObj
		},
	},
	"gamepad-button-1": {
		Doc: "Get ebiten.GamepadButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton1)))
			return resObj
		},
	},
	"gamepad-button-10": {
		Doc: "Get ebiten.GamepadButton10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton10)))
			return resObj
		},
	},
	"gamepad-button-11": {
		Doc: "Get ebiten.GamepadButton11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton11)))
			return resObj
		},
	},
	"gamepad-button-12": {
		Doc: "Get ebiten.GamepadButton12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton12)))
			return resObj
		},
	},
	"gamepad-button-13": {
		Doc: "Get ebiten.GamepadButton13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton13)))
			return resObj
		},
	},
	"gamepad-button-14": {
		Doc: "Get ebiten.GamepadButton14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton14)))
			return resObj
		},
	},
	"gamepad-button-15": {
		Doc: "Get ebiten.GamepadButton15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton15)))
			return resObj
		},
	},
	"gamepad-button-16": {
		Doc: "Get ebiten.GamepadButton16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton16)))
			return resObj
		},
	},
	"gamepad-button-17": {
		Doc: "Get ebiten.GamepadButton17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton17)))
			return resObj
		},
	},
	"gamepad-button-18": {
		Doc: "Get ebiten.GamepadButton18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton18)))
			return resObj
		},
	},
	"gamepad-button-19": {
		Doc: "Get ebiten.GamepadButton19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton19)))
			return resObj
		},
	},
	"gamepad-button-2": {
		Doc: "Get ebiten.GamepadButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton2)))
			return resObj
		},
	},
	"gamepad-button-20": {
		Doc: "Get ebiten.GamepadButton20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton20)))
			return resObj
		},
	},
	"gamepad-button-21": {
		Doc: "Get ebiten.GamepadButton21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton21)))
			return resObj
		},
	},
	"gamepad-button-22": {
		Doc: "Get ebiten.GamepadButton22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton22)))
			return resObj
		},
	},
	"gamepad-button-23": {
		Doc: "Get ebiten.GamepadButton23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton23)))
			return resObj
		},
	},
	"gamepad-button-24": {
		Doc: "Get ebiten.GamepadButton24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton24)))
			return resObj
		},
	},
	"gamepad-button-25": {
		Doc: "Get ebiten.GamepadButton25 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton25)))
			return resObj
		},
	},
	"gamepad-button-26": {
		Doc: "Get ebiten.GamepadButton26 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton26)))
			return resObj
		},
	},
	"gamepad-button-27": {
		Doc: "Get ebiten.GamepadButton27 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton27)))
			return resObj
		},
	},
	"gamepad-button-28": {
		Doc: "Get ebiten.GamepadButton28 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton28)))
			return resObj
		},
	},
	"gamepad-button-29": {
		Doc: "Get ebiten.GamepadButton29 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton29)))
			return resObj
		},
	},
	"gamepad-button-3": {
		Doc: "Get ebiten.GamepadButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton3)))
			return resObj
		},
	},
	"gamepad-button-30": {
		Doc: "Get ebiten.GamepadButton30 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton30)))
			return resObj
		},
	},
	"gamepad-button-31": {
		Doc: "Get ebiten.GamepadButton31 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton31)))
			return resObj
		},
	},
	"gamepad-button-4": {
		Doc: "Get ebiten.GamepadButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton4)))
			return resObj
		},
	},
	"gamepad-button-5": {
		Doc: "Get ebiten.GamepadButton5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton5)))
			return resObj
		},
	},
	"gamepad-button-6": {
		Doc: "Get ebiten.GamepadButton6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton6)))
			return resObj
		},
	},
	"gamepad-button-7": {
		Doc: "Get ebiten.GamepadButton7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton7)))
			return resObj
		},
	},
	"gamepad-button-8": {
		Doc: "Get ebiten.GamepadButton8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton8)))
			return resObj
		},
	},
	"gamepad-button-9": {
		Doc: "Get ebiten.GamepadButton9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton9)))
			return resObj
		},
	},
	"gamepad-button-count": {
		Doc: "ebiten.GamepadButtonCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-button-count: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadButtonCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-button-max": {
		Doc: "Get ebiten.GamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButtonMax)))
			return resObj
		},
	},
	"gamepad-button-num": {
		Doc: "ebiten.GamepadButtonNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-button-num: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadButtonNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-i-ds": {
		Doc: "ebiten.GamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.GamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"gamepad-name": {
		Doc: "ebiten.GamepadName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-name: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"gamepad-sdlid": {
		Doc: "ebiten.GamepadSDLID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("gamepad-sdlid: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadSDLID(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"graphics-library-auto": {
		Doc: "Get ebiten.GraphicsLibraryAuto value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryAuto)))
			return resObj
		},
	},
	"graphics-library-direct-x": {
		Doc: "Get ebiten.GraphicsLibraryDirectX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryDirectX)))
			return resObj
		},
	},
	"graphics-library-metal": {
		Doc: "Get ebiten.GraphicsLibraryMetal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryMetal)))
			return resObj
		},
	},
	"graphics-library-open-gl": {
		Doc: "Get ebiten.GraphicsLibraryOpenGL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryOpenGL)))
			return resObj
		},
	},
	"graphics-library-play-station-5": {
		Doc: "Get ebiten.GraphicsLibraryPlayStation5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryPlayStation5)))
			return resObj
		},
	},
	"graphics-library-unknown": {
		Doc: "Get ebiten.GraphicsLibraryUnknown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryUnknown)))
			return resObj
		},
	},
	"ebiten-graphics-library//string": {
		Doc: "ebiten.GraphicsLibrary.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GraphicsLibrary
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-graphics-library//string: arg 1: expected integer")
					}
					arg0Val = ebiten.GraphicsLibrary(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"input-chars": {
		Doc: "ebiten.InputChars",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.InputChars()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"is-focused": {
		Doc: "ebiten.IsFocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsFocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-fullscreen": {
		Doc: "ebiten.IsFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-gamepad-button-pressed": {
		Doc: "ebiten.IsGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-gamepad-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-gamepad-button-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := ebiten.IsGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-key-pressed": {
		Doc: "ebiten.IsKeyPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-key-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.IsKeyPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-mouse-button-pressed": {
		Doc: "ebiten.IsMouseButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-mouse-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := ebiten.IsMouseButtonPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-runnable-on-unfocused": {
		Doc: "ebiten.IsRunnableOnUnfocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsRunnableOnUnfocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-cleared-every-frame": {
		Doc: "ebiten.IsScreenClearedEveryFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenClearedEveryFrame()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-filter-enabled": {
		Doc: "ebiten.IsScreenFilterEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenFilterEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-transparent": {
		Doc: "ebiten.IsScreenTransparent",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenTransparent()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-axis-available": {
		Doc: "ebiten.IsStandardGamepadAxisAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-axis-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadAxis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadAxis
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadAxis)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-axis-available: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadAxis(u)
				}
			}
			res0 := ebiten.IsStandardGamepadAxisAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-available": {
		Doc: "ebiten.IsStandardGamepadButtonAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-button-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-button-available: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.IsStandardGamepadButtonAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-pressed": {
		Doc: "ebiten.IsStandardGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-button-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.IsStandardGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-layout-available": {
		Doc: "ebiten.IsStandardGamepadLayoutAvailable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("is-standard-gamepad-layout-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.IsStandardGamepadLayoutAvailable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-vsync-enabled": {
		Doc: "ebiten.IsVsyncEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsVsyncEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-being-closed": {
		Doc: "ebiten.IsWindowBeingClosed",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowBeingClosed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-closing-handled": {
		Doc: "ebiten.IsWindowClosingHandled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowClosingHandled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-decorated": {
		Doc: "ebiten.IsWindowDecorated",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowDecorated()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-floating": {
		Doc: "ebiten.IsWindowFloating",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowFloating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-maximized": {
		Doc: "ebiten.IsWindowMaximized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMaximized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-minimized": {
		Doc: "ebiten.IsWindowMinimized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMinimized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-mouse-passthrough": {
		Doc: "ebiten.IsWindowMousePassthrough",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMousePassthrough()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-resizable": {
		Doc: "ebiten.IsWindowResizable",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowResizable()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"key-0": {
		Doc: "Get ebiten.Key0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key0)))
			return resObj
		},
	},
	"key-1": {
		Doc: "Get ebiten.Key1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key1)))
			return resObj
		},
	},
	"key-2": {
		Doc: "Get ebiten.Key2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key2)))
			return resObj
		},
	},
	"key-3": {
		Doc: "Get ebiten.Key3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key3)))
			return resObj
		},
	},
	"key-4": {
		Doc: "Get ebiten.Key4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key4)))
			return resObj
		},
	},
	"key-5": {
		Doc: "Get ebiten.Key5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key5)))
			return resObj
		},
	},
	"key-6": {
		Doc: "Get ebiten.Key6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key6)))
			return resObj
		},
	},
	"key-7": {
		Doc: "Get ebiten.Key7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key7)))
			return resObj
		},
	},
	"key-8": {
		Doc: "Get ebiten.Key8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key8)))
			return resObj
		},
	},
	"key-9": {
		Doc: "Get ebiten.Key9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key9)))
			return resObj
		},
	},
	"key-a": {
		Doc: "Get ebiten.KeyA value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyA)))
			return resObj
		},
	},
	"key-alt": {
		Doc: "Get ebiten.KeyAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAlt)))
			return resObj
		},
	},
	"key-alt-left": {
		Doc: "Get ebiten.KeyAltLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltLeft)))
			return resObj
		},
	},
	"key-alt-right": {
		Doc: "Get ebiten.KeyAltRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltRight)))
			return resObj
		},
	},
	"key-apostrophe": {
		Doc: "Get ebiten.KeyApostrophe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyApostrophe)))
			return resObj
		},
	},
	"key-arrow-down": {
		Doc: "Get ebiten.KeyArrowDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowDown)))
			return resObj
		},
	},
	"key-arrow-left": {
		Doc: "Get ebiten.KeyArrowLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowLeft)))
			return resObj
		},
	},
	"key-arrow-right": {
		Doc: "Get ebiten.KeyArrowRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowRight)))
			return resObj
		},
	},
	"key-arrow-up": {
		Doc: "Get ebiten.KeyArrowUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowUp)))
			return resObj
		},
	},
	"key-b": {
		Doc: "Get ebiten.KeyB value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyB)))
			return resObj
		},
	},
	"key-backquote": {
		Doc: "Get ebiten.KeyBackquote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackquote)))
			return resObj
		},
	},
	"key-backslash": {
		Doc: "Get ebiten.KeyBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackslash)))
			return resObj
		},
	},
	"key-backspace": {
		Doc: "Get ebiten.KeyBackspace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackspace)))
			return resObj
		},
	},
	"key-bracket-left": {
		Doc: "Get ebiten.KeyBracketLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketLeft)))
			return resObj
		},
	},
	"key-bracket-right": {
		Doc: "Get ebiten.KeyBracketRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketRight)))
			return resObj
		},
	},
	"key-c": {
		Doc: "Get ebiten.KeyC value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyC)))
			return resObj
		},
	},
	"key-caps-lock": {
		Doc: "Get ebiten.KeyCapsLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyCapsLock)))
			return resObj
		},
	},
	"key-comma": {
		Doc: "Get ebiten.KeyComma value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyComma)))
			return resObj
		},
	},
	"key-context-menu": {
		Doc: "Get ebiten.KeyContextMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyContextMenu)))
			return resObj
		},
	},
	"key-control": {
		Doc: "Get ebiten.KeyControl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControl)))
			return resObj
		},
	},
	"key-control-left": {
		Doc: "Get ebiten.KeyControlLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlLeft)))
			return resObj
		},
	},
	"key-control-right": {
		Doc: "Get ebiten.KeyControlRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlRight)))
			return resObj
		},
	},
	"key-d": {
		Doc: "Get ebiten.KeyD value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyD)))
			return resObj
		},
	},
	"key-delete": {
		Doc: "Get ebiten.KeyDelete value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDelete)))
			return resObj
		},
	},
	"key-digit-0": {
		Doc: "Get ebiten.KeyDigit0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit0)))
			return resObj
		},
	},
	"key-digit-1": {
		Doc: "Get ebiten.KeyDigit1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit1)))
			return resObj
		},
	},
	"key-digit-2": {
		Doc: "Get ebiten.KeyDigit2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit2)))
			return resObj
		},
	},
	"key-digit-3": {
		Doc: "Get ebiten.KeyDigit3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit3)))
			return resObj
		},
	},
	"key-digit-4": {
		Doc: "Get ebiten.KeyDigit4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit4)))
			return resObj
		},
	},
	"key-digit-5": {
		Doc: "Get ebiten.KeyDigit5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit5)))
			return resObj
		},
	},
	"key-digit-6": {
		Doc: "Get ebiten.KeyDigit6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit6)))
			return resObj
		},
	},
	"key-digit-7": {
		Doc: "Get ebiten.KeyDigit7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit7)))
			return resObj
		},
	},
	"key-digit-8": {
		Doc: "Get ebiten.KeyDigit8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit8)))
			return resObj
		},
	},
	"key-digit-9": {
		Doc: "Get ebiten.KeyDigit9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit9)))
			return resObj
		},
	},
	"key-down": {
		Doc: "Get ebiten.KeyDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDown)))
			return resObj
		},
	},
	"key-e": {
		Doc: "Get ebiten.KeyE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyE)))
			return resObj
		},
	},
	"key-end": {
		Doc: "Get ebiten.KeyEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnd)))
			return resObj
		},
	},
	"key-enter": {
		Doc: "Get ebiten.KeyEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnter)))
			return resObj
		},
	},
	"key-equal": {
		Doc: "Get ebiten.KeyEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEqual)))
			return resObj
		},
	},
	"key-escape": {
		Doc: "Get ebiten.KeyEscape value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEscape)))
			return resObj
		},
	},
	"key-f": {
		Doc: "Get ebiten.KeyF value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF)))
			return resObj
		},
	},
	"key-f-1": {
		Doc: "Get ebiten.KeyF1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF1)))
			return resObj
		},
	},
	"key-f-10": {
		Doc: "Get ebiten.KeyF10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF10)))
			return resObj
		},
	},
	"key-f-11": {
		Doc: "Get ebiten.KeyF11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF11)))
			return resObj
		},
	},
	"key-f-12": {
		Doc: "Get ebiten.KeyF12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF12)))
			return resObj
		},
	},
	"key-f-13": {
		Doc: "Get ebiten.KeyF13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF13)))
			return resObj
		},
	},
	"key-f-14": {
		Doc: "Get ebiten.KeyF14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF14)))
			return resObj
		},
	},
	"key-f-15": {
		Doc: "Get ebiten.KeyF15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF15)))
			return resObj
		},
	},
	"key-f-16": {
		Doc: "Get ebiten.KeyF16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF16)))
			return resObj
		},
	},
	"key-f-17": {
		Doc: "Get ebiten.KeyF17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF17)))
			return resObj
		},
	},
	"key-f-18": {
		Doc: "Get ebiten.KeyF18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF18)))
			return resObj
		},
	},
	"key-f-19": {
		Doc: "Get ebiten.KeyF19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF19)))
			return resObj
		},
	},
	"key-f-2": {
		Doc: "Get ebiten.KeyF2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF2)))
			return resObj
		},
	},
	"key-f-20": {
		Doc: "Get ebiten.KeyF20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF20)))
			return resObj
		},
	},
	"key-f-21": {
		Doc: "Get ebiten.KeyF21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF21)))
			return resObj
		},
	},
	"key-f-22": {
		Doc: "Get ebiten.KeyF22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF22)))
			return resObj
		},
	},
	"key-f-23": {
		Doc: "Get ebiten.KeyF23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF23)))
			return resObj
		},
	},
	"key-f-24": {
		Doc: "Get ebiten.KeyF24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF24)))
			return resObj
		},
	},
	"key-f-3": {
		Doc: "Get ebiten.KeyF3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF3)))
			return resObj
		},
	},
	"key-f-4": {
		Doc: "Get ebiten.KeyF4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF4)))
			return resObj
		},
	},
	"key-f-5": {
		Doc: "Get ebiten.KeyF5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF5)))
			return resObj
		},
	},
	"key-f-6": {
		Doc: "Get ebiten.KeyF6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF6)))
			return resObj
		},
	},
	"key-f-7": {
		Doc: "Get ebiten.KeyF7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF7)))
			return resObj
		},
	},
	"key-f-8": {
		Doc: "Get ebiten.KeyF8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF8)))
			return resObj
		},
	},
	"key-f-9": {
		Doc: "Get ebiten.KeyF9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF9)))
			return resObj
		},
	},
	"key-g": {
		Doc: "Get ebiten.KeyG value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyG)))
			return resObj
		},
	},
	"key-grave-accent": {
		Doc: "Get ebiten.KeyGraveAccent value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyGraveAccent)))
			return resObj
		},
	},
	"key-h": {
		Doc: "Get ebiten.KeyH value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyH)))
			return resObj
		},
	},
	"key-home": {
		Doc: "Get ebiten.KeyHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyHome)))
			return resObj
		},
	},
	"key-i": {
		Doc: "Get ebiten.KeyI value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyI)))
			return resObj
		},
	},
	"key-insert": {
		Doc: "Get ebiten.KeyInsert value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyInsert)))
			return resObj
		},
	},
	"key-intl-backslash": {
		Doc: "Get ebiten.KeyIntlBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyIntlBackslash)))
			return resObj
		},
	},
	"key-j": {
		Doc: "Get ebiten.KeyJ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyJ)))
			return resObj
		},
	},
	"key-k": {
		Doc: "Get ebiten.KeyK value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyK)))
			return resObj
		},
	},
	"key-kp-0": {
		Doc: "Get ebiten.KeyKP0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP0)))
			return resObj
		},
	},
	"key-kp-1": {
		Doc: "Get ebiten.KeyKP1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP1)))
			return resObj
		},
	},
	"key-kp-2": {
		Doc: "Get ebiten.KeyKP2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP2)))
			return resObj
		},
	},
	"key-kp-3": {
		Doc: "Get ebiten.KeyKP3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP3)))
			return resObj
		},
	},
	"key-kp-4": {
		Doc: "Get ebiten.KeyKP4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP4)))
			return resObj
		},
	},
	"key-kp-5": {
		Doc: "Get ebiten.KeyKP5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP5)))
			return resObj
		},
	},
	"key-kp-6": {
		Doc: "Get ebiten.KeyKP6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP6)))
			return resObj
		},
	},
	"key-kp-7": {
		Doc: "Get ebiten.KeyKP7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP7)))
			return resObj
		},
	},
	"key-kp-8": {
		Doc: "Get ebiten.KeyKP8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP8)))
			return resObj
		},
	},
	"key-kp-9": {
		Doc: "Get ebiten.KeyKP9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP9)))
			return resObj
		},
	},
	"key-kp-add": {
		Doc: "Get ebiten.KeyKPAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPAdd)))
			return resObj
		},
	},
	"key-kp-decimal": {
		Doc: "Get ebiten.KeyKPDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDecimal)))
			return resObj
		},
	},
	"key-kp-divide": {
		Doc: "Get ebiten.KeyKPDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDivide)))
			return resObj
		},
	},
	"key-kp-enter": {
		Doc: "Get ebiten.KeyKPEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEnter)))
			return resObj
		},
	},
	"key-kp-equal": {
		Doc: "Get ebiten.KeyKPEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEqual)))
			return resObj
		},
	},
	"key-kp-multiply": {
		Doc: "Get ebiten.KeyKPMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPMultiply)))
			return resObj
		},
	},
	"key-kp-subtract": {
		Doc: "Get ebiten.KeyKPSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPSubtract)))
			return resObj
		},
	},
	"key-l": {
		Doc: "Get ebiten.KeyL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyL)))
			return resObj
		},
	},
	"key-left": {
		Doc: "Get ebiten.KeyLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeft)))
			return resObj
		},
	},
	"key-left-bracket": {
		Doc: "Get ebiten.KeyLeftBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeftBracket)))
			return resObj
		},
	},
	"key-m": {
		Doc: "Get ebiten.KeyM value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyM)))
			return resObj
		},
	},
	"key-max": {
		Doc: "Get ebiten.KeyMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMax)))
			return resObj
		},
	},
	"key-menu": {
		Doc: "Get ebiten.KeyMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMenu)))
			return resObj
		},
	},
	"key-meta": {
		Doc: "Get ebiten.KeyMeta value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMeta)))
			return resObj
		},
	},
	"key-meta-left": {
		Doc: "Get ebiten.KeyMetaLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaLeft)))
			return resObj
		},
	},
	"key-meta-right": {
		Doc: "Get ebiten.KeyMetaRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaRight)))
			return resObj
		},
	},
	"key-minus": {
		Doc: "Get ebiten.KeyMinus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMinus)))
			return resObj
		},
	},
	"key-n": {
		Doc: "Get ebiten.KeyN value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyN)))
			return resObj
		},
	},
	"key-name": {
		Doc: "ebiten.KeyName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("key-name: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.KeyName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"key-num-lock": {
		Doc: "Get ebiten.KeyNumLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumLock)))
			return resObj
		},
	},
	"key-numpad-0": {
		Doc: "Get ebiten.KeyNumpad0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad0)))
			return resObj
		},
	},
	"key-numpad-1": {
		Doc: "Get ebiten.KeyNumpad1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad1)))
			return resObj
		},
	},
	"key-numpad-2": {
		Doc: "Get ebiten.KeyNumpad2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad2)))
			return resObj
		},
	},
	"key-numpad-3": {
		Doc: "Get ebiten.KeyNumpad3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad3)))
			return resObj
		},
	},
	"key-numpad-4": {
		Doc: "Get ebiten.KeyNumpad4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad4)))
			return resObj
		},
	},
	"key-numpad-5": {
		Doc: "Get ebiten.KeyNumpad5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad5)))
			return resObj
		},
	},
	"key-numpad-6": {
		Doc: "Get ebiten.KeyNumpad6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad6)))
			return resObj
		},
	},
	"key-numpad-7": {
		Doc: "Get ebiten.KeyNumpad7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad7)))
			return resObj
		},
	},
	"key-numpad-8": {
		Doc: "Get ebiten.KeyNumpad8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad8)))
			return resObj
		},
	},
	"key-numpad-9": {
		Doc: "Get ebiten.KeyNumpad9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad9)))
			return resObj
		},
	},
	"key-numpad-add": {
		Doc: "Get ebiten.KeyNumpadAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadAdd)))
			return resObj
		},
	},
	"key-numpad-decimal": {
		Doc: "Get ebiten.KeyNumpadDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDecimal)))
			return resObj
		},
	},
	"key-numpad-divide": {
		Doc: "Get ebiten.KeyNumpadDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDivide)))
			return resObj
		},
	},
	"key-numpad-enter": {
		Doc: "Get ebiten.KeyNumpadEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEnter)))
			return resObj
		},
	},
	"key-numpad-equal": {
		Doc: "Get ebiten.KeyNumpadEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEqual)))
			return resObj
		},
	},
	"key-numpad-multiply": {
		Doc: "Get ebiten.KeyNumpadMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadMultiply)))
			return resObj
		},
	},
	"key-numpad-subtract": {
		Doc: "Get ebiten.KeyNumpadSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadSubtract)))
			return resObj
		},
	},
	"key-o": {
		Doc: "Get ebiten.KeyO value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyO)))
			return resObj
		},
	},
	"key-p": {
		Doc: "Get ebiten.KeyP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyP)))
			return resObj
		},
	},
	"key-page-down": {
		Doc: "Get ebiten.KeyPageDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageDown)))
			return resObj
		},
	},
	"key-page-up": {
		Doc: "Get ebiten.KeyPageUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageUp)))
			return resObj
		},
	},
	"key-pause": {
		Doc: "Get ebiten.KeyPause value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPause)))
			return resObj
		},
	},
	"key-period": {
		Doc: "Get ebiten.KeyPeriod value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPeriod)))
			return resObj
		},
	},
	"key-print-screen": {
		Doc: "Get ebiten.KeyPrintScreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPrintScreen)))
			return resObj
		},
	},
	"key-q": {
		Doc: "Get ebiten.KeyQ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQ)))
			return resObj
		},
	},
	"key-quote": {
		Doc: "Get ebiten.KeyQuote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQuote)))
			return resObj
		},
	},
	"key-r": {
		Doc: "Get ebiten.KeyR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyR)))
			return resObj
		},
	},
	"key-right": {
		Doc: "Get ebiten.KeyRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRight)))
			return resObj
		},
	},
	"key-right-bracket": {
		Doc: "Get ebiten.KeyRightBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRightBracket)))
			return resObj
		},
	},
	"key-s": {
		Doc: "Get ebiten.KeyS value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyS)))
			return resObj
		},
	},
	"key-scroll-lock": {
		Doc: "Get ebiten.KeyScrollLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyScrollLock)))
			return resObj
		},
	},
	"key-semicolon": {
		Doc: "Get ebiten.KeySemicolon value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySemicolon)))
			return resObj
		},
	},
	"key-shift": {
		Doc: "Get ebiten.KeyShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShift)))
			return resObj
		},
	},
	"key-shift-left": {
		Doc: "Get ebiten.KeyShiftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftLeft)))
			return resObj
		},
	},
	"key-shift-right": {
		Doc: "Get ebiten.KeyShiftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftRight)))
			return resObj
		},
	},
	"key-slash": {
		Doc: "Get ebiten.KeySlash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySlash)))
			return resObj
		},
	},
	"key-space": {
		Doc: "Get ebiten.KeySpace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySpace)))
			return resObj
		},
	},
	"key-t": {
		Doc: "Get ebiten.KeyT value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyT)))
			return resObj
		},
	},
	"key-tab": {
		Doc: "Get ebiten.KeyTab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyTab)))
			return resObj
		},
	},
	"key-u": {
		Doc: "Get ebiten.KeyU value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyU)))
			return resObj
		},
	},
	"key-up": {
		Doc: "Get ebiten.KeyUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyUp)))
			return resObj
		},
	},
	"key-v": {
		Doc: "Get ebiten.KeyV value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyV)))
			return resObj
		},
	},
	"key-w": {
		Doc: "Get ebiten.KeyW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyW)))
			return resObj
		},
	},
	"key-x": {
		Doc: "Get ebiten.KeyX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyX)))
			return resObj
		},
	},
	"key-y": {
		Doc: "Get ebiten.KeyY value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyY)))
			return resObj
		},
	},
	"key-z": {
		Doc: "Get ebiten.KeyZ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyZ)))
			return resObj
		},
	},
	"ebiten-key//marshal-text": {
		Doc: "ebiten.Key.MarshalText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-key//marshal-text: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, res1 := arg0Val.MarshalText()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ebiten-key//string": {
		Doc: "ebiten.Key.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-key//string: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ebiten-layout-fer//layout-f": {
		Doc: "ebiten.LayoutFer.LayoutF",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.LayoutFer
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_LayoutFer{
					self: v,
				}
				ctxObj0, ok := wordToObj["layout-f"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: context to ebiten.LayoutFer: expected context to have function layout-f")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 2 {
						ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: context to ebiten.LayoutFer: context fn layout-f: function has invalid number of arguments (expected 2)")
					}
					impl.fn_LayoutF = func(ctx env.RyeCtx, arg0 float64, arg1 float64) (float64, float64) {
						var arg0Val, arg1Val env.Object
						arg0Val = *env.NewDecimal(float64(arg0))
						arg1Val = *env.NewDecimal(float64(arg1))
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
						var res0 float64
						var res1 float64
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-layout-fer//layout-f: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-layout-fer//layout-f: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Decimal); ok {
							res0 = float64(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-layout-fer//layout-f: arg 1: callback result: expected decimal",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[1].(env.Decimal); ok {
							res1 = float64(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebiten-layout-fer//layout-f: arg 1: callback result: expected decimal",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						return res0, res1
					}
				case env.Integer:
					if fn.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: context to ebiten.LayoutFer: context fn layout-f: expected integer to be 0 or nil")
					}
					impl.fn_LayoutF = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: context to ebiten.LayoutFer: context fn layout-f: expected function or nil")
				}
				arg0Val = impl
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.LayoutFer)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected native of type ebiten.LayoutFer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-layout-fer//layout-f: arg 3: expected decimal")
			}
			res0, res1 := arg0Val.LayoutF(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"screen-width": res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"max-tps": {
		Doc: "ebiten.MaxTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.MaxTPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"maximize-window": {
		Doc: "ebiten.MaximizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.MaximizeWindow()
			return nil
		},
	},
	"minimize-window": {
		Doc: "ebiten.MinimizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.MinimizeWindow()
			return nil
		},
	},
	"monitor": {
		Doc: "ebiten.Monitor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.Monitor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-monitor-type")
			return res0Obj
		},
	},
	"mouse-button-0": {
		Doc: "Get ebiten.MouseButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton0)))
			return resObj
		},
	},
	"mouse-button-1": {
		Doc: "Get ebiten.MouseButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton1)))
			return resObj
		},
	},
	"mouse-button-2": {
		Doc: "Get ebiten.MouseButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton2)))
			return resObj
		},
	},
	"mouse-button-3": {
		Doc: "Get ebiten.MouseButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton3)))
			return resObj
		},
	},
	"mouse-button-4": {
		Doc: "Get ebiten.MouseButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton4)))
			return resObj
		},
	},
	"mouse-button-left": {
		Doc: "Get ebiten.MouseButtonLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonLeft)))
			return resObj
		},
	},
	"mouse-button-max": {
		Doc: "Get ebiten.MouseButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonMax)))
			return resObj
		},
	},
	"mouse-button-middle": {
		Doc: "Get ebiten.MouseButtonMiddle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonMiddle)))
			return resObj
		},
	},
	"mouse-button-right": {
		Doc: "Get ebiten.MouseButtonRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonRight)))
			return resObj
		},
	},
	"shader": {
		Doc: "ebiten.NewShader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("shader: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("shader: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
return env.NewError("shader: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("shader: arg 1: expected block, native or nil")
			}
			res0, res1 := ebiten.NewShader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-shader")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"non-zero": {
		Doc: "Get ebiten.NonZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.NonZero)))
			return resObj
		},
	},
	"restore-window": {
		Doc: "ebiten.RestoreWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.RestoreWindow()
			return nil
		},
	},
	"run-game": {
		Doc: "ebiten.RunGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("run-game: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("run-game: arg 1: expected native")
				}
				res0 := ebiten.RunGame(arg0Val)
				var res0Obj env.Object
				res0Obj = *env.NewError(res0.Error())
				return res0Obj
		},
	},
	"ebiten-run-game-options//graphics-library!": {
		Doc: "Set ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//graphics-library!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ebiten-run-game-options//graphics-library?": {
		Doc: "Get ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//graphics-library?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ebiten-run-game-options//init-unfocused!": {
		Doc: "Set ebiten.RunGameOptions InitUnfocused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//init-unfocused!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//init-unfocused!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.InitUnfocused = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//init-unfocused!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//init-unfocused?": {
		Doc: "Get ebiten.RunGameOptions InitUnfocused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//init-unfocused?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//init-unfocused?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.InitUnfocused))
			return resObj
		},
	},
	"ebiten-run-game-options//screen-transparent!": {
		Doc: "Set ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//screen-transparent!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//screen-transparent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScreenTransparent = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//screen-transparent!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//screen-transparent?": {
		Doc: "Get ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//screen-transparent?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//screen-transparent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScreenTransparent))
			return resObj
		},
	},
	"ebiten-run-game-options//single-thread!": {
		Doc: "Set ebiten.RunGameOptions SingleThread value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//single-thread!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//single-thread!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SingleThread = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//single-thread!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//single-thread?": {
		Doc: "Get ebiten.RunGameOptions SingleThread value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//single-thread?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//single-thread?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleThread))
			return resObj
		},
	},
	"ebiten-run-game-options//skip-taskbar!": {
		Doc: "Set ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//skip-taskbar!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//skip-taskbar!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SkipTaskbar = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//skip-taskbar!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//skip-taskbar?": {
		Doc: "Get ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//skip-taskbar?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//skip-taskbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SkipTaskbar))
			return resObj
		},
	},
	"ebiten-run-game-options//x-11-class-name!": {
		Doc: "Set ebiten.RunGameOptions X11ClassName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-class-name!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-class-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11ClassName = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-class-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//x-11-class-name?": {
		Doc: "Get ebiten.RunGameOptions X11ClassName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-class-name?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-class-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11ClassName)
			return resObj
		},
	},
	"ebiten-run-game-options//x-11-instance-name!": {
		Doc: "Set ebiten.RunGameOptions X11InstanceName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-instance-name!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-instance-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11InstanceName = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-instance-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//x-11-instance-name?": {
		Doc: "Get ebiten.RunGameOptions X11InstanceName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-instance-name?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-run-game-options//x-11-instance-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11InstanceName)
			return resObj
		},
	},
	"run-game-with-options": {
		Doc: "ebiten.RunGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game-with-options: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game-with-options: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game-with-options: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game-with-options: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game-with-options: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"run-game-with-options: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 1: expected native")
				}
				var arg1Val *ebiten.RunGameOptions
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
					if !ok {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 2: expected native of type *ebiten.RunGameOptions")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("run-game-with-options: arg 2: expected native")
				}
				res0 := ebiten.RunGameWithOptions(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewError(res0.Error())
				return res0Obj
		},
	},
	"schedule-frame": {
		Doc: "ebiten.ScheduleFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			ebiten.ScheduleFrame()
			return nil
		},
	},
	"screen-size-in-fullscreen": {
		Doc: "ebiten.ScreenSizeInFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.ScreenSizeInFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"set-cursor-mode": {
		Doc: "ebiten.SetCursorMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.CursorModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CursorModeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("set-cursor-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.CursorModeType(u)
				}
			}
			ebiten.SetCursorMode(arg0Val)
			return nil
		},
	},
	"set-cursor-shape": {
		Doc: "ebiten.SetCursorShape",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorShapeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.CursorShapeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CursorShapeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("set-cursor-shape: arg 1: expected integer")
					}
					arg0Val = ebiten.CursorShapeType(u)
				}
			}
			ebiten.SetCursorShape(arg0Val)
			return nil
		},
	},
	"set-fps-mode": {
		Doc: "ebiten.SetFPSMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.FPSModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.FPSModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FPSModeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("set-fps-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.FPSModeType(u)
				}
			}
			ebiten.SetFPSMode(arg0Val)
			return nil
		},
	},
	"set-fullscreen": {
		Doc: "ebiten.SetFullscreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-fullscreen: arg 1: expected integer")
			}
			ebiten.SetFullscreen(arg0Val)
			return nil
		},
	},
	"set-init-focused": {
		Doc: "ebiten.SetInitFocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-init-focused: arg 1: expected integer")
			}
			ebiten.SetInitFocused(arg0Val)
			return nil
		},
	},
	"set-max-tps": {
		Doc: "ebiten.SetMaxTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-max-tps: arg 1: expected integer")
			}
			ebiten.SetMaxTPS(arg0Val)
			return nil
		},
	},
	"set-monitor": {
		Doc: "ebiten.SetMonitor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
return env.NewError("set-monitor: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("set-monitor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("set-monitor: arg 1: expected native")
			}
			ebiten.SetMonitor(arg0Val)
			return nil
		},
	},
	"set-runnable-on-unfocused": {
		Doc: "ebiten.SetRunnableOnUnfocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-runnable-on-unfocused: arg 1: expected integer")
			}
			ebiten.SetRunnableOnUnfocused(arg0Val)
			return nil
		},
	},
	"set-screen-cleared-every-frame": {
		Doc: "ebiten.SetScreenClearedEveryFrame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-screen-cleared-every-frame: arg 1: expected integer")
			}
			ebiten.SetScreenClearedEveryFrame(arg0Val)
			return nil
		},
	},
	"set-screen-filter-enabled": {
		Doc: "ebiten.SetScreenFilterEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-screen-filter-enabled: arg 1: expected integer")
			}
			ebiten.SetScreenFilterEnabled(arg0Val)
			return nil
		},
	},
	"set-screen-transparent": {
		Doc: "ebiten.SetScreenTransparent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-screen-transparent: arg 1: expected integer")
			}
			ebiten.SetScreenTransparent(arg0Val)
			return nil
		},
	},
	"set-tps": {
		Doc: "ebiten.SetTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-tps: arg 1: expected integer")
			}
			ebiten.SetTPS(arg0Val)
			return nil
		},
	},
	"set-vsync-enabled": {
		Doc: "ebiten.SetVsyncEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-vsync-enabled: arg 1: expected integer")
			}
			ebiten.SetVsyncEnabled(arg0Val)
			return nil
		},
	},
	"set-window-closing-handled": {
		Doc: "ebiten.SetWindowClosingHandled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-closing-handled: arg 1: expected integer")
			}
			ebiten.SetWindowClosingHandled(arg0Val)
			return nil
		},
	},
	"set-window-decorated": {
		Doc: "ebiten.SetWindowDecorated",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-decorated: arg 1: expected integer")
			}
			ebiten.SetWindowDecorated(arg0Val)
			return nil
		},
	},
	"set-window-floating": {
		Doc: "ebiten.SetWindowFloating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-floating: arg 1: expected integer")
			}
			ebiten.SetWindowFloating(arg0Val)
			return nil
		},
	},
	"set-window-icon": {
		Doc: "ebiten.SetWindowIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []image.Image
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]image.Image, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(image.Image)
						if !ok {
							ps.FailureFlag = true
return env.NewError("set-window-icon: arg 1: block item: expected native of type image.Image")
						}
					default:
						ps.FailureFlag = true
return env.NewError("set-window-icon: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]image.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("set-window-icon: arg 1: expected native of type []image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("set-window-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("set-window-icon: arg 1: expected block, native or nil")
			}
			ebiten.SetWindowIcon(arg0Val)
			return nil
		},
	},
	"set-window-mouse-passthrough": {
		Doc: "ebiten.SetWindowMousePassthrough",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-mouse-passthrough: arg 1: expected integer")
			}
			ebiten.SetWindowMousePassthrough(arg0Val)
			return nil
		},
	},
	"set-window-position": {
		Doc: "ebiten.SetWindowPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-position: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-position: arg 2: expected integer")
			}
			ebiten.SetWindowPosition(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-resizable": {
		Doc: "ebiten.SetWindowResizable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-resizable: arg 1: expected integer")
			}
			ebiten.SetWindowResizable(arg0Val)
			return nil
		},
	},
	"set-window-resizing-mode": {
		Doc: "ebiten.SetWindowResizingMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.WindowResizingModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.WindowResizingModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.WindowResizingModeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("set-window-resizing-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.WindowResizingModeType(u)
				}
			}
			ebiten.SetWindowResizingMode(arg0Val)
			return nil
		},
	},
	"set-window-size": {
		Doc: "ebiten.SetWindowSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-size: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-size: arg 2: expected integer")
			}
			ebiten.SetWindowSize(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-size-limits": {
		Doc: "ebiten.SetWindowSizeLimits",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-size-limits: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-size-limits: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-size-limits: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-size-limits: arg 4: expected integer")
			}
			ebiten.SetWindowSizeLimits(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"set-window-title": {
		Doc: "ebiten.SetWindowTitle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("set-window-title: arg 1: expected string")
			}
			ebiten.SetWindowTitle(arg0Val)
			return nil
		},
	},
	"standard-gamepad-axis-left-stick-horizontal": {
		Doc: "Get ebiten.StandardGamepadAxisLeftStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisLeftStickHorizontal)))
			return resObj
		},
	},
	"standard-gamepad-axis-left-stick-vertical": {
		Doc: "Get ebiten.StandardGamepadAxisLeftStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisLeftStickVertical)))
			return resObj
		},
	},
	"standard-gamepad-axis-max": {
		Doc: "Get ebiten.StandardGamepadAxisMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisMax)))
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-horizontal": {
		Doc: "Get ebiten.StandardGamepadAxisRightStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisRightStickHorizontal)))
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-vertical": {
		Doc: "Get ebiten.StandardGamepadAxisRightStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisRightStickVertical)))
			return resObj
		},
	},
	"standard-gamepad-axis-value": {
		Doc: "ebiten.StandardGamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("standard-gamepad-axis-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadAxis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadAxis
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadAxis)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("standard-gamepad-axis-value: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadAxis(u)
				}
			}
			res0 := ebiten.StandardGamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"standard-gamepad-button-center-center": {
		Doc: "Get ebiten.StandardGamepadButtonCenterCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterCenter)))
			return resObj
		},
	},
	"standard-gamepad-button-center-left": {
		Doc: "Get ebiten.StandardGamepadButtonCenterLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-center-right": {
		Doc: "Get ebiten.StandardGamepadButtonCenterRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterRight)))
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-left": {
		Doc: "Get ebiten.StandardGamepadButtonFrontBottomLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontBottomLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-right": {
		Doc: "Get ebiten.StandardGamepadButtonFrontBottomRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontBottomRight)))
			return resObj
		},
	},
	"standard-gamepad-button-front-top-left": {
		Doc: "Get ebiten.StandardGamepadButtonFrontTopLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontTopLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-front-top-right": {
		Doc: "Get ebiten.StandardGamepadButtonFrontTopRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontTopRight)))
			return resObj
		},
	},
	"standard-gamepad-button-left-bottom": {
		Doc: "Get ebiten.StandardGamepadButtonLeftBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftBottom)))
			return resObj
		},
	},
	"standard-gamepad-button-left-left": {
		Doc: "Get ebiten.StandardGamepadButtonLeftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-left-right": {
		Doc: "Get ebiten.StandardGamepadButtonLeftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftRight)))
			return resObj
		},
	},
	"standard-gamepad-button-left-stick": {
		Doc: "Get ebiten.StandardGamepadButtonLeftStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftStick)))
			return resObj
		},
	},
	"standard-gamepad-button-left-top": {
		Doc: "Get ebiten.StandardGamepadButtonLeftTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftTop)))
			return resObj
		},
	},
	"standard-gamepad-button-max": {
		Doc: "Get ebiten.StandardGamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonMax)))
			return resObj
		},
	},
	"standard-gamepad-button-right-bottom": {
		Doc: "Get ebiten.StandardGamepadButtonRightBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightBottom)))
			return resObj
		},
	},
	"standard-gamepad-button-right-left": {
		Doc: "Get ebiten.StandardGamepadButtonRightLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-right-right": {
		Doc: "Get ebiten.StandardGamepadButtonRightRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightRight)))
			return resObj
		},
	},
	"standard-gamepad-button-right-stick": {
		Doc: "Get ebiten.StandardGamepadButtonRightStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightStick)))
			return resObj
		},
	},
	"standard-gamepad-button-right-top": {
		Doc: "Get ebiten.StandardGamepadButtonRightTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightTop)))
			return resObj
		},
	},
	"standard-gamepad-button-value": {
		Doc: "ebiten.StandardGamepadButtonValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("standard-gamepad-button-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("standard-gamepad-button-value: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.StandardGamepadButtonValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"touch-i-ds": {
		Doc: "ebiten.TouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.TouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"touch-position": {
		Doc: "ebiten.TouchPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("touch-position: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0, res1 := ebiten.TouchPosition(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"tps": {
		Doc: "ebiten.TPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.TPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"update-standard-gamepad-layout-mappings": {
		Doc: "ebiten.UpdateStandardGamepadLayoutMappings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("update-standard-gamepad-layout-mappings: arg 1: expected string")
			}
			res0, res1 := ebiten.UpdateStandardGamepadLayoutMappings(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ebiten-vertex//color-a!": {
		Doc: "Set ebiten.Vertex ColorA value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-a!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorA = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-a!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-a?": {
		Doc: "Get ebiten.Vertex ColorA value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-a?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorA))
			return resObj
		},
	},
	"ebiten-vertex//color-b!": {
		Doc: "Set ebiten.Vertex ColorB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-b!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorB = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-b!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-b?": {
		Doc: "Get ebiten.Vertex ColorB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-b?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorB))
			return resObj
		},
	},
	"ebiten-vertex//color-g!": {
		Doc: "Set ebiten.Vertex ColorG value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-g!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorG = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-g!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-g?": {
		Doc: "Get ebiten.Vertex ColorG value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-g?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorG))
			return resObj
		},
	},
	"ebiten-vertex//color-r!": {
		Doc: "Set ebiten.Vertex ColorR value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-r!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorR = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-r!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-r?": {
		Doc: "Get ebiten.Vertex ColorR value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-r?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//color-r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorR))
			return resObj
		},
	},
	"ebiten-vertex//dst-x!": {
		Doc: "Set ebiten.Vertex DstX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-x!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstX = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//dst-x?": {
		Doc: "Get ebiten.Vertex DstX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-x?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstX))
			return resObj
		},
	},
	"ebiten-vertex//dst-y!": {
		Doc: "Set ebiten.Vertex DstY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-y!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstY = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//dst-y?": {
		Doc: "Get ebiten.Vertex DstY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-y?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//dst-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstY))
			return resObj
		},
	},
	"ebiten-vertex//src-x!": {
		Doc: "Set ebiten.Vertex SrcX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-x!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcX = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//src-x?": {
		Doc: "Get ebiten.Vertex SrcX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-x?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcX))
			return resObj
		},
	},
	"ebiten-vertex//src-y!": {
		Doc: "Set ebiten.Vertex SrcY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-y!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcY = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//src-y?": {
		Doc: "Get ebiten.Vertex SrcY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-y?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vertex//src-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcY))
			return resObj
		},
	},
	"vibrate": {
		Doc: "ebiten.Vibrate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vibrate: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("vibrate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("vibrate: arg 1: expected native")
			}
			ebiten.Vibrate(arg0Val)
			return nil
		},
	},
	"vibrate-gamepad": {
		Doc: "ebiten.VibrateGamepad",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("vibrate-gamepad: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val *ebiten.VibrateGamepadOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vibrate-gamepad: arg 2: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("vibrate-gamepad: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("vibrate-gamepad: arg 2: expected native")
			}
			ebiten.VibrateGamepad(arg0Val, arg1Val)
			return nil
		},
	},
	"ebiten-vibrate-gamepad-options//duration!": {
		Doc: "Set ebiten.VibrateGamepadOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-vibrate-gamepad-options//duration?": {
		Doc: "Get ebiten.VibrateGamepadOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//duration?: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ebiten-vibrate-gamepad-options//strong-magnitude!": {
		Doc: "Set ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrongMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vibrate-gamepad-options//strong-magnitude?": {
		Doc: "Get ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrongMagnitude))
			return resObj
		},
	},
	"ebiten-vibrate-gamepad-options//weak-magnitude!": {
		Doc: "Set ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.WeakMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vibrate-gamepad-options//weak-magnitude?": {
		Doc: "Get ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeakMagnitude))
			return resObj
		},
	},
	"ebiten-vibrate-options//duration!": {
		Doc: "Set ebiten.VibrateOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//duration!: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-vibrate-options//duration?": {
		Doc: "Get ebiten.VibrateOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//duration?: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ebiten-vibrate-options//magnitude!": {
		Doc: "Set ebiten.VibrateOptions Magnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//magnitude!: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Magnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vibrate-options//magnitude?": {
		Doc: "Get ebiten.VibrateOptions Magnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//magnitude?: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebiten-vibrate-options//magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Magnitude))
			return resObj
		},
	},
	"wheel": {
		Doc: "ebiten.Wheel",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.Wheel()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"xoff": res0Obj,
				"yoff": res1Obj,
			})
		},
	},
	"window-position": {
		Doc: "ebiten.WindowPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"x": res0Obj,
				"y": res1Obj,
			})
		},
	},
	"window-resizing-mode": {
		Doc: "ebiten.WindowResizingMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := ebiten.WindowResizingMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"window-resizing-mode-disabled": {
		Doc: "Get ebiten.WindowResizingModeDisabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeDisabled)))
			return resObj
		},
	},
	"window-resizing-mode-enabled": {
		Doc: "Get ebiten.WindowResizingModeEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeEnabled)))
			return resObj
		},
	},
	"window-resizing-mode-only-fullscreen-enabled": {
		Doc: "Get ebiten.WindowResizingModeOnlyFullscreenEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeOnlyFullscreenEnabled)))
			return resObj
		},
	},
	"window-size": {
		Doc: "ebiten.WindowSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"window-size-limits": {
		Doc: "ebiten.WindowSizeLimits",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1, res2, res3 := ebiten.WindowSizeLimits()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return env.NewDict(map[string]any{
				"minw": res0Obj,
				"minh": res1Obj,
				"maxw": res2Obj,
				"maxh": res3Obj,
			})
		},
	},
	"ebitenutil-debug-print": {
		Doc: "ebitenutil.DebugPrint",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print: arg 2: expected string")
			}
			ebitenutil.DebugPrint(arg0Val, arg1Val)
			return nil
		},
	},
	"ebitenutil-debug-print-at": {
		Doc: "ebitenutil.DebugPrintAt",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print-at: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print-at: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print-at: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print-at: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-debug-print-at: arg 4: expected integer")
			}
			ebitenutil.DebugPrintAt(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"ebitenutil-draw-circle": {
		Doc: "ebitenutil.DrawCircle",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 4: expected decimal")
			}
			var arg4Val color.Color
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 5: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ebitenutil-draw-circle: arg 5: expected native")
			}
			ebitenutil.DrawCircle(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val)
			return nil
		},
	},
	"ebitenutil-image-from-file": {
		Doc: "ebitenutil.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file: arg 1: expected string")
			}
			res0, res1, res2 := ebitenutil.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"err": res2Obj,
			})
		},
	},
	"ebitenutil-image-from-file-system": {
		Doc: "ebitenutil.NewImageFromFileSystem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val fs.FS
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_fs_FS{
					self: v,
				}
				ctxObj0, ok := wordToObj["open"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: context to fs.FS: expected context to have function open")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: context to fs.FS: context fn open: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Open = func(ctx env.RyeCtx, arg0 string) (fs.File, error) {
						var arg0Val env.Object
						arg0Val = *env.NewString(arg0)
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 fs.File
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[0].(type) {
						case env.RyeCtx:
							words := v.GetWords(*ps.Idx).Series.S
							wordToObj := make(map[string]env.Object, len(words))
							for _, word := range words {
								name := word.(env.String).Value
								idx, ok := ps.Idx.GetIndex(name)
								if !ok {
									panic("expected valid word")
								}
								obj, ok := v.Get(idx)
								if !ok {
									panic("expected valid index")
								}
								wordToObj[name] = obj
							}
							impl := &ryegen_fs_File{
								self: v,
							}
							ctxObj0, ok := wordToObj["stat"]
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: expected context to have function stat",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							switch fn := ctxObj0.(type) {
							case env.Function:
								if fn.Argsn != 0 {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn stat: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								impl.fn_Stat = func(ctx env.RyeCtx) (fs.FileInfo, error) {
									actualFn := fn
									_ = actualFn
									evaldo.CallFunctionArgsN(fn, ps, &ctx)
									var res0 fs.FileInfo
									var res1 error
									res, ok := ps.Res.(env.Block)
									if !ok {
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									if len(res.Series.S) != 2 {
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									switch v := res.Series.S[0].(type) {
									case env.RyeCtx:
										words := v.GetWords(*ps.Idx).Series.S
										wordToObj := make(map[string]env.Object, len(words))
										for _, word := range words {
											name := word.(env.String).Value
											idx, ok := ps.Idx.GetIndex(name)
											if !ok {
												panic("expected valid word")
											}
											obj, ok := v.Get(idx)
											if !ok {
												panic("expected valid index")
											}
											wordToObj[name] = obj
										}
										impl := &ryegen_fs_FileInfo{
											self: v,
										}
										ctxObj0, ok := wordToObj["name"]
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: expected context to have function name",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch fn := ctxObj0.(type) {
										case env.Function:
											if fn.Argsn != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn name: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Name = func(ctx env.RyeCtx) (string) {
												actualFn := fn
												_ = actualFn
												evaldo.CallFunctionArgsN(fn, ps, &ctx)
												var res string
												if v, ok := ps.Res.(env.String); ok {
													res = string(v.Value)
												} else {
													fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected string",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn name: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Name = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn name: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										ctxObj1, ok := wordToObj["size"]
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: expected context to have function size",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch fn := ctxObj1.(type) {
										case env.Function:
											if fn.Argsn != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn size: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Size = func(ctx env.RyeCtx) (int64) {
												actualFn := fn
												_ = actualFn
												evaldo.CallFunctionArgsN(fn, ps, &ctx)
												var res int64
												if v, ok := ps.Res.(env.Integer); ok {
													res = int64(v.Value)
												} else {
													fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn size: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Size = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn size: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										ctxObj2, ok := wordToObj["mode"]
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: expected context to have function mode",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch fn := ctxObj2.(type) {
										case env.Function:
											if fn.Argsn != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn mode: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Mode = func(ctx env.RyeCtx) (fs.FileMode) {
												actualFn := fn
												_ = actualFn
												evaldo.CallFunctionArgsN(fn, ps, &ctx)
												var res fs.FileMode
												{
													nat, natOk := ps.Res.(env.Native)
													var natValOk bool
													var natVal fs.FileMode
													if natOk {
														natVal, natValOk = nat.Value.(fs.FileMode)
													}
													if natOk && natValOk {
														res = natVal
													} else {
														var u uint32
														if v, ok := ps.Res.(env.Integer); ok {
															u = uint32(v.Value)
														} else {
															fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
														}
														res = fs.FileMode(u)
													}
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn mode: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Mode = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn mode: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										ctxObj3, ok := wordToObj["mod-time"]
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: expected context to have function mod-time",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch fn := ctxObj3.(type) {
										case env.Function:
											if fn.Argsn != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn mod-time: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_ModTime = func(ctx env.RyeCtx) (time.Time) {
												actualFn := fn
												_ = actualFn
												evaldo.CallFunctionArgsN(fn, ps, &ctx)
												var res time.Time
												switch v := ps.Res.(type) {
												case env.Native:
													var ok bool
													res, ok = v.Value.(time.Time)
													if !ok {
														fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native of type time.Time",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
													}
												default:
													fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn mod-time: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_ModTime = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn mod-time: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										ctxObj4, ok := wordToObj["is-dir"]
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: expected context to have function is-dir",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch fn := ctxObj4.(type) {
										case env.Function:
											if fn.Argsn != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn is-dir: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_IsDir = func(ctx env.RyeCtx) (bool) {
												actualFn := fn
												_ = actualFn
												evaldo.CallFunctionArgsN(fn, ps, &ctx)
												var res bool
												if v, ok := ps.Res.(env.Integer); ok {
													res = v.Value != 0
												} else {
													fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn is-dir: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_IsDir = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn is-dir: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										ctxObj5, ok := wordToObj["sys"]
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: expected context to have function sys",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch fn := ctxObj5.(type) {
										case env.Function:
											if fn.Argsn != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn sys: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Sys = func(ctx env.RyeCtx) (any) {
												actualFn := fn
												_ = actualFn
												evaldo.CallFunctionArgsN(fn, ps, &ctx)
												var res any
												switch v := ps.Res.(type) {
												case env.Native:
													var ok bool
													res, ok = v.Value.(any)
													if !ok {
														fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native of type any",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
													}
												default:
													fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn sys: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Sys = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.FileInfo: context fn sys: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										res0 = impl
									case env.Native:
										var ok bool
										res0, ok = v.Value.(fs.FileInfo)
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native of type fs.FileInfo",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
									case env.Integer:
										if v.Value != 0 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										res0 = nil
									default:
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									switch v := res.Series.S[1].(type) {
									case env.String:
										res1 = errors.New(v.Value)
									case env.Error:
										res1 = errors.New(v.Print(*ps.Idx))
									case env.Integer:
										if v.Value != 0 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										res1 = nil
									default:
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										return res0, res1
									}
								case env.Integer:
									if fn.Value != 0 {
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn stat: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									impl.fn_Stat = nil
								default:
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn stat: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								ctxObj1, ok := wordToObj["read"]
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: expected context to have function read",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
								}
								switch fn := ctxObj1.(type) {
								case env.Function:
									if fn.Argsn != 1 {
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn read: function has invalid number of arguments (expected 1)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
										var arg0Val env.Object
										{
											items := make([]env.Object, len(arg0))
											for i, it := range arg0 {
												items[i] = *env.NewNative(ps.Idx, it, "byte")
											}
											arg0Val = *env.NewBlock(*env.NewTSeries(items))
										}
										actualFn := fn
										_ = actualFn
										evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
										var res0 int
										var res1 error
										res, ok := ps.Res.(env.Block)
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										if len(res.Series.S) != 2 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										if v, ok := res.Series.S[0].(env.Integer); ok {
											res0 = int(v.Value)
										} else {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										switch v := res.Series.S[1].(type) {
										case env.String:
											res1 = errors.New(v.Value)
										case env.Error:
											res1 = errors.New(v.Print(*ps.Idx))
										case env.Integer:
											if v.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											res1 = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											return res0, res1
										}
									case env.Integer:
										if fn.Value != 0 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn read: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										impl.fn_Read = nil
									default:
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn read: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									ctxObj2, ok := wordToObj["close"]
									if !ok {
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: expected context to have function close",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									switch fn := ctxObj2.(type) {
									case env.Function:
										if fn.Argsn != 0 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn close: function has invalid number of arguments (expected 0)",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										impl.fn_Close = func(ctx env.RyeCtx) (error) {
											actualFn := fn
											_ = actualFn
											evaldo.CallFunctionArgsN(fn, ps, &ctx)
											var res error
											switch v := ps.Res.(type) {
											case env.String:
												res = errors.New(v.Value)
											case env.Error:
												res = errors.New(v.Print(*ps.Idx))
											case env.Integer:
												if v.Value != 0 {
													fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												res = nil
											default:
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
												}
												return res
											}
										case env.Integer:
											if fn.Value != 0 {
												fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn close: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
											}
											impl.fn_Close = nil
										default:
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: context to fs.File: context fn close: expected function or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										res0 = impl
									case env.Native:
										var ok bool
										res0, ok = v.Value.(fs.File)
										if !ok {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native of type fs.File",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
									case env.Integer:
										if v.Value != 0 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										res0 = nil
									default:
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected native",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
									}
									switch v := res.Series.S[1].(type) {
									case env.String:
										res1 = errors.New(v.Value)
									case env.Error:
										res1 = errors.New(v.Print(*ps.Idx))
									case env.Integer:
										if v.Value != 0 {
											fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										res1 = nil
									default:
										fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-file-system: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
										}
										return res0, res1
									}
								case env.Integer:
									if fn.Value != 0 {
										ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: context to fs.FS: context fn open: expected integer to be 0 or nil")
									}
									impl.fn_Open = nil
								default:
									ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: context to fs.FS: context fn open: expected function or nil")
								}
								arg0Val = impl
							case env.Native:
								var ok bool
								arg0Val, ok = v.Value.(fs.FS)
								if !ok {
									ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: expected native of type fs.FS")
								}
							case env.Integer:
								if v.Value != 0 {
									ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: expected integer to be 0 or nil")
								}
								arg0Val = nil
							default:
								ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 1: expected native")
							}
							var arg1Val string
							if v, ok := arg1.(env.String); ok {
								arg1Val = string(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-file-system: arg 2: expected string")
							}
							res0, res1, res2 := ebitenutil.NewImageFromFileSystem(arg0Val, arg1Val)
							var res0Obj env.Object
							res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
							var res1Obj env.Object
							res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
							var res2Obj env.Object
							res2Obj = *env.NewError(res2.Error())
							return env.NewDict(map[string]any{
								"1": res0Obj,
								"2": res1Obj,
								"err": res2Obj,
							})
		},
	},
	"ebitenutil-image-from-reader": {
		Doc: "ebitenutil.NewImageFromReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-reader: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-reader: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-reader: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-reader: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ebitenutil-image-from-reader: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: context to io.Reader: context fn read: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-reader: arg 1: expected native")
				}
				res0, res1, res2 := ebitenutil.NewImageFromReader(arg0Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
				var res1Obj env.Object
				res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
				var res2Obj env.Object
				res2Obj = *env.NewError(res2.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"2": res1Obj,
					"err": res2Obj,
				})
		},
	},
	"ebitenutil-image-from-url": {
		Doc: "ebitenutil.NewImageFromURL",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-image-from-url: arg 1: expected string")
			}
			res0, res1 := ebitenutil.NewImageFromURL(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ebitenutil-open-file": {
		Doc: "ebitenutil.OpenFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ebitenutil-open-file: arg 1: expected string")
			}
			res0, res1 := ebitenutil.OpenFile(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath() + "." + typPfx + typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "ebitenutil-read-seek-closer")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"flappy-gopher-png": {
		Doc: "Get flappy.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Gopher_png))
				for i, it := range flappy.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"flappy-tiles-png": {
		Doc: "Get flappy.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Tiles_png))
				for i, it := range flappy.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-m-plus-1-p-regular-ttf": {
		Doc: "Get fonts.MPlus1pRegular_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.MPlus1pRegular_ttf))
				for i, it := range fonts.MPlus1pRegular_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-press-start-2-p-ttf": {
		Doc: "Get fonts.PressStart2P_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.PressStart2P_ttf))
				for i, it := range fonts.PressStart2P_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ebiten-png": {
		Doc: "Get images.Ebiten_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Ebiten_png))
				for i, it := range images.Ebiten_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-five-years-jpg": {
		Doc: "Get images.FiveYears_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.FiveYears_jpg))
				for i, it := range images.FiveYears_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-gophers-jpg": {
		Doc: "Get images.Gophers_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Gophers_jpg))
				for i, it := range images.Gophers_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-runner-png": {
		Doc: "Get images.Runner_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Runner_png))
				for i, it := range images.Runner_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-smoke-png": {
		Doc: "Get images.Smoke_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Smoke_png))
				for i, it := range images.Smoke_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-spritesheet-png": {
		Doc: "Get images.Spritesheet_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Spritesheet_png))
				for i, it := range images.Spritesheet_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tile-png": {
		Doc: "Get images.Tile_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tile_png))
				for i, it := range images.Tile_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tiles-png": {
		Doc: "Get images.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tiles_png))
				for i, it := range images.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ui-png": {
		Doc: "Get images.UI_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.UI_png))
				for i, it := range images.UI_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"inpututil-append-just-connected-gamepad-i-ds": {
		Doc: "inpututil.AppendJustConnectedGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.GamepadID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.GamepadID)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected native of type []ebiten.GamepadID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustConnectedGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-gamepad-buttons": {
		Doc: "inpututil.AppendJustPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-keys": {
		Doc: "inpututil.AppendJustPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-standard-gamepad-buttons": {
		Doc: "inpututil.AppendJustPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-touch-i-ds": {
		Doc: "inpututil.AppendJustPressedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-gamepad-buttons": {
		Doc: "inpututil.AppendJustReleasedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-keys": {
		Doc: "inpututil.AppendJustReleasedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-standard-gamepad-buttons": {
		Doc: "inpututil.AppendJustReleasedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-touch-i-ds": {
		Doc: "inpututil.AppendJustReleasedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-gamepad-buttons": {
		Doc: "inpututil.AppendPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-keys": {
		Doc: "inpututil.AppendPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-standard-gamepad-buttons": {
		Doc: "inpututil.AppendPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-gamepad-button-press-duration": {
		Doc: "inpututil.GamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-gamepad-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-gamepad-button-press-duration: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.GamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-pressed": {
		Doc: "inpututil.IsGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.IsGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-released": {
		Doc: "inpututil.IsGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-gamepad-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-gamepad-button-just-released: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.IsGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-just-disconnected": {
		Doc: "inpututil.IsGamepadJustDisconnected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-gamepad-just-disconnected: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := inpututil.IsGamepadJustDisconnected(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-pressed": {
		Doc: "inpututil.IsKeyJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-key-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-released": {
		Doc: "inpututil.IsKeyJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-key-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-pressed": {
		Doc: "inpututil.IsMouseButtonJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-mouse-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.IsMouseButtonJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-released": {
		Doc: "inpututil.IsMouseButtonJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-mouse-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.IsMouseButtonJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-pressed": {
		Doc: "inpututil.IsStandardGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.IsStandardGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-released": {
		Doc: "inpututil.IsStandardGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.IsStandardGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-touch-just-released": {
		Doc: "inpututil.IsTouchJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-is-touch-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0 := inpututil.IsTouchJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-just-connected-gamepad-i-ds": {
		Doc: "inpututil.JustConnectedGamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.JustConnectedGamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-just-pressed-touch-i-ds": {
		Doc: "inpututil.JustPressedTouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.JustPressedTouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-key-press-duration": {
		Doc: "inpututil.KeyPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-key-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.KeyPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-mouse-button-press-duration": {
		Doc: "inpututil.MouseButtonPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-mouse-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.MouseButtonPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-pressed-keys": {
		Doc: "inpututil.PressedKeys",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := inpututil.PressedKeys()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-standard-gamepad-button-press-duration": {
		Doc: "inpututil.StandardGamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.StandardGamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-touch-position-in-previous-tick": {
		Doc: "inpututil.TouchPositionInPreviousTick",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-touch-position-in-previous-tick: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0, res1 := inpututil.TouchPositionInPreviousTick(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"inpututil-touch-press-duration": {
		Doc: "inpututil.TouchPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("inpututil-touch-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0 := inpututil.TouchPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"io-closer//close": {
		Doc: "io.Closer.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Closer
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Closer{
					self: v,
				}
				ctxObj0, ok := wordToObj["close"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: context to io.Closer: expected context to have function close")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: context to io.Closer: context fn close: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Close = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-closer//close: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-closer//close: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: context to io.Closer: context fn close: expected integer to be 0 or nil")
						}
						impl.fn_Close = nil
					default:
						ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: context to io.Closer: context fn close: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Closer)
					if !ok {
						ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: expected native of type io.Closer")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("io-closer//close: arg 1: expected native")
				}
				res0 := arg0Val.Close()
				var res0Obj env.Object
				res0Obj = *env.NewError(res0.Error())
				return res0Obj
		},
	},
	"io-reader//read": {
		Doc: "io.Reader.Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-reader//read: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-reader//read: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-reader//read: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-reader//read: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-reader//read: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: context to io.Reader: context fn read: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("io-reader//read: arg 1: expected native")
				}
				var arg1Val []byte
				switch v := arg1.(type) {
				case env.Block:
					arg1Val = make([]byte, len(v.Series.S))
					for i, it := range v.Series.S {
						switch v := it.(type) {
						case env.Native:
							var ok bool
							arg1Val[i], ok = v.Value.(byte)
							if !ok {
								ps.FailureFlag = true
return env.NewError("io-reader//read: arg 2: block item: expected native of type byte")
							}
						default:
							ps.FailureFlag = true
return env.NewError("io-reader//read: arg 2: block item: expected native")
						}
					}
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.([]byte)
					if !ok {
						ps.FailureFlag = true
return env.NewError("io-reader//read: arg 2: expected native of type []byte")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("io-reader//read: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("io-reader//read: arg 2: expected block, native or nil")
				}
				res0, res1 := arg0Val.Read(arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewInteger(int64(res0))
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"n": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"io-seeker//seek": {
		Doc: "io.Seeker.Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Seeker
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Seeker{
					self: v,
				}
				ctxObj0, ok := wordToObj["seek"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: context to io.Seeker: expected context to have function seek")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 2 {
						ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: context to io.Seeker: context fn seek: function has invalid number of arguments (expected 2)")
					}
					impl.fn_Seek = func(ctx env.RyeCtx, arg0 int64, arg1 int) (int64, error) {
						var arg0Val, arg1Val env.Object
						arg0Val = *env.NewInteger(int64(arg0))
						arg1Val = *env.NewInteger(int64(arg1))
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
						var res0 int64
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-seeker//seek: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-seeker//seek: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int64(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-seeker//seek: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-seeker//seek: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"io-seeker//seek: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: context to io.Seeker: context fn seek: expected integer to be 0 or nil")
						}
						impl.fn_Seek = nil
					default:
						ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: context to io.Seeker: context fn seek: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Seeker)
					if !ok {
						ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: expected native of type io.Seeker")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 1: expected native")
				}
				var arg1Val int64
				if v, ok := arg1.(env.Integer); ok {
					arg1Val = int64(v.Value)
				} else {
					ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 2: expected integer")
				}
				var arg2Val int
				if v, ok := arg2.(env.Integer); ok {
					arg2Val = int(v.Value)
				} else {
					ps.FailureFlag = true
return env.NewError("io-seeker//seek: arg 3: expected integer")
				}
				res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
				var res0Obj env.Object
				res0Obj = *env.NewInteger(int64(res0))
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"keyboard-1-keyboard-png": {
		Doc: "Get keyboard_1.Keyboard_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(keyboard_1.Keyboard_png))
				for i, it := range keyboard_1.Keyboard_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"keyboard-key-rect": {
		Doc: "keyboard.KeyRect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("keyboard-key-rect: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, res1 := keyboard.KeyRect(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-rectangle")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"mascot-out-01-png": {
		Doc: "Get mascot.Out01_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out01_png))
				for i, it := range mascot.Out01_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-02-png": {
		Doc: "Get mascot.Out02_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out02_png))
				for i, it := range mascot.Out02_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-03-png": {
		Doc: "Get mascot.Out03_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out03_png))
				for i, it := range mascot.Out03_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mobile-set-game": {
		Doc: "mobile.SetGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("mobile-set-game: arg 1: expected native")
				}
				mobile.SetGame(arg0Val)
				return nil
		},
	},
	"mobile-set-game-with-options": {
		Doc: "mobile.SetGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_ebiten_Game{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 0 {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn update: function has invalid number of arguments (expected 0)")
					}
					impl.fn_Update = func(ctx env.RyeCtx) (error) {
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game-with-options: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game-with-options: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn draw: expected function or nil")
					}
					ctxObj2, ok := wordToObj["layout"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: expected context to have function layout")
					}
					switch fn := ctxObj2.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn layout: function has invalid number of arguments (expected 2)")
						}
						impl.fn_Layout = func(ctx env.RyeCtx, arg0 int, arg1 int) (int, int) {
							var arg0Val, arg1Val env.Object
							arg0Val = *env.NewInteger(int64(arg0))
							arg1Val = *env.NewInteger(int64(arg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val, arg1Val)
							var res0 int
							var res1 int
							res, ok := ps.Res.(env.Block)
							if !ok {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game-with-options: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if len(res.Series.S) != 2 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game-with-options: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[0].(env.Integer); ok {
								res0 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game-with-options: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							if v, ok := res.Series.S[1].(env.Integer); ok {
								res1 = int(v.Value)
							} else {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mobile-set-game-with-options: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn layout: expected integer to be 0 or nil")
						}
						impl.fn_Layout = nil
					default:
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: context to ebiten.Game: context fn layout: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(ebiten.Game)
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: expected native of type ebiten.Game")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 1: expected native")
				}
				var arg1Val *ebiten.RunGameOptions
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
					if !ok {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 2: expected native of type *ebiten.RunGameOptions")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("mobile-set-game-with-options: arg 2: expected native")
				}
				mobile.SetGameWithOptions(arg0Val, arg1Val)
				return nil
		},
	},
	"mp-3-decode": {
		Doc: "mp3.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode: arg 2: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode: arg 2: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode: arg 2: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: context to io.Reader: context fn read: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("mp-3-decode: arg 2: expected native")
				}
				res0, res1 := mp3.Decode(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"mp-3-decode-with-sample-rate": {
		Doc: "mp3.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-with-sample-rate: arg 2: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-with-sample-rate: arg 2: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-with-sample-rate: arg 2: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-with-sample-rate: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-with-sample-rate: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected native")
				}
				res0, res1 := mp3.DecodeWithSampleRate(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"mp-3-decode-without-resampling": {
		Doc: "mp3.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-without-resampling: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-without-resampling: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-without-resampling: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-without-resampling: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"mp-3-decode-without-resampling: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: context to io.Reader: context fn read: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("mp-3-decode-without-resampling: arg 1: expected native")
				}
				res0, res1 := mp3.DecodeWithoutResampling(arg0Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"platformer-background-png": {
		Doc: "Get platformer.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Background_png))
				for i, it := range platformer.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-left-png": {
		Doc: "Get platformer.Left_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Left_png))
				for i, it := range platformer.Left_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-main-char-png": {
		Doc: "Get platformer.MainChar_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.MainChar_png))
				for i, it := range platformer.MainChar_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-right-png": {
		Doc: "Get platformer.Right_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Right_png))
				for i, it := range platformer.Right_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-audio-infinite-loop//read": {
		Doc: "(*audio.InfiniteLoop).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.InfiniteLoop)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected native of type *audio.InfiniteLoop")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-audio-infinite-loop//seek": {
		Doc: "(*audio.InfiniteLoop).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.InfiniteLoop)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected native of type *audio.InfiniteLoop")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-audio-infinite-loop//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-blocks-game-scene//draw": {
		Doc: "(*blocks.GameScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GameScene)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected native of type *blocks.GameScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-game-scene//update": {
		Doc: "(*blocks.GameScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GameScene)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//update: arg 1: expected native of type *blocks.GameScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-game-state//input!": {
		Doc: "Set *blocks.GameState Input value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input!: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Input, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input!: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input!: arg 2: expected integer to be 0 or nil")
				}
				self.Input = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//input?": {
		Doc: "Get *blocks.GameState Input value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input?: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//input?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Input, "ptr-blocks-input")
			return resObj
		},
	},
	"ptr-blocks-game-state//scene-manager!": {
		Doc: "Set *blocks.GameState SceneManager value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SceneManager, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected integer to be 0 or nil")
				}
				self.SceneManager = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//scene-manager?": {
		Doc: "Get *blocks.GameState SceneManager value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SceneManager, "ptr-blocks-scene-manager")
			return resObj
		},
	},
	"ptr-blocks-game//draw": {
		Doc: "(*blocks.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//draw: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-game//layout": {
		Doc: "(*blocks.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//layout: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"screen-width": res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"ptr-blocks-game//update": {
		Doc: "(*blocks.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//update: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-game//update: arg 1: expected native")
			}
			res0 := arg0Val.Update()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-gamepad-scene//draw": {
		Doc: "(*blocks.GamepadScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GamepadScene)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected native of type *blocks.GamepadScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-gamepad-scene//update": {
		Doc: "(*blocks.GamepadScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GamepadScene)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected native of type *blocks.GamepadScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-input//gamepad-id-button-pressed": {
		Doc: "(*blocks.Input).GamepadIDButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected native")
			}
			res0 := arg0Val.GamepadIDButtonPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-input//is-rotate-left-just-pressed": {
		Doc: "(*blocks.Input).IsRotateLeftJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected native")
			}
			res0 := arg0Val.IsRotateLeftJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//is-rotate-right-just-pressed": {
		Doc: "(*blocks.Input).IsRotateRightJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected native")
			}
			res0 := arg0Val.IsRotateRightJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-down": {
		Doc: "(*blocks.Input).StateForDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected native")
			}
			res0 := arg0Val.StateForDown()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-left": {
		Doc: "(*blocks.Input).StateForLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected native")
			}
			res0 := arg0Val.StateForLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-right": {
		Doc: "(*blocks.Input).StateForRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected native")
			}
			res0 := arg0Val.StateForRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//update": {
		Doc: "(*blocks.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//update: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-input//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-input//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-blocks-piece//absorb-into": {
		Doc: "(*blocks.Piece).AbsorbInto",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected native")
			}
			var arg1Val *blocks.Field
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//absorb-into: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbInto(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-piece//draw": {
		Doc: "(*blocks.Piece).Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//draw: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-piece//initial-position": {
		Doc: "(*blocks.Piece).InitialPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected native")
			}
			res0, res1 := arg0Val.InitialPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-blocks-scene-manager//draw": {
		Doc: "(*blocks.SceneManager).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-scene-manager//go-to": {
		Doc: "(*blocks.SceneManager).GoTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected native")
			}
			var arg1Val blocks.Scene
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_blocks_Scene{
					self: v,
				}
				ctxObj0, ok := wordToObj["update"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: expected context to have function update")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: context fn update: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Update = func(ctx env.RyeCtx, arg0 *blocks.GameState) (error) {
						var arg0Val env.Object
						arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-blocks-game-state")
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res error
						switch v := ps.Res.(type) {
						case env.String:
							res = errors.New(v.Value)
						case env.Error:
							res = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ptr-blocks-scene-manager//go-to: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							res = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"ptr-blocks-scene-manager//go-to: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: context fn update: expected integer to be 0 or nil")
						}
						impl.fn_Update = nil
					default:
						ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: context fn update: expected function or nil")
					}
					ctxObj1, ok := wordToObj["draw"]
					if !ok {
						ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: expected context to have function draw")
					}
					switch fn := ctxObj1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: context fn draw: function has invalid number of arguments (expected 1)")
						}
						impl.fn_Draw = func(ctx env.RyeCtx, arg0 *ebiten.Image) {
							var arg0Val env.Object
							arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-ebiten-image")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: context fn draw: expected integer to be 0 or nil")
						}
						impl.fn_Draw = nil
					default:
						ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: context to blocks.Scene: context fn draw: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(blocks.Scene)
					if !ok {
						ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected native of type blocks.Scene")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected native")
				}
				arg0Val.GoTo(arg1Val)
				return arg0
		},
	},
	"ptr-blocks-scene-manager//update": {
		Doc: "(*blocks.SceneManager).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected native")
			}
			var arg1Val *blocks.Input
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-title-scene//draw": {
		Doc: "(*blocks.TitleScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.TitleScene)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected native of type *blocks.TitleScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-title-scene//update": {
		Doc: "(*blocks.TitleScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.TitleScene)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//update: arg 1: expected native of type *blocks.TitleScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-blocks-title-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-colorm-draw-image-options//blend!": {
		Doc: "Set *colorm.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//blend?": {
		Doc: "Get *colorm.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-colorm-draw-image-options//filter!": {
		Doc: "Set *colorm.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//filter?": {
		Doc: "Get *colorm.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-colorm-draw-image-options//geo-m!": {
		Doc: "Set *colorm.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//geo-m?": {
		Doc: "Get *colorm.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//address!": {
		Doc: "Set *colorm.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//address?": {
		Doc: "Get *colorm.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//anti-alias!": {
		Doc: "Set *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//anti-alias?": {
		Doc: "Get *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//blend!": {
		Doc: "Set *colorm.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//blend?": {
		Doc: "Get *colorm.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//color-scale-mode!": {
		Doc: "Set *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//color-scale-mode?": {
		Doc: "Get *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//fill-rule!": {
		Doc: "Set *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//fill-rule?": {
		Doc: "Get *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//filter!": {
		Doc: "Set *colorm.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//filter?": {
		Doc: "Get *colorm.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-alpha!": {
		Doc: "Set *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native")
					}
					self.BlendFactorDestinationAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-alpha?": {
		Doc: "Get *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-rgb!": {
		Doc: "Set *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native")
					}
					self.BlendFactorDestinationRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-rgb?": {
		Doc: "Get *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-source-alpha!": {
		Doc: "Set *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 2: expected native")
					}
					self.BlendFactorSourceAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-source-alpha?": {
		Doc: "Get *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-source-rgb!": {
		Doc: "Set *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 2: expected native")
					}
					self.BlendFactorSourceRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-source-rgb?": {
		Doc: "Get *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-operation-alpha!": {
		Doc: "Set *ebiten.Blend BlendOperationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 2: expected native")
					}
					self.BlendOperationAlpha = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-operation-alpha?": {
		Doc: "Get *ebiten.Blend BlendOperationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-operation-rgb!": {
		Doc: "Set *ebiten.Blend BlendOperationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 2: expected native")
					}
					self.BlendOperationRGB = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-operation-rgb?": {
		Doc: "Get *ebiten.Blend BlendOperationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-color-scale//a": {
		Doc: "(*ebiten.ColorScale).A",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected native")
			}
			res0 := arg0Val.A()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//b": {
		Doc: "(*ebiten.ColorScale).B",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected native")
			}
			res0 := arg0Val.B()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//g": {
		Doc: "(*ebiten.ColorScale).G",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected native")
			}
			res0 := arg0Val.G()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//r": {
		Doc: "(*ebiten.ColorScale).R",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected native")
			}
			res0 := arg0Val.R()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//reset": {
		Doc: "(*ebiten.ColorScale).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale": {
		Doc: "(*ebiten.ColorScale).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-alpha": {
		Doc: "(*ebiten.ColorScale).ScaleAlpha",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 2: expected decimal")
			}
			arg0Val.ScaleAlpha(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-with-color": {
		Doc: "(*ebiten.ColorScale).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-with-color-scale": {
		Doc: "(*ebiten.ColorScale).ScaleWithColorScale",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected native")
			}
			var arg1Val ebiten.ColorScale
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected native")
			}
			arg0Val.ScaleWithColorScale(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-a": {
		Doc: "(*ebiten.ColorScale).SetA",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-a: arg 2: expected decimal")
			}
			arg0Val.SetA(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-b": {
		Doc: "(*ebiten.ColorScale).SetB",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-b: arg 2: expected decimal")
			}
			arg0Val.SetB(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-g": {
		Doc: "(*ebiten.ColorScale).SetG",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-g: arg 2: expected decimal")
			}
			arg0Val.SetG(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-r": {
		Doc: "(*ebiten.ColorScale).SetR",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//set-r: arg 2: expected decimal")
			}
			arg0Val.SetR(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//string": {
		Doc: "(*ebiten.ColorScale).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-draw-image-options//blend!": {
		Doc: "Set *ebiten.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//blend?": {
		Doc: "Get *ebiten.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//color-m!": {
		Doc: "Set *ebiten.DrawImageOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//color-m?": {
		Doc: "Get *ebiten.DrawImageOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//color-scale!": {
		Doc: "Set *ebiten.DrawImageOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//color-scale?": {
		Doc: "Get *ebiten.DrawImageOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//composite-mode!": {
		Doc: "Set *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//composite-mode?": {
		Doc: "Get *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//filter!": {
		Doc: "Set *ebiten.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//filter?": {
		Doc: "Get *ebiten.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//geo-m!": {
		Doc: "Set *ebiten.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//geo-m?": {
		Doc: "Get *ebiten.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//address!": {
		Doc: "Set *ebiten.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//address?": {
		Doc: "Get *ebiten.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//anti-alias!": {
		Doc: "Set *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//anti-alias?": {
		Doc: "Get *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//blend!": {
		Doc: "Set *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//blend?": {
		Doc: "Get *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//color-m!": {
		Doc: "Set *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//color-m?": {
		Doc: "Get *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//color-scale-mode!": {
		Doc: "Set *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//color-scale-mode?": {
		Doc: "Get *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//composite-mode!": {
		Doc: "Set *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//composite-mode?": {
		Doc: "Get *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//fill-rule!": {
		Doc: "Set *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//fill-rule?": {
		Doc: "Get *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//filter!": {
		Doc: "Set *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//filter?": {
		Doc: "Get *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-geo-m//apply": {
		Doc: "(*ebiten.GeoM).Apply",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//apply: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//apply: arg 3: expected decimal")
			}
			res0, res1 := arg0Val.Apply(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-ebiten-geo-m//concat": {
		Doc: "(*ebiten.GeoM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected native")
			}
			var arg1Val ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//element": {
		Doc: "(*ebiten.GeoM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//invert": {
		Doc: "(*ebiten.GeoM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-ebiten-geo-m//is-invertible": {
		Doc: "(*ebiten.GeoM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//reset": {
		Doc: "(*ebiten.GeoM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-geo-m//rotate": {
		Doc: "(*ebiten.GeoM).Rotate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//rotate: arg 2: expected decimal")
			}
			arg0Val.Rotate(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//scale": {
		Doc: "(*ebiten.GeoM).Scale",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//scale: arg 3: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//set-element": {
		Doc: "(*ebiten.GeoM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//skew": {
		Doc: "(*ebiten.GeoM).Skew",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//skew: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//skew: arg 3: expected decimal")
			}
			arg0Val.Skew(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//string": {
		Doc: "(*ebiten.GeoM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//translate": {
		Doc: "(*ebiten.GeoM).Translate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-geo-m//translate: arg 3: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-image//clear": {
		Doc: "(*ebiten.Image).Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//clear: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//clear: arg 1: expected native")
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"ptr-ebiten-image//draw-image": {
		Doc: "(*ebiten.Image).DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected native")
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected native")
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-image//draw-triangles": {
		Doc: "(*ebiten.Image).DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected native")
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-image//fill": {
		Doc: "(*ebiten.Image).Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//fill: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//fill: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//fill: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//fill: arg 2: expected native")
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-image//size": {
		Doc: "(*ebiten.Image).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//size: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-image//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"width": res0Obj,
				"height": res1Obj,
			})
		},
	},
	"ptr-ebiten-key//unmarshal-text": {
		Doc: "(*ebiten.Key).UnmarshalText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Key
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Key)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected native of type *ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.UnmarshalText(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//device-scale-factor": {
		Doc: "(*ebiten.MonitorType).DeviceScaleFactor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected native")
			}
			res0 := arg0Val.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//name": {
		Doc: "(*ebiten.MonitorType).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//size": {
		Doc: "(*ebiten.MonitorType).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-ebiten-run-game-options//graphics-library!": {
		Doc: "Set *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//graphics-library?": {
		Doc: "Get *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//init-unfocused!": {
		Doc: "Set *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.InitUnfocused = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//init-unfocused?": {
		Doc: "Get *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.InitUnfocused))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//screen-transparent!": {
		Doc: "Set *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScreenTransparent = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//screen-transparent?": {
		Doc: "Get *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScreenTransparent))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//single-thread!": {
		Doc: "Set *ebiten.RunGameOptions SingleThread value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SingleThread = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//single-thread?": {
		Doc: "Get *ebiten.RunGameOptions SingleThread value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleThread))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//skip-taskbar!": {
		Doc: "Set *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SkipTaskbar = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//skip-taskbar?": {
		Doc: "Get *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SkipTaskbar))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//x-11-class-name!": {
		Doc: "Set *ebiten.RunGameOptions X11ClassName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11ClassName = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//x-11-class-name?": {
		Doc: "Get *ebiten.RunGameOptions X11ClassName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11ClassName)
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//x-11-instance-name!": {
		Doc: "Set *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11InstanceName = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//x-11-instance-name?": {
		Doc: "Get *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11InstanceName)
			return resObj
		},
	},
	"ptr-ebiten-shader//deallocate": {
		Doc: "(*ebiten.Shader).Deallocate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected native")
			}
			arg0Val.Deallocate()
			return arg0
		},
	},
	"ptr-ebiten-shader//dispose": {
		Doc: "(*ebiten.Shader).Dispose",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected native")
			}
			arg0Val.Dispose()
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-a!": {
		Doc: "Set *ebiten.Vertex ColorA value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorA = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-a?": {
		Doc: "Get *ebiten.Vertex ColorA value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorA))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-b!": {
		Doc: "Set *ebiten.Vertex ColorB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorB = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-b?": {
		Doc: "Get *ebiten.Vertex ColorB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorB))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-g!": {
		Doc: "Set *ebiten.Vertex ColorG value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorG = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-g?": {
		Doc: "Get *ebiten.Vertex ColorG value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorG))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-r!": {
		Doc: "Set *ebiten.Vertex ColorR value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorR = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-r?": {
		Doc: "Get *ebiten.Vertex ColorR value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorR))
			return resObj
		},
	},
	"ptr-ebiten-vertex//dst-x!": {
		Doc: "Set *ebiten.Vertex DstX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstX = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//dst-x?": {
		Doc: "Get *ebiten.Vertex DstX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstX))
			return resObj
		},
	},
	"ptr-ebiten-vertex//dst-y!": {
		Doc: "Set *ebiten.Vertex DstY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstY = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//dst-y?": {
		Doc: "Get *ebiten.Vertex DstY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstY))
			return resObj
		},
	},
	"ptr-ebiten-vertex//src-x!": {
		Doc: "Set *ebiten.Vertex SrcX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcX = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//src-x?": {
		Doc: "Get *ebiten.Vertex SrcX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcX))
			return resObj
		},
	},
	"ptr-ebiten-vertex//src-y!": {
		Doc: "Set *ebiten.Vertex SrcY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcY = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//src-y?": {
		Doc: "Get *ebiten.Vertex SrcY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcY))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//duration!": {
		Doc: "Set *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//duration?": {
		Doc: "Get *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//strong-magnitude!": {
		Doc: "Set *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrongMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//strong-magnitude?": {
		Doc: "Get *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrongMagnitude))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//weak-magnitude!": {
		Doc: "Set *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.WeakMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//weak-magnitude?": {
		Doc: "Get *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeakMagnitude))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-options//duration!": {
		Doc: "Set *ebiten.VibrateOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-options//duration?": {
		Doc: "Get *ebiten.VibrateOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-ebiten-vibrate-options//magnitude!": {
		Doc: "Set *ebiten.VibrateOptions Magnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Magnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-options//magnitude?": {
		Doc: "Get *ebiten.VibrateOptions Magnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Magnitude))
			return resObj
		},
	},
	"ptr-mp-3-stream//length": {
		Doc: "(*mp3.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//length: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-mp-3-stream//read": {
		Doc: "(*mp3.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-mp-3-stream//seek": {
		Doc: "(*mp3.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//seek: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-mp-3-stream//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-text-1-draw-options//blend!": {
		Doc: "Set *text_1.DrawOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//blend?": {
		Doc: "Get *text_1.DrawOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-text-1-draw-options//color-m!": {
		Doc: "Set *text_1.DrawOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//color-m?": {
		Doc: "Get *text_1.DrawOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-text-1-draw-options//color-scale!": {
		Doc: "Set *text_1.DrawOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//color-scale?": {
		Doc: "Get *text_1.DrawOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"ptr-text-1-draw-options//composite-mode!": {
		Doc: "Set *text_1.DrawOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//composite-mode?": {
		Doc: "Get *text_1.DrawOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-text-1-draw-options//filter!": {
		Doc: "Set *text_1.DrawOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//filter?": {
		Doc: "Get *text_1.DrawOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-text-1-draw-options//geo-m!": {
		Doc: "Set *text_1.DrawOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//geo-m?": {
		Doc: "Get *text_1.DrawOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ptr-text-1-draw-options//line-spacing!": {
		Doc: "Set *text_1.DrawOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//line-spacing?": {
		Doc: "Get *text_1.DrawOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"ptr-text-1-draw-options//primary-align!": {
		Doc: "Set *text_1.DrawOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//primary-align?": {
		Doc: "Get *text_1.DrawOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-draw-options//secondary-align!": {
		Doc: "Set *text_1.DrawOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//secondary-align?": {
		Doc: "Get *text_1.DrawOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-draw-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-glyph//end-index-in-bytes!": {
		Doc: "Set *text_1.Glyph EndIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.EndIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//end-index-in-bytes?": {
		Doc: "Get *text_1.Glyph EndIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//end-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.EndIndexInBytes))
			return resObj
		},
	},
	"ptr-text-1-glyph//gid!": {
		Doc: "Set *text_1.Glyph GID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.GID = uint32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//gid?": {
		Doc: "Get *text_1.Glyph GID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//gid?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.GID))
			return resObj
		},
	},
	"ptr-text-1-glyph//image!": {
		Doc: "Set *text_1.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//image?": {
		Doc: "Get *text_1.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"ptr-text-1-glyph//start-index-in-bytes!": {
		Doc: "Set *text_1.Glyph StartIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StartIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//start-index-in-bytes?": {
		Doc: "Get *text_1.Glyph StartIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//start-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StartIndexInBytes))
			return resObj
		},
	},
	"ptr-text-1-glyph//x!": {
		Doc: "Set *text_1.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//x?": {
		Doc: "Get *text_1.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-text-1-glyph//y!": {
		Doc: "Set *text_1.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//y?": {
		Doc: "Get *text_1.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-text-1-go-text-face//direction!": {
		Doc: "Set *text_1.GoTextFace Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Direction
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Direction)
				}
				if natOk && natValOk {
					self.Direction = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction!: arg 2: expected integer")
					}
					self.Direction = text_1.Direction(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//direction?": {
		Doc: "Get *text_1.GoTextFace Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//direction?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Direction)))
			return resObj
		},
	},
	"ptr-text-1-go-text-face//language!": {
		Doc: "Set *text_1.GoTextFace Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Language, ok = v.Value.(language.Tag)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language!: arg 2: expected native of type language.Tag")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//language?": {
		Doc: "Get *text_1.GoTextFace Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//language?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Language, "language-tag")
			return resObj
		},
	},
	"ptr-text-1-go-text-face//metrics": {
		Doc: "(*text_1.GoTextFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//metrics: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"ptr-text-1-go-text-face//remove-feature": {
		Doc: "(*text_1.GoTextFace).RemoveFeature",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			arg0Val.RemoveFeature(arg1Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//remove-variation": {
		Doc: "(*text_1.GoTextFace).RemoveVariation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			arg0Val.RemoveVariation(arg1Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//script!": {
		Doc: "Set *text_1.GoTextFace Script value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Script, ok = v.Value.(language.Script)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script!: arg 2: expected native of type language.Script")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//script?": {
		Doc: "Get *text_1.GoTextFace Script value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//script?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Script, "language-script")
			return resObj
		},
	},
	"ptr-text-1-go-text-face//set-feature": {
		Doc: "(*text_1.GoTextFace).SetFeature",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-feature: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-feature: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-feature: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-feature: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			var arg2Val uint32
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-feature: arg 3: expected integer")
			}
			arg0Val.SetFeature(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//set-variation": {
		Doc: "(*text_1.GoTextFace).SetVariation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-variation: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-variation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-variation: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-variation: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//set-variation: arg 3: expected decimal")
			}
			arg0Val.SetVariation(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//size!": {
		Doc: "Set *text_1.GoTextFace Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Size = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//size?": {
		Doc: "Get *text_1.GoTextFace Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Size))
			return resObj
		},
	},
	"ptr-text-1-go-text-face//source!": {
		Doc: "Set *text_1.GoTextFace Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(*text_1.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source!: arg 2: expected native of type *text_1.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source!: arg 2: expected integer to be 0 or nil")
				}
				self.Source = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//source?": {
		Doc: "Get *text_1.GoTextFace Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-go-text-face//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "ptr-text-1-go-text-face-source")
			return resObj
		},
	},
	"ptr-text-1-layout-options//line-spacing!": {
		Doc: "Set *text_1.LayoutOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-layout-options//line-spacing?": {
		Doc: "Get *text_1.LayoutOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing?: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"ptr-text-1-layout-options//primary-align!": {
		Doc: "Set *text_1.LayoutOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align!: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-layout-options//primary-align?": {
		Doc: "Get *text_1.LayoutOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align?: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-layout-options//secondary-align!": {
		Doc: "Set *text_1.LayoutOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-layout-options//secondary-align?": {
		Doc: "Get *text_1.LayoutOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align?: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-layout-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-limited-face//add-unicode-range": {
		Doc: "(*text_1.LimitedFace).AddUnicodeRange",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.LimitedFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 1: expected native of type *text_1.LimitedFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 2: expected native")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 3: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 3: expected native")
			}
			arg0Val.AddUnicodeRange(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-1-limited-face//metrics": {
		Doc: "(*text_1.LimitedFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.LimitedFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//metrics: arg 1: expected native of type *text_1.LimitedFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-limited-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"ptr-text-1-metadata//family!": {
		Doc: "Set *text_1.Metadata Family value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Family = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//family?": {
		Doc: "Get *text_1.Metadata Family value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//family?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Family)
			return resObj
		},
	},
	"ptr-text-1-metadata//stretch!": {
		Doc: "Set *text_1.Metadata Stretch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Stretch
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Stretch)
				}
				if natOk && natValOk {
					self.Stretch = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch!: arg 2: expected decimal")
					}
					self.Stretch = text_1.Stretch(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//stretch?": {
		Doc: "Get *text_1.Metadata Stretch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//stretch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Stretch)))
			return resObj
		},
	},
	"ptr-text-1-metadata//style!": {
		Doc: "Set *text_1.Metadata Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Style
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Style)
				}
				if natOk && natValOk {
					self.Style = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style!: arg 2: expected integer")
					}
					self.Style = text_1.Style(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//style?": {
		Doc: "Get *text_1.Metadata Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Style)))
			return resObj
		},
	},
	"ptr-text-1-metadata//weight!": {
		Doc: "Set *text_1.Metadata Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Weight
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Weight)
				}
				if natOk && natValOk {
					self.Weight = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight!: arg 2: expected decimal")
					}
					self.Weight = text_1.Weight(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//weight?": {
		Doc: "Get *text_1.Metadata Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metadata//weight?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Weight)))
			return resObj
		},
	},
	"ptr-text-1-metrics//h-ascent!": {
		Doc: "Set *text_1.Metrics HAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//h-ascent?": {
		Doc: "Get *text_1.Metrics HAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HAscent))
			return resObj
		},
	},
	"ptr-text-1-metrics//h-descent!": {
		Doc: "Set *text_1.Metrics HDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//h-descent?": {
		Doc: "Get *text_1.Metrics HDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HDescent))
			return resObj
		},
	},
	"ptr-text-1-metrics//h-line-gap!": {
		Doc: "Set *text_1.Metrics HLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//h-line-gap?": {
		Doc: "Get *text_1.Metrics HLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//h-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HLineGap))
			return resObj
		},
	},
	"ptr-text-1-metrics//v-ascent!": {
		Doc: "Set *text_1.Metrics VAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//v-ascent?": {
		Doc: "Get *text_1.Metrics VAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VAscent))
			return resObj
		},
	},
	"ptr-text-1-metrics//v-descent!": {
		Doc: "Set *text_1.Metrics VDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//v-descent?": {
		Doc: "Get *text_1.Metrics VDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VDescent))
			return resObj
		},
	},
	"ptr-text-1-metrics//v-line-gap!": {
		Doc: "Set *text_1.Metrics VLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//v-line-gap?": {
		Doc: "Get *text_1.Metrics VLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-metrics//v-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VLineGap))
			return resObj
		},
	},
	"ptr-text-1-multi-face//metrics": {
		Doc: "(*text_1.MultiFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text_1.MultiFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.MultiFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-multi-face//metrics: arg 1: expected native of type *text_1.MultiFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-1-multi-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-1-multi-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"ptr-text-glyph//image!": {
		Doc: "Set *text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-glyph//image?": {
		Doc: "Get *text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"ptr-text-glyph//rune!": {
		Doc: "Set *text.Glyph Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-glyph//rune?": {
		Doc: "Get *text.Glyph Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"ptr-text-glyph//x!": {
		Doc: "Set *text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-glyph//x?": {
		Doc: "Get *text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-text-glyph//y!": {
		Doc: "Set *text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-glyph//y?": {
		Doc: "Get *text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-text-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-textinput-state//committed!": {
		Doc: "Set *textinput.State Committed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Committed = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//committed?": {
		Doc: "Get *textinput.State Committed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//committed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Committed))
			return resObj
		},
	},
	"ptr-textinput-state//composition-selection-end-in-bytes!": {
		Doc: "Set *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionEndInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//composition-selection-end-in-bytes?": {
		Doc: "Get *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionEndInBytes))
			return resObj
		},
	},
	"ptr-textinput-state//composition-selection-start-in-bytes!": {
		Doc: "Set *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionStartInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//composition-selection-start-in-bytes?": {
		Doc: "Get *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionStartInBytes))
			return resObj
		},
	},
	"ptr-textinput-state//error!": {
		Doc: "Set *textinput.State Error value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.String:
				self.Error = errors.New(v.Value)
			case env.Error:
				self.Error = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error!: arg 2: expected integer to be 0 or nil")
				}
				self.Error = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error!: arg 2: expected error, string or nil")
				}
				return arg0
		},
	},
	"ptr-textinput-state//error?": {
		Doc: "Get *textinput.State Error value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//error?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewError(self.Error.Error())
			return resObj
		},
	},
	"ptr-textinput-state//text!": {
		Doc: "Set *textinput.State Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-textinput-state//text?": {
		Doc: "Get *textinput.State Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-textinput-state//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-twenty-48-game//draw": {
		Doc: "(*twenty48.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//draw: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-twenty-48-game//layout": {
		Doc: "(*twenty48.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//layout: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"screen-width": res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"ptr-twenty-48-game//update": {
		Doc: "(*twenty48.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//update: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-game//update: arg 1: expected native")
			}
			res0 := arg0Val.Update()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-twenty-48-input//dir": {
		Doc: "(*twenty48.Input).Dir",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-input//dir: arg 1: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-input//dir: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-input//dir: arg 1: expected native")
			}
			res0, res1 := arg0Val.Dir()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-twenty-48-input//update": {
		Doc: "(*twenty48.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-input//update: arg 1: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-input//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-input//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-twenty-48-tile//is-moving": {
		Doc: "(*twenty48.Tile).IsMoving",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected native")
			}
			res0 := arg0Val.IsMoving()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-twenty-48-tile//next-pos": {
		Doc: "(*twenty48.Tile).NextPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.NextPos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-twenty-48-tile//next-value": {
		Doc: "(*twenty48.Tile).NextValue",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected native")
			}
			res0 := arg0Val.NextValue()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-twenty-48-tile//pos": {
		Doc: "(*twenty48.Tile).Pos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.Pos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-twenty-48-tile//value": {
		Doc: "(*twenty48.Tile).Value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//value: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-twenty-48-tile//value: arg 1: expected native")
			}
			res0 := arg0Val.Value()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-vector-path//append-vertices-and-indices-for-filling": {
		Doc: "(*vector.Path).AppendVerticesAndIndicesForFilling",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected block, native or nil")
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForFilling(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-vertex")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-vector-path//append-vertices-and-indices-for-stroke": {
		Doc: "(*vector.Path).AppendVerticesAndIndicesForStroke",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected block, native or nil")
			}
			var arg3Val *vector.StrokeOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected native")
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForStroke(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-vertex")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-vector-path//close": {
		Doc: "(*vector.Path).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//close: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//close: arg 1: expected native")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"ptr-vector-path//line-to": {
		Doc: "(*vector.Path).LineTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//line-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//line-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//line-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//line-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//line-to: arg 3: expected decimal")
			}
			arg0Val.LineTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-vector-path//move-to": {
		Doc: "(*vector.Path).MoveTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//move-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//move-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//move-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//move-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//move-to: arg 3: expected decimal")
			}
			arg0Val.MoveTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-vector-path//quad-to": {
		Doc: "(*vector.Path).QuadTo",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-path//quad-to: arg 5: expected decimal")
			}
			arg0Val.QuadTo(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-cap!": {
		Doc: "Set *vector.StrokeOptions LineCap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineCap
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineCap)
				}
				if natOk && natValOk {
					self.LineCap = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap!: arg 2: expected integer")
					}
					self.LineCap = vector.LineCap(u)
				}
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-cap?": {
		Doc: "Get *vector.StrokeOptions LineCap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineCap)))
			return resObj
		},
	},
	"ptr-vector-stroke-options//line-join!": {
		Doc: "Set *vector.StrokeOptions LineJoin value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineJoin
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineJoin)
				}
				if natOk && natValOk {
					self.LineJoin = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join!: arg 2: expected integer")
					}
					self.LineJoin = vector.LineJoin(u)
				}
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-join?": {
		Doc: "Get *vector.StrokeOptions LineJoin value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineJoin)))
			return resObj
		},
	},
	"ptr-vector-stroke-options//miter-limit!": {
		Doc: "Set *vector.StrokeOptions MiterLimit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.MiterLimit = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//miter-limit?": {
		Doc: "Get *vector.StrokeOptions MiterLimit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.MiterLimit))
			return resObj
		},
	},
	"ptr-vector-stroke-options//width!": {
		Doc: "Set *vector.StrokeOptions Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//width?": {
		Doc: "Get *vector.StrokeOptions Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"ptr-vorbis-stream//length": {
		Doc: "(*vorbis.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//length: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-vorbis-stream//read": {
		Doc: "(*vorbis.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-vorbis-stream//seek": {
		Doc: "(*vorbis.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//seek: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-vorbis-stream//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-wav-stream//length": {
		Doc: "(*wav.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//length: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-wav-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-wav-stream//read": {
		Doc: "(*wav.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-wav-stream//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-wav-stream//seek": {
		Doc: "(*wav.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//seek: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("ptr-wav-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("ptr-wav-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-wav-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("ptr-wav-stream//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"shader-1-gopher-bg-png": {
		Doc: "Get shader_1.GopherBg_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.GopherBg_png))
				for i, it := range shader_1.GopherBg_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"shader-1-gopher-png": {
		Doc: "Get shader_1.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.Gopher_png))
				for i, it := range shader_1.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"shader-1-noise-png": {
		Doc: "Get shader_1.Noise_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.Noise_png))
				for i, it := range shader_1.Noise_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"shader-1-normal-png": {
		Doc: "Get shader_1.Normal_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.Normal_png))
				for i, it := range shader_1.Normal_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"text-1-advance": {
		Doc: "text_1.Advance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-advance: arg 1: expected string")
			}
			var arg1Val text_1.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-advance: arg 2: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-advance: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-advance: arg 2: expected native")
			}
			res0 := text_1.Advance(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-1-align-center": {
		Doc: "Get text_1.AlignCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.AlignCenter)))
			return resObj
		},
	},
	"text-1-align-end": {
		Doc: "Get text_1.AlignEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.AlignEnd)))
			return resObj
		},
	},
	"text-1-align-start": {
		Doc: "Get text_1.AlignStart value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.AlignStart)))
			return resObj
		},
	},
	"text-1-append-glyphs": {
		Doc: "text_1.AppendGlyphs",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text_1.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text_1.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text_1.Glyph)
						if !ok {
							ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 1: block item: expected native of type text_1.Glyph")
						}
					default:
						ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 1: expected native of type []text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 2: expected string")
			}
			var arg2Val text_1.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 3: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 3: expected native")
			}
			var arg3Val *text_1.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 4: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-append-glyphs: arg 4: expected native")
			}
			res0 := text_1.AppendGlyphs(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "text-1-glyph")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"text-1-append-vector-path": {
		Doc: "text_1.AppendVectorPath",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 2: expected string")
			}
			var arg2Val text_1.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 3: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 3: expected native")
			}
			var arg3Val *text_1.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 4: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-append-vector-path: arg 4: expected native")
			}
			text_1.AppendVectorPath(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-1-cache-glyphs": {
		Doc: "text_1.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-cache-glyphs: arg 1: expected string")
			}
			var arg1Val text_1.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-cache-glyphs: arg 2: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-cache-glyphs: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-cache-glyphs: arg 2: expected native")
			}
			text_1.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"text-1-direction-left-to-right": {
		Doc: "Get text_1.DirectionLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionLeftToRight)))
			return resObj
		},
	},
	"text-1-direction-right-to-left": {
		Doc: "Get text_1.DirectionRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionRightToLeft)))
			return resObj
		},
	},
	"text-1-direction-top-to-bottom-and-left-to-right": {
		Doc: "Get text_1.DirectionTopToBottomAndLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionTopToBottomAndLeftToRight)))
			return resObj
		},
	},
	"text-1-direction-top-to-bottom-and-right-to-left": {
		Doc: "Get text_1.DirectionTopToBottomAndRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionTopToBottomAndRightToLeft)))
			return resObj
		},
	},
	"text-1-draw": {
		Doc: "text_1.Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-draw: arg 2: expected string")
			}
			var arg2Val text_1.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw: arg 3: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-draw: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw: arg 3: expected native")
			}
			var arg3Val *text_1.DrawOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw: arg 4: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-draw: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw: arg 4: expected native")
			}
			text_1.Draw(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-1-draw-options//blend!": {
		Doc: "Set text_1.DrawOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//blend!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//blend?": {
		Doc: "Get text_1.DrawOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//blend?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"text-1-draw-options//color-m!": {
		Doc: "Set text_1.DrawOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-m!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//color-m?": {
		Doc: "Get text_1.DrawOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-m?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"text-1-draw-options//color-scale!": {
		Doc: "Set text_1.DrawOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-scale!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//color-scale?": {
		Doc: "Get text_1.DrawOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-scale?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"text-1-draw-options//composite-mode!": {
		Doc: "Set text_1.DrawOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//composite-mode!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-draw-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//composite-mode?": {
		Doc: "Get text_1.DrawOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//composite-mode?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"text-1-draw-options//filter!": {
		Doc: "Set text_1.DrawOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//filter!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-draw-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//filter?": {
		Doc: "Get text_1.DrawOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//filter?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"text-1-draw-options//geo-m!": {
		Doc: "Set text_1.DrawOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//geo-m!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//geo-m?": {
		Doc: "Get text_1.DrawOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//geo-m?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"text-1-draw-options//line-spacing!": {
		Doc: "Set text_1.DrawOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//line-spacing!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-draw-options//line-spacing?": {
		Doc: "Get text_1.DrawOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//line-spacing?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"text-1-draw-options//primary-align!": {
		Doc: "Set text_1.DrawOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//primary-align!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-draw-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//primary-align?": {
		Doc: "Get text_1.DrawOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//primary-align?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"text-1-draw-options//secondary-align!": {
		Doc: "Set text_1.DrawOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//secondary-align!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-draw-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//secondary-align?": {
		Doc: "Get text_1.DrawOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-draw-options//secondary-align?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-draw-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"text-1-face//metrics": {
		Doc: "text_1.Face.Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-face//metrics: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"text-1-glyph//end-index-in-bytes!": {
		Doc: "Set text_1.Glyph EndIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//end-index-in-bytes!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//end-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.EndIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-glyph//end-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"text-1-glyph//end-index-in-bytes?": {
		Doc: "Get text_1.Glyph EndIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//end-index-in-bytes?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//end-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.EndIndexInBytes))
			return resObj
		},
	},
	"text-1-glyph//gid!": {
		Doc: "Set text_1.Glyph GID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//gid!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//gid!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.GID = uint32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-glyph//gid!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"text-1-glyph//gid?": {
		Doc: "Get text_1.Glyph GID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//gid?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//gid?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.GID))
			return resObj
		},
	},
	"text-1-glyph//image!": {
		Doc: "Set text_1.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//image!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-glyph//image?": {
		Doc: "Get text_1.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//image?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"text-1-glyph//start-index-in-bytes!": {
		Doc: "Set text_1.Glyph StartIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//start-index-in-bytes!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//start-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StartIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-glyph//start-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"text-1-glyph//start-index-in-bytes?": {
		Doc: "Get text_1.Glyph StartIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//start-index-in-bytes?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//start-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StartIndexInBytes))
			return resObj
		},
	},
	"text-1-glyph//x!": {
		Doc: "Set text_1.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//x!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-glyph//x?": {
		Doc: "Get text_1.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//x?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"text-1-glyph//y!": {
		Doc: "Set text_1.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//y!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-glyph//y?": {
		Doc: "Get text_1.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-glyph//y?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"text-1-go-text-face//direction!": {
		Doc: "Set text_1.GoTextFace Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//direction!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//direction!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Direction
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Direction)
				}
				if natOk && natValOk {
					self.Direction = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-go-text-face//direction!: arg 2: expected integer")
					}
					self.Direction = text_1.Direction(u)
				}
			}
			return arg0
		},
	},
	"text-1-go-text-face//direction?": {
		Doc: "Get text_1.GoTextFace Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//direction?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//direction?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Direction)))
			return resObj
		},
	},
	"text-1-go-text-face//language!": {
		Doc: "Set text_1.GoTextFace Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//language!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//language!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Language, ok = v.Value.(language.Tag)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//language!: arg 2: expected native of type language.Tag")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//language!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-go-text-face//language?": {
		Doc: "Get text_1.GoTextFace Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//language?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//language?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Language, "language-tag")
			return resObj
		},
	},
	"text-1-go-text-face//script!": {
		Doc: "Set text_1.GoTextFace Script value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//script!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//script!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Script, ok = v.Value.(language.Script)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//script!: arg 2: expected native of type language.Script")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//script!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-go-text-face//script?": {
		Doc: "Get text_1.GoTextFace Script value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//script?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//script?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Script, "language-script")
			return resObj
		},
	},
	"text-1-go-text-face//size!": {
		Doc: "Set text_1.GoTextFace Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//size!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Size = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-go-text-face//size?": {
		Doc: "Get text_1.GoTextFace Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//size?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Size))
			return resObj
		},
	},
	"text-1-go-text-face//source!": {
		Doc: "Set text_1.GoTextFace Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(*text_1.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source!: arg 2: expected native of type *text_1.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source!: arg 2: expected integer to be 0 or nil")
				}
				self.Source = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-go-text-face//source?": {
		Doc: "Get text_1.GoTextFace Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-go-text-face//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "ptr-text-1-go-text-face-source")
			return resObj
		},
	},
	"text-1-layout-options//line-spacing!": {
		Doc: "Set text_1.LayoutOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-layout-options//line-spacing!: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-layout-options//line-spacing?": {
		Doc: "Get text_1.LayoutOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-layout-options//line-spacing?: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"text-1-layout-options//primary-align!": {
		Doc: "Set text_1.LayoutOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-layout-options//primary-align!: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-layout-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-layout-options//primary-align?": {
		Doc: "Get text_1.LayoutOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-layout-options//primary-align?: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"text-1-layout-options//secondary-align!": {
		Doc: "Set text_1.LayoutOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-layout-options//secondary-align!: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-layout-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-layout-options//secondary-align?": {
		Doc: "Get text_1.LayoutOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-layout-options//secondary-align?: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-layout-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"text-1-measure": {
		Doc: "text_1.Measure",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-measure: arg 1: expected string")
			}
			var arg1Val text_1.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-measure: arg 2: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-measure: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-measure: arg 2: expected native")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-measure: arg 3: expected decimal")
			}
			res0, res1 := text_1.Measure(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"width": res0Obj,
				"height": res1Obj,
			})
		},
	},
	"text-1-metadata//family!": {
		Doc: "Set text_1.Metadata Family value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//family!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//family!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Family = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metadata//family!: arg 2: expected string")
			}
			return arg0
		},
	},
	"text-1-metadata//family?": {
		Doc: "Get text_1.Metadata Family value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//family?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//family?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Family)
			return resObj
		},
	},
	"text-1-metadata//stretch!": {
		Doc: "Set text_1.Metadata Stretch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//stretch!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//stretch!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Stretch
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Stretch)
				}
				if natOk && natValOk {
					self.Stretch = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-metadata//stretch!: arg 2: expected decimal")
					}
					self.Stretch = text_1.Stretch(u)
				}
			}
			return arg0
		},
	},
	"text-1-metadata//stretch?": {
		Doc: "Get text_1.Metadata Stretch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//stretch?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//stretch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Stretch)))
			return resObj
		},
	},
	"text-1-metadata//style!": {
		Doc: "Set text_1.Metadata Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//style!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//style!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Style
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Style)
				}
				if natOk && natValOk {
					self.Style = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-metadata//style!: arg 2: expected integer")
					}
					self.Style = text_1.Style(u)
				}
			}
			return arg0
		},
	},
	"text-1-metadata//style?": {
		Doc: "Get text_1.Metadata Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//style?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Style)))
			return resObj
		},
	},
	"text-1-metadata//weight!": {
		Doc: "Set text_1.Metadata Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//weight!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//weight!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Weight
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Weight)
				}
				if natOk && natValOk {
					self.Weight = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-metadata//weight!: arg 2: expected decimal")
					}
					self.Weight = text_1.Weight(u)
				}
			}
			return arg0
		},
	},
	"text-1-metadata//weight?": {
		Doc: "Get text_1.Metadata Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metadata//weight?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metadata//weight?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Weight)))
			return resObj
		},
	},
	"text-1-metrics//h-ascent!": {
		Doc: "Set text_1.Metrics HAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//h-ascent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//h-ascent?": {
		Doc: "Get text_1.Metrics HAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//h-ascent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HAscent))
			return resObj
		},
	},
	"text-1-metrics//h-descent!": {
		Doc: "Set text_1.Metrics HDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//h-descent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//h-descent?": {
		Doc: "Get text_1.Metrics HDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//h-descent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HDescent))
			return resObj
		},
	},
	"text-1-metrics//h-line-gap!": {
		Doc: "Set text_1.Metrics HLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//h-line-gap!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//h-line-gap?": {
		Doc: "Get text_1.Metrics HLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//h-line-gap?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//h-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HLineGap))
			return resObj
		},
	},
	"text-1-metrics//v-ascent!": {
		Doc: "Set text_1.Metrics VAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//v-ascent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//v-ascent?": {
		Doc: "Get text_1.Metrics VAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//v-ascent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VAscent))
			return resObj
		},
	},
	"text-1-metrics//v-descent!": {
		Doc: "Set text_1.Metrics VDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//v-descent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//v-descent?": {
		Doc: "Get text_1.Metrics VDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//v-descent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VDescent))
			return resObj
		},
	},
	"text-1-metrics//v-line-gap!": {
		Doc: "Set text_1.Metrics VLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//v-line-gap!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//v-line-gap?": {
		Doc: "Get text_1.Metrics VLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-metrics//v-line-gap?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-1-metrics//v-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VLineGap))
			return resObj
		},
	},
	"text-1-must-parse-tag": {
		Doc: "text_1.MustParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-must-parse-tag: arg 1: expected string")
			}
			res0 := text_1.MustParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			return res0Obj
		},
	},
	"text-1-limited-face": {
		Doc: "text_1.NewLimitedFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-limited-face: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-limited-face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-limited-face: arg 1: expected native")
			}
			res0 := text_1.NewLimitedFace(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-1-limited-face")
			return res0Obj
		},
	},
	"text-1-multi-face": {
		Doc: "text_1.NewMultiFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text_1.Face
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text_1.Face, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text_1.Face)
						if !ok {
							ps.FailureFlag = true
return env.NewError("text-1-multi-face: arg 1: block item: expected native of type text_1.Face")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
return env.NewError("text-1-multi-face: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
return env.NewError("text-1-multi-face: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text_1.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-1-multi-face: arg 1: expected native of type []text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-1-multi-face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-1-multi-face: arg 1: expected block, native or nil")
			}
			res0, res1 := text_1.NewMultiFace(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-1-multi-face")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"text-1-parse-tag": {
		Doc: "text_1.ParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-1-parse-tag: arg 1: expected string")
			}
			res0, res1 := text_1.ParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"text-1-stretch-condensed": {
		Doc: "Get text_1.StretchCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchCondensed)))
			return resObj
		},
	},
	"text-1-stretch-expanded": {
		Doc: "Get text_1.StretchExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchExpanded)))
			return resObj
		},
	},
	"text-1-stretch-extra-condensed": {
		Doc: "Get text_1.StretchExtraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchExtraCondensed)))
			return resObj
		},
	},
	"text-1-stretch-extra-expanded": {
		Doc: "Get text_1.StretchExtraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchExtraExpanded)))
			return resObj
		},
	},
	"text-1-stretch-normal": {
		Doc: "Get text_1.StretchNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchNormal)))
			return resObj
		},
	},
	"text-1-stretch-semi-condensed": {
		Doc: "Get text_1.StretchSemiCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchSemiCondensed)))
			return resObj
		},
	},
	"text-1-stretch-semi-expanded": {
		Doc: "Get text_1.StretchSemiExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchSemiExpanded)))
			return resObj
		},
	},
	"text-1-stretch-ultra-condensed": {
		Doc: "Get text_1.StretchUltraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchUltraCondensed)))
			return resObj
		},
	},
	"text-1-stretch-ultra-expanded": {
		Doc: "Get text_1.StretchUltraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchUltraExpanded)))
			return resObj
		},
	},
	"text-1-style-italic": {
		Doc: "Get text_1.StyleItalic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text_1.StyleItalic)))
			return resObj
		},
	},
	"text-1-style-normal": {
		Doc: "Get text_1.StyleNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text_1.StyleNormal)))
			return resObj
		},
	},
	"text-1-tag//string": {
		Doc: "text_1.Tag.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text_1.Tag
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u uint32
					if v, ok := arg0.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("text-1-tag//string: arg 1: expected integer")
					}
					arg0Val = text_1.Tag(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"text-1-weight-black": {
		Doc: "Get text_1.WeightBlack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightBlack)))
			return resObj
		},
	},
	"text-1-weight-bold": {
		Doc: "Get text_1.WeightBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightBold)))
			return resObj
		},
	},
	"text-1-weight-extra-bold": {
		Doc: "Get text_1.WeightExtraBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightExtraBold)))
			return resObj
		},
	},
	"text-1-weight-extra-light": {
		Doc: "Get text_1.WeightExtraLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightExtraLight)))
			return resObj
		},
	},
	"text-1-weight-light": {
		Doc: "Get text_1.WeightLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightLight)))
			return resObj
		},
	},
	"text-1-weight-medium": {
		Doc: "Get text_1.WeightMedium value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightMedium)))
			return resObj
		},
	},
	"text-1-weight-normal": {
		Doc: "Get text_1.WeightNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightNormal)))
			return resObj
		},
	},
	"text-1-weight-semibold": {
		Doc: "Get text_1.WeightSemibold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightSemibold)))
			return resObj
		},
	},
	"text-1-weight-thin": {
		Doc: "Get text_1.WeightThin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightThin)))
			return resObj
		},
	},
	"text-append-glyphs": {
		Doc: "text.AppendGlyphs",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text.Glyph)
						if !ok {
							ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 1: block item: expected native of type text.Glyph")
						}
					default:
						ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 1: expected native of type []text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 1: expected block, native or nil")
			}
			var arg1Val font.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 2: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-append-glyphs: arg 3: expected string")
			}
			res0 := text.AppendGlyphs(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "text-glyph")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"text-bound-string": {
		Doc: "text.BoundString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-bound-string: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-bound-string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-bound-string: arg 2: expected string")
			}
			res0 := text.BoundString(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-rectangle")
			return res0Obj
		},
	},
	"text-cache-glyphs": {
		Doc: "text.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-cache-glyphs: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-cache-glyphs: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-cache-glyphs: arg 2: expected string")
			}
			text.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"text-draw-with-options": {
		Doc: "text.DrawWithOptions",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 2: expected string")
			}
			var arg2Val font.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 3: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 3: expected native")
			}
			var arg3Val *ebiten.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 4: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-draw-with-options: arg 4: expected native")
			}
			text.DrawWithOptions(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-face-with-line-height": {
		Doc: "text.FaceWithLineHeight",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-face-with-line-height: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-face-with-line-height: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-face-with-line-height: arg 2: expected decimal")
			}
			res0 := text.FaceWithLineHeight(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "font-face")
			return res0Obj
		},
	},
	"text-glyph//image!": {
		Doc: "Set text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//image!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("text-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-glyph//image?": {
		Doc: "Get text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//image?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"text-glyph//rune!": {
		Doc: "Set text.Glyph Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//rune!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-glyph//rune?": {
		Doc: "Get text.Glyph Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//rune?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"text-glyph//x!": {
		Doc: "Set text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//x!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-glyph//x?": {
		Doc: "Get text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//x?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"text-glyph//y!": {
		Doc: "Set text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//y!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("text-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-glyph//y?": {
		Doc: "Get text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
return env.NewError("text-glyph//y?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
return env.NewError("text-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"textinput-state//committed!": {
		Doc: "Set textinput.State Committed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//committed!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//committed!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Committed = v.Value != 0
			} else {
				ps.FailureFlag = true
return env.NewError("textinput-state//committed!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"textinput-state//committed?": {
		Doc: "Get textinput.State Committed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//committed?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//committed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Committed))
			return resObj
		},
	},
	"textinput-state//composition-selection-end-in-bytes!": {
		Doc: "Set textinput.State CompositionSelectionEndInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-end-in-bytes!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-end-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionEndInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-end-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"textinput-state//composition-selection-end-in-bytes?": {
		Doc: "Get textinput.State CompositionSelectionEndInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-end-in-bytes?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-end-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionEndInBytes))
			return resObj
		},
	},
	"textinput-state//composition-selection-start-in-bytes!": {
		Doc: "Set textinput.State CompositionSelectionStartInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-start-in-bytes!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-start-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionStartInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-start-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"textinput-state//composition-selection-start-in-bytes?": {
		Doc: "Get textinput.State CompositionSelectionStartInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-start-in-bytes?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//composition-selection-start-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionStartInBytes))
			return resObj
		},
	},
	"textinput-state//error!": {
		Doc: "Set textinput.State Error value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//error!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//error!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.String:
				self.Error = errors.New(v.Value)
			case env.Error:
				self.Error = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("textinput-state//error!: arg 2: expected integer to be 0 or nil")
				}
				self.Error = nil
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//error!: arg 2: expected error, string or nil")
				}
				return arg0
		},
	},
	"textinput-state//error?": {
		Doc: "Get textinput.State Error value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//error?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//error?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewError(self.Error.Error())
			return resObj
		},
	},
	"textinput-state//text!": {
		Doc: "Set textinput.State Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//text!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("textinput-state//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"textinput-state//text?": {
		Doc: "Get textinput.State Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
return env.NewError("textinput-state//text?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
return env.NewError("textinput-state//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"twenty-48-dir-down": {
		Doc: "Get twenty48.DirDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirDown)))
			return resObj
		},
	},
	"twenty-48-dir-left": {
		Doc: "Get twenty48.DirLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirLeft)))
			return resObj
		},
	},
	"twenty-48-dir-right": {
		Doc: "Get twenty48.DirRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirRight)))
			return resObj
		},
	},
	"twenty-48-dir-up": {
		Doc: "Get twenty48.DirUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirUp)))
			return resObj
		},
	},
	"twenty-48-dir//string": {
		Doc: "twenty48.Dir.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("twenty-48-dir//string: arg 1: expected integer")
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"twenty-48-dir//vector": {
		Doc: "twenty48.Dir.Vector",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("twenty-48-dir//vector: arg 1: expected integer")
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0, res1 := arg0Val.Vector()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"x": res0Obj,
				"y": res1Obj,
			})
		},
	},
	"twenty-48-game": {
		Doc: "twenty48.NewGame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, res1 := twenty48.NewGame()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-game")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"err": res1Obj,
			})
		},
	},
	"twenty-48-input": {
		Doc: "twenty48.NewInput",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := twenty48.NewInput()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-input")
			return res0Obj
		},
	},
	"twenty-48-tile": {
		Doc: "twenty48.NewTile",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("twenty-48-tile: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("twenty-48-tile: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("twenty-48-tile: arg 3: expected integer")
			}
			res0 := twenty48.NewTile(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-tile")
			return res0Obj
		},
	},
	"vector-clockwise": {
		Doc: "Get vector.Clockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.Clockwise)))
			return resObj
		},
	},
	"vector-counter-clockwise": {
		Doc: "Get vector.CounterClockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.CounterClockwise)))
			return resObj
		},
	},
	"vector-line-cap-butt": {
		Doc: "Get vector.LineCapButt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapButt)))
			return resObj
		},
	},
	"vector-line-cap-round": {
		Doc: "Get vector.LineCapRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapRound)))
			return resObj
		},
	},
	"vector-line-cap-square": {
		Doc: "Get vector.LineCapSquare value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapSquare)))
			return resObj
		},
	},
	"vector-line-join-bevel": {
		Doc: "Get vector.LineJoinBevel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinBevel)))
			return resObj
		},
	},
	"vector-line-join-miter": {
		Doc: "Get vector.LineJoinMiter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinMiter)))
			return resObj
		},
	},
	"vector-line-join-round": {
		Doc: "Get vector.LineJoinRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinRound)))
			return resObj
		},
	},
	"vector-stroke-options//line-cap!": {
		Doc: "Set vector.StrokeOptions LineCap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-cap!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-cap!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineCap
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineCap)
				}
				if natOk && natValOk {
					self.LineCap = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-cap!: arg 2: expected integer")
					}
					self.LineCap = vector.LineCap(u)
				}
			}
			return arg0
		},
	},
	"vector-stroke-options//line-cap?": {
		Doc: "Get vector.StrokeOptions LineCap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-cap?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-cap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineCap)))
			return resObj
		},
	},
	"vector-stroke-options//line-join!": {
		Doc: "Set vector.StrokeOptions LineJoin value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-join!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-join!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineJoin
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineJoin)
				}
				if natOk && natValOk {
					self.LineJoin = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-join!: arg 2: expected integer")
					}
					self.LineJoin = vector.LineJoin(u)
				}
			}
			return arg0
		},
	},
	"vector-stroke-options//line-join?": {
		Doc: "Get vector.StrokeOptions LineJoin value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-join?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//line-join?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineJoin)))
			return resObj
		},
	},
	"vector-stroke-options//miter-limit!": {
		Doc: "Set vector.StrokeOptions MiterLimit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//miter-limit!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//miter-limit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.MiterLimit = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//miter-limit!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"vector-stroke-options//miter-limit?": {
		Doc: "Get vector.StrokeOptions MiterLimit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//miter-limit?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//miter-limit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.MiterLimit))
			return resObj
		},
	},
	"vector-stroke-options//width!": {
		Doc: "Set vector.StrokeOptions Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//width!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"vector-stroke-options//width?": {
		Doc: "Get vector.StrokeOptions Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vector-stroke-options//width?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
return env.NewError("vector-stroke-options//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"vorbis-decode": {
		Doc: "vorbis.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode: arg 2: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode: arg 2: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode: arg 2: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: context to io.Reader: context fn read: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("vorbis-decode: arg 2: expected native")
				}
				res0, res1 := vorbis.Decode(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"vorbis-decode-with-sample-rate": {
		Doc: "vorbis.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-with-sample-rate: arg 2: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-with-sample-rate: arg 2: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-with-sample-rate: arg 2: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-with-sample-rate: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-with-sample-rate: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected native")
				}
				res0, res1 := vorbis.DecodeWithSampleRate(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"vorbis-decode-without-resampling": {
		Doc: "vorbis.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-without-resampling: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-without-resampling: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-without-resampling: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-without-resampling: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"vorbis-decode-without-resampling: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: context to io.Reader: context fn read: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("vorbis-decode-without-resampling: arg 1: expected native")
				}
				res0, res1 := vorbis.DecodeWithoutResampling(arg0Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"wav-decode": {
		Doc: "wav.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
return env.NewError("wav-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
return env.NewError("wav-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
return env.NewError("wav-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode: arg 2: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode: arg 2: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode: arg 2: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: context to io.Reader: context fn read: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("wav-decode: arg 2: expected native")
				}
				res0, res1 := wav.Decode(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"wav-decode-with-sample-rate": {
		Doc: "wav.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-with-sample-rate: arg 2: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-with-sample-rate: arg 2: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-with-sample-rate: arg 2: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-with-sample-rate: arg 2: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-with-sample-rate: arg 2: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: context to io.Reader: context fn read: expected function or nil")
					}
					arg1Val = impl
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("wav-decode-with-sample-rate: arg 2: expected native")
				}
				res0, res1 := wav.DecodeWithSampleRate(arg0Val, arg1Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
	"wav-decode-without-resampling": {
		Doc: "wav.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.RyeCtx:
				words := v.GetWords(*ps.Idx).Series.S
				wordToObj := make(map[string]env.Object, len(words))
				for _, word := range words {
					name := word.(env.String).Value
					idx, ok := ps.Idx.GetIndex(name)
					if !ok {
						panic("expected valid word")
					}
					obj, ok := v.Get(idx)
					if !ok {
						panic("expected valid index")
					}
					wordToObj[name] = obj
				}
				impl := &ryegen_io_Reader{
					self: v,
				}
				ctxObj0, ok := wordToObj["read"]
				if !ok {
					ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: context to io.Reader: expected context to have function read")
				}
				switch fn := ctxObj0.(type) {
				case env.Function:
					if fn.Argsn != 1 {
						ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: context to io.Reader: context fn read: function has invalid number of arguments (expected 1)")
					}
					impl.fn_Read = func(ctx env.RyeCtx, arg0 []byte) (int, error) {
						var arg0Val env.Object
						{
							items := make([]env.Object, len(arg0))
							for i, it := range arg0 {
								items[i] = *env.NewNative(ps.Idx, it, "byte")
							}
							arg0Val = *env.NewBlock(*env.NewTSeries(items))
						}
						actualFn := fn
						_ = actualFn
						evaldo.CallFunctionArgsN(fn, ps, &ctx, arg0Val)
						var res0 int
						var res1 error
						res, ok := ps.Res.(env.Block)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-without-resampling: arg 1: callback result: expected block for multiple return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if len(res.Series.S) != 2 {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-without-resampling: arg 1: callback result: expected block with 2 return values",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						if v, ok := res.Series.S[0].(env.Integer); ok {
							res0 = int(v.Value)
						} else {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-without-resampling: arg 1: callback result: expected integer",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
						}
						switch v := res.Series.S[1].(type) {
						case env.String:
							res1 = errors.New(v.Value)
						case env.Error:
							res1 = errors.New(v.Print(*ps.Idx))
						case env.Integer:
							if v.Value != 0 {
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-without-resampling: arg 1: callback result: expected integer to be 0 or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							res1 = nil
						default:
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v %v\033[m\n",
	"wav-decode-without-resampling: arg 1: callback result: expected error, string or nil",
	actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
	actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
	)
	return res0, res1
							}
							return res0, res1
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: context to io.Reader: context fn read: expected integer to be 0 or nil")
						}
						impl.fn_Read = nil
					default:
						ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: context to io.Reader: context fn read: expected function or nil")
					}
					arg0Val = impl
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(io.Reader)
					if !ok {
						ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: expected native of type io.Reader")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
return env.NewError("wav-decode-without-resampling: arg 1: expected native")
				}
				res0, res1 := wav.DecodeWithoutResampling(arg0Val)
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
				var res1Obj env.Object
				res1Obj = *env.NewError(res1.Error())
				return env.NewDict(map[string]any{
					"1": res0Obj,
					"err": res1Obj,
				})
		},
	},
}
