//go:build b_fyne

// Code generated by generator/generate. DO NOT EDIT.

package fyne

import (
	"errors"
	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/audio"
	"github.com/hajimehoshi/ebiten/v2/audio/mp3"
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis"
	"github.com/hajimehoshi/ebiten/v2/audio/wav"
	"github.com/hajimehoshi/ebiten/v2/colorm"
	"github.com/hajimehoshi/ebiten/v2/ebitenutil"
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048"
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks"
	"github.com/hajimehoshi/ebiten/v2/examples/keyboard/keyboard"
	"github.com/hajimehoshi/ebiten/v2/exp/textinput"
	"github.com/hajimehoshi/ebiten/v2/inpututil"
	"github.com/hajimehoshi/ebiten/v2/mobile"
	//	"github.com/hajimehoshi/ebiten/v2/mobile/ebitenmobileview"
	"github.com/hajimehoshi/ebiten/v2/text"
	text_1 "github.com/hajimehoshi/ebiten/v2/text/v2"
	"github.com/hajimehoshi/ebiten/v2/vector"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"golang.org/x/image/font"
	"golang.org/x/text/language"
	"image"
	"image/color"
	"io"
	"io/fs"
	"reflect"
	"time"
)

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

var ryeStructNameLookup = map[string]string{
	"github.com/ebitengine/purego/objc.*FieldDef":                           "ptr-objc-field-def",
	"github.com/ebitengine/purego/objc.*MethodDef":                          "ptr-objc-method-def",
	"github.com/ebitengine/purego/objc.FieldDef":                            "objc-field-def",
	"github.com/ebitengine/purego/objc.MethodDef":                           "objc-method-def",
	"github.com/hajimehoshi/ebiten/v2.*Blend":                               "ptr-ebiten-blend",
	"github.com/hajimehoshi/ebiten/v2.*ColorM":                              "ptr-ebiten-color-m",
	"github.com/hajimehoshi/ebiten/v2.*ColorScale":                          "ptr-ebiten-color-scale",
	"github.com/hajimehoshi/ebiten/v2.*DebugInfo":                           "ptr-ebiten-debug-info",
	"github.com/hajimehoshi/ebiten/v2.*DrawImageOptions":                    "ptr-ebiten-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2.*DrawTrianglesOptions":                "ptr-ebiten-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2.*DrawTrianglesShaderOptions":          "ptr-ebiten-draw-triangles-shader-options",
	"github.com/hajimehoshi/ebiten/v2.*GeoM":                                "ptr-ebiten-geo-m",
	"github.com/hajimehoshi/ebiten/v2.*Image":                               "ptr-ebiten-image",
	"github.com/hajimehoshi/ebiten/v2.*RunGameOptions":                      "ptr-ebiten-run-game-options",
	"github.com/hajimehoshi/ebiten/v2.*Shader":                              "ptr-ebiten-shader",
	"github.com/hajimehoshi/ebiten/v2.*Vertex":                              "ptr-ebiten-vertex",
	"github.com/hajimehoshi/ebiten/v2.*VibrateGamepadOptions":               "ptr-ebiten-vibrate-gamepad-options",
	"github.com/hajimehoshi/ebiten/v2.*VibrateOptions":                      "ptr-ebiten-vibrate-options",
	"github.com/hajimehoshi/ebiten/v2.Blend":                                "ebiten-blend",
	"github.com/hajimehoshi/ebiten/v2.ColorM":                               "ebiten-color-m",
	"github.com/hajimehoshi/ebiten/v2.ColorScale":                           "ebiten-color-scale",
	"github.com/hajimehoshi/ebiten/v2.DebugInfo":                            "ebiten-debug-info",
	"github.com/hajimehoshi/ebiten/v2.DrawImageOptions":                     "ebiten-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2.DrawTrianglesOptions":                 "ebiten-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2.DrawTrianglesShaderOptions":           "ebiten-draw-triangles-shader-options",
	"github.com/hajimehoshi/ebiten/v2.GeoM":                                 "ebiten-geo-m",
	"github.com/hajimehoshi/ebiten/v2.Image":                                "ebiten-image",
	"github.com/hajimehoshi/ebiten/v2.RunGameOptions":                       "ebiten-run-game-options",
	"github.com/hajimehoshi/ebiten/v2.Shader":                               "ebiten-shader",
	"github.com/hajimehoshi/ebiten/v2.Vertex":                               "ebiten-vertex",
	"github.com/hajimehoshi/ebiten/v2.VibrateGamepadOptions":                "ebiten-vibrate-gamepad-options",
	"github.com/hajimehoshi/ebiten/v2.VibrateOptions":                       "ebiten-vibrate-options",
	"github.com/hajimehoshi/ebiten/v2/audio.*InfiniteLoop":                  "ptr-audio-infinite-loop",
	"github.com/hajimehoshi/ebiten/v2/audio.InfiniteLoop":                   "audio-infinite-loop",
	"github.com/hajimehoshi/ebiten/v2/audio/mp3.*Stream":                    "ptr-mp-3-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/mp3.Stream":                     "mp-3-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis.*Stream":                 "ptr-vorbis-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/vorbis.Stream":                  "vorbis-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/wav.*Stream":                    "ptr-wav-stream",
	"github.com/hajimehoshi/ebiten/v2/audio/wav.Stream":                     "wav-stream",
	"github.com/hajimehoshi/ebiten/v2/colorm.*ColorM":                       "ptr-colorm-color-m",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawImageOptions":             "ptr-colorm-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.*DrawTrianglesOptions":         "ptr-colorm-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.ColorM":                        "colorm-color-m",
	"github.com/hajimehoshi/ebiten/v2/colorm.DrawImageOptions":              "colorm-draw-image-options",
	"github.com/hajimehoshi/ebiten/v2/colorm.DrawTrianglesOptions":          "colorm-draw-triangles-options",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Game":             "ptr-twenty-48-game",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Input":            "ptr-twenty-48-input",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*Tile":             "ptr-twenty-48-tile",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.*TileData":         "ptr-twenty-48-tile-data",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.Game":              "twenty-48-game",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.Input":             "twenty-48-input",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.Tile":              "twenty-48-tile",
	"github.com/hajimehoshi/ebiten/v2/examples/2048/2048.TileData":          "twenty-48-tile-data",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Field":        "ptr-blocks-field",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Game":         "ptr-blocks-game",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameScene":    "ptr-blocks-game-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GameState":    "ptr-blocks-game-state",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*GamepadScene": "ptr-blocks-gamepad-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Input":        "ptr-blocks-input",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*Piece":        "ptr-blocks-piece",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*SceneManager": "ptr-blocks-scene-manager",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.*TitleScene":   "ptr-blocks-title-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Field":         "blocks-field",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Game":          "blocks-game",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.GameScene":     "blocks-game-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.GameState":     "blocks-game-state",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.GamepadScene":  "blocks-gamepad-scene",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Input":         "blocks-input",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.Piece":         "blocks-piece",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.SceneManager":  "blocks-scene-manager",
	"github.com/hajimehoshi/ebiten/v2/examples/blocks/blocks.TitleScene":    "blocks-title-scene",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.*State":                 "ptr-textinput-state",
	"github.com/hajimehoshi/ebiten/v2/exp/textinput.State":                  "textinput-state",
	"github.com/hajimehoshi/ebiten/v2/text.*Glyph":                          "ptr-text-glyph",
	"github.com/hajimehoshi/ebiten/v2/text.Glyph":                           "text-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*DrawOptions":                 "ptr-text-1-draw-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Glyph":                       "ptr-text-1-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*GoTextFace":                  "ptr-text-1-go-text-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LayoutOptions":               "ptr-text-1-layout-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*LimitedFace":                 "ptr-text-1-limited-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metadata":                    "ptr-text-1-metadata",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*Metrics":                     "ptr-text-1-metrics",
	"github.com/hajimehoshi/ebiten/v2/text/v2.*MultiFace":                   "ptr-text-1-multi-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.DrawOptions":                  "text-1-draw-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.Glyph":                        "text-1-glyph",
	"github.com/hajimehoshi/ebiten/v2/text/v2.GoTextFace":                   "text-1-go-text-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.LayoutOptions":                "text-1-layout-options",
	"github.com/hajimehoshi/ebiten/v2/text/v2.LimitedFace":                  "text-1-limited-face",
	"github.com/hajimehoshi/ebiten/v2/text/v2.Metadata":                     "text-1-metadata",
	"github.com/hajimehoshi/ebiten/v2/text/v2.Metrics":                      "text-1-metrics",
	"github.com/hajimehoshi/ebiten/v2/text/v2.MultiFace":                    "text-1-multi-face",
	"github.com/hajimehoshi/ebiten/v2/vector.*Path":                         "ptr-vector-path",
	"github.com/hajimehoshi/ebiten/v2/vector.*StrokeOptions":                "ptr-vector-stroke-options",
	"github.com/hajimehoshi/ebiten/v2/vector.Path":                          "vector-path",
	"github.com/hajimehoshi/ebiten/v2/vector.StrokeOptions":                 "vector-stroke-options",
	"io.*LimitedReader": "ptr-io-limited-reader",
	"io.*PipeReader":    "ptr-io-pipe-reader",
	"io.*PipeWriter":    "ptr-io-pipe-writer",
	"io.*SectionReader": "ptr-io-section-reader",
	"io.LimitedReader":  "io-limited-reader",
	"io.PipeReader":     "io-pipe-reader",
	"io.PipeWriter":     "io-pipe-writer",
	"io.SectionReader":  "io-section-reader",
	"io/fs.*PathError":  "ptr-fs-path-error",
	"io/fs.PathError":   "fs-path-error",
}

var Builtins_fyne = map[string]*env.Builtin{
	"nil": {
		Doc: "nil value for go types",
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			return *env.NewInteger(0)
		},
	},
	"audio-1-jab-wav": {
		Doc:   "Get audio_1.Jab_wav value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Jab_wav))
				for i, it := range audio_1.Jab_wav {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-1-jump-ogg": {
		Doc:   "Get audio_1.Jump_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Jump_ogg))
				for i, it := range audio_1.Jump_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-1-ragtime-mp-3": {
		Doc:   "Get audio_1.Ragtime_mp3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Ragtime_mp3))
				for i, it := range audio_1.Ragtime_mp3 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-1-ragtime-ogg": {
		Doc:   "Get audio_1.Ragtime_ogg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_1.Ragtime_ogg))
				for i, it := range audio_1.Ragtime_ogg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-2-alert-png": {
		Doc:   "Get audio_2.Alert_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_2.Alert_png))
				for i, it := range audio_2.Alert_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-2-pause-png": {
		Doc:   "Get audio_2.Pause_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_2.Pause_png))
				for i, it := range audio_2.Pause_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-2-play-png": {
		Doc:   "Get audio_2.Play_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(audio_2.Play_png))
				for i, it := range audio_2.Play_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"audio-infinite-loop": {
		Doc:   "audio.NewInfiniteLoop",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.ReadSeeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: expected native of type io.ReadSeeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop: arg 2: expected integer")
			}
			res0 := audio.NewInfiniteLoop(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-infinite-loop")
			return res0Obj
		},
	},
	"audio-infinite-loop-with-intro": {
		Doc:   "audio.NewInfiniteLoopWithIntro",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.ReadSeeker
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.ReadSeeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: expected native of type io.ReadSeeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("audio-infinite-loop-with-intro: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 2: expected integer")
			}
			var arg2Val int64
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("audio-infinite-loop-with-intro: arg 3: expected integer")
			}
			res0 := audio.NewInfiniteLoopWithIntro(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-audio-infinite-loop")
			return res0Obj
		},
	},
	"blend-dest-png": {
		Doc:   "Get blend.Dest_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Dest_png))
				for i, it := range blend.Dest_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blend-source-png": {
		Doc:   "Get blend.Source_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blend.Source_png))
				for i, it := range blend.Source_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-1-background-png": {
		Doc:   "Get blocks_1.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blocks_1.Background_png))
				for i, it := range blocks_1.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-1-blocks-png": {
		Doc:   "Get blocks_1.Blocks_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(blocks_1.Blocks_png))
				for i, it := range blocks_1.Blocks_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"blocks-angle-0": {
		Doc:   "Get blocks.Angle0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle0)))
			return resObj
		},
	},
	"blocks-angle-180": {
		Doc:   "Get blocks.Angle180 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle180)))
			return resObj
		},
	},
	"blocks-angle-270": {
		Doc:   "Get blocks.Angle270 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle270)))
			return resObj
		},
	},
	"blocks-angle-90": {
		Doc:   "Get blocks.Angle90 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.Angle90)))
			return resObj
		},
	},
	"blocks-angle//rotate-left": {
		Doc:   "blocks.Angle.RotateLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("blocks-angle//rotate-left: arg 1: expected integer")
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"blocks-angle//rotate-right": {
		Doc:   "blocks.Angle.RotateRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val blocks.Angle
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("blocks-angle//rotate-right: arg 1: expected integer")
					}
					arg0Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotateRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"blocks-block-type-1": {
		Doc:   "Get blocks.BlockType1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType1)))
			return resObj
		},
	},
	"blocks-block-type-2": {
		Doc:   "Get blocks.BlockType2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType2)))
			return resObj
		},
	},
	"blocks-block-type-3": {
		Doc:   "Get blocks.BlockType3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType3)))
			return resObj
		},
	},
	"blocks-block-type-4": {
		Doc:   "Get blocks.BlockType4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType4)))
			return resObj
		},
	},
	"blocks-block-type-5": {
		Doc:   "Get blocks.BlockType5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType5)))
			return resObj
		},
	},
	"blocks-block-type-6": {
		Doc:   "Get blocks.BlockType6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType6)))
			return resObj
		},
	},
	"blocks-block-type-7": {
		Doc:   "Get blocks.BlockType7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockType7)))
			return resObj
		},
	},
	"blocks-block-type-max": {
		Doc:   "Get blocks.BlockTypeMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeMax)))
			return resObj
		},
	},
	"blocks-block-type-none": {
		Doc:   "Get blocks.BlockTypeNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(blocks.BlockTypeNone)))
			return resObj
		},
	},
	"blocks-game-state//input!": {
		Doc:   "Set blocks.GameState Input value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//input!: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-game-state//input!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Input, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//input!: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//input!: arg 2: expected integer to be 0 or nil")
				}
				self.Input = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-game-state//input!: arg 2: expected native")
			}
			return arg0
		},
	},
	"blocks-game-state//input?": {
		Doc:   "Get blocks.GameState Input value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//input?: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-game-state//input?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Input, "ptr-blocks-input")
			return resObj
		},
	},
	"blocks-game-state//scene-manager!": {
		Doc:   "Set blocks.GameState SceneManager value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//scene-manager!: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-game-state//scene-manager!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SceneManager, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//scene-manager!: arg 2: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//scene-manager!: arg 2: expected integer to be 0 or nil")
				}
				self.SceneManager = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-game-state//scene-manager!: arg 2: expected native")
			}
			return arg0
		},
	},
	"blocks-game-state//scene-manager?": {
		Doc:   "Get blocks.GameState SceneManager value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-game-state//scene-manager?: arg 1: expected native of type blocks.GameState")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-game-state//scene-manager?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SceneManager, "ptr-blocks-scene-manager")
			return resObj
		},
	},
	"blocks-game-scene": {
		Doc:   "blocks.NewGameScene",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := blocks.NewGameScene()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-blocks-game-scene")
			return res0Obj
		},
	},
	"blocks-pieces": {
		Doc:   "Get blocks.Pieces value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, blocks.Pieces, "map(blocks-block-type)ptr-blocks-piece")
			return resObj
		},
	},
	"blocks-scene//draw": {
		Doc:   "blocks.Scene.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(blocks.Scene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 1: expected native of type blocks.Scene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"blocks-scene//update": {
		Doc:   "blocks.Scene.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val blocks.Scene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(blocks.Scene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 1: expected native of type blocks.Scene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("blocks-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("blocks-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"colorm-draw-image": {
		Doc:   "colorm.DrawImage",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 2: expected native")
			}
			var arg2Val colorm.ColorM
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 3: expected native of type colorm.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 3: expected native")
			}
			var arg3Val *colorm.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 4: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image: arg 4: expected native")
			}
			colorm.DrawImage(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"colorm-draw-image-options//blend!": {
		Doc:   "Set colorm.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//blend!: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"colorm-draw-image-options//blend?": {
		Doc:   "Get colorm.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//blend?: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"colorm-draw-image-options//filter!": {
		Doc:   "Set colorm.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//filter!: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("colorm-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-image-options//filter?": {
		Doc:   "Get colorm.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//filter?: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"colorm-draw-image-options//geo-m!": {
		Doc:   "Set colorm.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//geo-m!: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"colorm-draw-image-options//geo-m?": {
		Doc:   "Get colorm.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-image-options//geo-m?: arg 1: expected native of type colorm.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"colorm-draw-triangles-options//address!": {
		Doc:   "Set colorm.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//address!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("colorm-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//address?": {
		Doc:   "Get colorm.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//address?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"colorm-draw-triangles-options//anti-alias!": {
		Doc:   "Set colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//anti-alias!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//anti-alias?": {
		Doc:   "Get colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//anti-alias?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"colorm-draw-triangles-options//blend!": {
		Doc:   "Set colorm.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//blend!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//blend?": {
		Doc:   "Get colorm.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//blend?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"colorm-draw-triangles-options//color-scale-mode!": {
		Doc:   "Set colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("colorm-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//color-scale-mode?": {
		Doc:   "Get colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"colorm-draw-triangles-options//fill-rule!": {
		Doc:   "Set colorm.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//fill-rule!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("colorm-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//fill-rule?": {
		Doc:   "Get colorm.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//fill-rule?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"colorm-draw-triangles-options//filter!": {
		Doc:   "Set colorm.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//filter!: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("colorm-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"colorm-draw-triangles-options//filter?": {
		Doc:   "Get colorm.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colorm-draw-triangles-options//filter?: arg 1: expected native of type colorm.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("colorm-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"actual-fps": {
		Doc:   "ebiten.ActualFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.ActualFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"actual-tps": {
		Doc:   "ebiten.ActualTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.ActualTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"address-clamp-to-zero": {
		Doc:   "Get ebiten.AddressClampToZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressClampToZero)))
			return resObj
		},
	},
	"address-repeat": {
		Doc:   "Get ebiten.AddressRepeat value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressRepeat)))
			return resObj
		},
	},
	"address-unsafe": {
		Doc:   "Get ebiten.AddressUnsafe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.AddressUnsafe)))
			return resObj
		},
	},
	"append-gamepad-i-ds": {
		Doc:   "ebiten.AppendGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("append-gamepad-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.GamepadID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.GamepadID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-gamepad-i-ds: arg 1: expected native of type []ebiten.GamepadID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-gamepad-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-gamepad-i-ds: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-input-chars": {
		Doc:   "ebiten.AppendInputChars",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []rune
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(rune)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("append-input-chars: arg 1: block item: expected native of type rune")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("append-input-chars: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-input-chars: arg 1: expected native of type []rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-input-chars: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-input-chars: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendInputChars(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-monitors": {
		Doc:   "ebiten.AppendMonitors",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*ebiten.MonitorType, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*ebiten.MonitorType)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("append-monitors: arg 1: block item: expected native of type *ebiten.MonitorType")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("append-monitors: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("append-monitors: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-monitors: arg 1: expected native of type []*ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-monitors: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-monitors: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendMonitors(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-ebiten-monitor-type")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"append-touch-i-ds": {
		Doc:   "ebiten.AppendTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("append-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("append-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("append-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("append-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := ebiten.AppendTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"blend-factor-default": {
		Doc:   "Get ebiten.BlendFactorDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDefault), "byte")
			return resObj
		},
	},
	"blend-factor-destination-alpha": {
		Doc:   "Get ebiten.BlendFactorDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-destination-color": {
		Doc:   "Get ebiten.BlendFactorDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorDestinationColor), "byte")
			return resObj
		},
	},
	"blend-factor-one": {
		Doc:   "Get ebiten.BlendFactorOne value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOne), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-alpha": {
		Doc:   "Get ebiten.BlendFactorOneMinusDestinationAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-destination-color": {
		Doc:   "Get ebiten.BlendFactorOneMinusDestinationColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusDestinationColor), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-source-alpha": {
		Doc:   "Get ebiten.BlendFactorOneMinusSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-one-minus-source-color": {
		Doc:   "Get ebiten.BlendFactorOneMinusSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorOneMinusSourceColor), "byte")
			return resObj
		},
	},
	"blend-factor-source-alpha": {
		Doc:   "Get ebiten.BlendFactorSourceAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"blend-factor-source-color": {
		Doc:   "Get ebiten.BlendFactorSourceColor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorSourceColor), "byte")
			return resObj
		},
	},
	"blend-factor-zero": {
		Doc:   "Get ebiten.BlendFactorZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendFactorZero), "byte")
			return resObj
		},
	},
	"blend-operation-add": {
		Doc:   "Get ebiten.BlendOperationAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationAdd), "byte")
			return resObj
		},
	},
	"blend-operation-max": {
		Doc:   "Get ebiten.BlendOperationMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMax), "byte")
			return resObj
		},
	},
	"blend-operation-min": {
		Doc:   "Get ebiten.BlendOperationMin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationMin), "byte")
			return resObj
		},
	},
	"blend-operation-reverse-subtract": {
		Doc:   "Get ebiten.BlendOperationReverseSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationReverseSubtract), "byte")
			return resObj
		},
	},
	"blend-operation-subtract": {
		Doc:   "Get ebiten.BlendOperationSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(ebiten.BlendOperationSubtract), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-destination-alpha!": {
		Doc:   "Set ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native")
					}
					self.BlendFactorDestinationAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-destination-alpha?": {
		Doc:   "Get ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-destination-rgb!": {
		Doc:   "Set ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native")
					}
					self.BlendFactorDestinationRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-destination-rgb?": {
		Doc:   "Get ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationRGB), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-source-alpha!": {
		Doc:   "Set ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-blend//blend-factor-source-alpha!: arg 2: expected native")
					}
					self.BlendFactorSourceAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-source-alpha?": {
		Doc:   "Get ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-source-alpha?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-source-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-factor-source-rgb!": {
		Doc:   "Set ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-blend//blend-factor-source-rgb!: arg 2: expected native")
					}
					self.BlendFactorSourceRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-factor-source-rgb?": {
		Doc:   "Get ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-factor-source-rgb?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-factor-source-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceRGB), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-operation-alpha!": {
		Doc:   "Set ebiten.Blend BlendOperationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-operation-alpha!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-operation-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-blend//blend-operation-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-blend//blend-operation-alpha!: arg 2: expected native")
					}
					self.BlendOperationAlpha = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-operation-alpha?": {
		Doc:   "Get ebiten.Blend BlendOperationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-operation-alpha?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-operation-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationAlpha), "byte")
			return resObj
		},
	},
	"ebiten-blend//blend-operation-rgb!": {
		Doc:   "Set ebiten.Blend BlendOperationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-operation-rgb!: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-operation-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-blend//blend-operation-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-blend//blend-operation-rgb!: arg 2: expected native")
					}
					self.BlendOperationRGB = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ebiten-blend//blend-operation-rgb?": {
		Doc:   "Get ebiten.Blend BlendOperationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-blend//blend-operation-rgb?: arg 1: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-blend//blend-operation-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationRGB), "byte")
			return resObj
		},
	},
	"color-scale-mode-premultiplied-alpha": {
		Doc:   "Get ebiten.ColorScaleModePremultipliedAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModePremultipliedAlpha)))
			return resObj
		},
	},
	"color-scale-mode-straight-alpha": {
		Doc:   "Get ebiten.ColorScaleModeStraightAlpha value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.ColorScaleModeStraightAlpha)))
			return resObj
		},
	},
	"composite-mode-clear": {
		Doc:   "Get ebiten.CompositeModeClear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeClear)))
			return resObj
		},
	},
	"composite-mode-copy": {
		Doc:   "Get ebiten.CompositeModeCopy value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCopy)))
			return resObj
		},
	},
	"composite-mode-custom": {
		Doc:   "Get ebiten.CompositeModeCustom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeCustom)))
			return resObj
		},
	},
	"composite-mode-destination": {
		Doc:   "Get ebiten.CompositeModeDestination value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestination)))
			return resObj
		},
	},
	"composite-mode-destination-atop": {
		Doc:   "Get ebiten.CompositeModeDestinationAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationAtop)))
			return resObj
		},
	},
	"composite-mode-destination-in": {
		Doc:   "Get ebiten.CompositeModeDestinationIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationIn)))
			return resObj
		},
	},
	"composite-mode-destination-out": {
		Doc:   "Get ebiten.CompositeModeDestinationOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOut)))
			return resObj
		},
	},
	"composite-mode-destination-over": {
		Doc:   "Get ebiten.CompositeModeDestinationOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeDestinationOver)))
			return resObj
		},
	},
	"composite-mode-lighter": {
		Doc:   "Get ebiten.CompositeModeLighter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeLighter)))
			return resObj
		},
	},
	"composite-mode-multiply": {
		Doc:   "Get ebiten.CompositeModeMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeMultiply)))
			return resObj
		},
	},
	"composite-mode-source-atop": {
		Doc:   "Get ebiten.CompositeModeSourceAtop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceAtop)))
			return resObj
		},
	},
	"composite-mode-source-in": {
		Doc:   "Get ebiten.CompositeModeSourceIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceIn)))
			return resObj
		},
	},
	"composite-mode-source-out": {
		Doc:   "Get ebiten.CompositeModeSourceOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOut)))
			return resObj
		},
	},
	"composite-mode-source-over": {
		Doc:   "Get ebiten.CompositeModeSourceOver value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeSourceOver)))
			return resObj
		},
	},
	"composite-mode-xor": {
		Doc:   "Get ebiten.CompositeModeXor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CompositeModeXor)))
			return resObj
		},
	},
	"current-fps": {
		Doc:   "ebiten.CurrentFPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentFPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"current-tps": {
		Doc:   "ebiten.CurrentTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.CurrentTPS()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"cursor-mode": {
		Doc:   "ebiten.CursorMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.CursorMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"cursor-mode-captured": {
		Doc:   "Get ebiten.CursorModeCaptured value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeCaptured)))
			return resObj
		},
	},
	"cursor-mode-hidden": {
		Doc:   "Get ebiten.CursorModeHidden value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeHidden)))
			return resObj
		},
	},
	"cursor-mode-visible": {
		Doc:   "Get ebiten.CursorModeVisible value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorModeVisible)))
			return resObj
		},
	},
	"cursor-position": {
		Doc:   "ebiten.CursorPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := ebiten.CursorPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"x": res0Obj,
				"y": res1Obj,
			})
		},
	},
	"cursor-shape": {
		Doc:   "ebiten.CursorShape",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.CursorShape()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"cursor-shape-crosshair": {
		Doc:   "Get ebiten.CursorShapeCrosshair value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeCrosshair)))
			return resObj
		},
	},
	"cursor-shape-default": {
		Doc:   "Get ebiten.CursorShapeDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeDefault)))
			return resObj
		},
	},
	"cursor-shape-ew-resize": {
		Doc:   "Get ebiten.CursorShapeEWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeEWResize)))
			return resObj
		},
	},
	"cursor-shape-move": {
		Doc:   "Get ebiten.CursorShapeMove value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeMove)))
			return resObj
		},
	},
	"cursor-shape-nesw-resize": {
		Doc:   "Get ebiten.CursorShapeNESWResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNESWResize)))
			return resObj
		},
	},
	"cursor-shape-not-allowed": {
		Doc:   "Get ebiten.CursorShapeNotAllowed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNotAllowed)))
			return resObj
		},
	},
	"cursor-shape-ns-resize": {
		Doc:   "Get ebiten.CursorShapeNSResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNSResize)))
			return resObj
		},
	},
	"cursor-shape-nwse-resize": {
		Doc:   "Get ebiten.CursorShapeNWSEResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeNWSEResize)))
			return resObj
		},
	},
	"cursor-shape-pointer": {
		Doc:   "Get ebiten.CursorShapePointer value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapePointer)))
			return resObj
		},
	},
	"cursor-shape-text": {
		Doc:   "Get ebiten.CursorShapeText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.CursorShapeText)))
			return resObj
		},
	},
	"ebiten-debug-info//graphics-library!": {
		Doc:   "Set ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-debug-info//graphics-library!: arg 1: expected native of type ebiten.DebugInfo")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-debug-info//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-debug-info//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ebiten-debug-info//graphics-library?": {
		Doc:   "Get ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-debug-info//graphics-library?: arg 1: expected native of type ebiten.DebugInfo")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-debug-info//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"device-scale-factor": {
		Doc:   "ebiten.DeviceScaleFactor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ebiten-draw-image-options//blend!": {
		Doc:   "Set ebiten.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//blend!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//blend?": {
		Doc:   "Get ebiten.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//blend?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ebiten-draw-image-options//color-m!": {
		Doc:   "Set ebiten.DrawImageOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//color-m!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//color-m?": {
		Doc:   "Get ebiten.DrawImageOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//color-m?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ebiten-draw-image-options//color-scale!": {
		Doc:   "Set ebiten.DrawImageOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//color-scale!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//color-scale?": {
		Doc:   "Get ebiten.DrawImageOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//color-scale?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"ebiten-draw-image-options//composite-mode!": {
		Doc:   "Set ebiten.DrawImageOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//composite-mode!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-image-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//composite-mode?": {
		Doc:   "Get ebiten.DrawImageOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//composite-mode?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ebiten-draw-image-options//filter!": {
		Doc:   "Set ebiten.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//filter!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//filter?": {
		Doc:   "Get ebiten.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//filter?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ebiten-draw-image-options//geo-m!": {
		Doc:   "Set ebiten.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//geo-m!: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-image-options//geo-m?": {
		Doc:   "Get ebiten.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-image-options//geo-m?: arg 1: expected native of type ebiten.DrawImageOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ebiten-draw-triangles-options//address!": {
		Doc:   "Set ebiten.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//address!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//address?": {
		Doc:   "Get ebiten.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//address?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//anti-alias!": {
		Doc:   "Set ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//anti-alias!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//anti-alias?": {
		Doc:   "Get ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//anti-alias?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//blend!": {
		Doc:   "Set ebiten.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//blend!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//blend?": {
		Doc:   "Get ebiten.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//blend?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ebiten-draw-triangles-options//color-m!": {
		Doc:   "Set ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//color-m!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//color-m?": {
		Doc:   "Get ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//color-m?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ebiten-draw-triangles-options//color-scale-mode!": {
		Doc:   "Set ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//color-scale-mode?": {
		Doc:   "Get ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//composite-mode!": {
		Doc:   "Set ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//composite-mode!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//composite-mode?": {
		Doc:   "Get ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//composite-mode?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//fill-rule!": {
		Doc:   "Set ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//fill-rule!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//fill-rule?": {
		Doc:   "Get ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//fill-rule?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ebiten-draw-triangles-options//filter!": {
		Doc:   "Set ebiten.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//filter!: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-options//filter?": {
		Doc:   "Get ebiten.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-options//filter?: arg 1: expected native of type ebiten.DrawTrianglesOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ebiten-draw-triangles-shader-options//anti-alias!": {
		Doc:   "Set ebiten.DrawTrianglesShaderOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//anti-alias!: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-shader-options//anti-alias?": {
		Doc:   "Get ebiten.DrawTrianglesShaderOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//anti-alias?: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ebiten-draw-triangles-shader-options//blend!": {
		Doc:   "Set ebiten.DrawTrianglesShaderOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//blend!: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-shader-options//blend?": {
		Doc:   "Get ebiten.DrawTrianglesShaderOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//blend?: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ebiten-draw-triangles-shader-options//composite-mode!": {
		Doc:   "Set ebiten.DrawTrianglesShaderOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//composite-mode!: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-shader-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-shader-options//composite-mode?": {
		Doc:   "Get ebiten.DrawTrianglesShaderOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//composite-mode?: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ebiten-draw-triangles-shader-options//fill-rule!": {
		Doc:   "Set ebiten.DrawTrianglesShaderOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//fill-rule!: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-shader-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-shader-options//fill-rule?": {
		Doc:   "Get ebiten.DrawTrianglesShaderOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//fill-rule?: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ebiten-draw-triangles-shader-options//images!": {
		Doc:   "Set ebiten.DrawTrianglesShaderOptions Images value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Images = make([]*ebiten.Image, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Images[i], ok = v.Value.(*ebiten.Image)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 2: block item: expected native of type *ebiten.Image")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Images[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Images, ok = v.Value.([]*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 2: expected native of type []*ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 2: expected integer to be 0 or nil")
				}
				self.Images = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//images!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-shader-options//images?": {
		Doc:   "Get ebiten.DrawTrianglesShaderOptions Images value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//images?: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//images?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Images))
				for i, it := range self.Images {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-ebiten-image")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ebiten-draw-triangles-shader-options//uniforms!": {
		Doc:   "Set ebiten.DrawTrianglesShaderOptions Uniforms value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected block to have length of multiple of 2")
				}
				self.Uniforms = make(map[string]any, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: map key: expected string")
					}
					var mapV any
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native")
					}
					self.Uniforms[mapK] = mapV
				}
			case env.Dict:
				self.Uniforms = make(map[string]any, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV any
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native")
					}
					self.Uniforms[mapK] = mapV
				}
			case env.Native:
				var ok bool
				self.Uniforms, ok = v.Value.(map[string]any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected native of type map[string]any")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected integer to be 0 or nil")
				}
				self.Uniforms = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected native, block, dict or nil")
			}
			return arg0
		},
	},
	"ebiten-draw-triangles-shader-options//uniforms?": {
		Doc:   "Get ebiten.DrawTrianglesShaderOptions Uniforms value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-draw-triangles-shader-options//uniforms?: arg 1: expected native of type ebiten.DrawTrianglesShaderOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-draw-triangles-shader-options//uniforms?: arg 1: expected native")
			}
			var resObj env.Object
			{
				data := make(map[string]any, len(self.Uniforms))
				for mKey, mVal := range self.Uniforms {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "any")
					data[mKey] = dVal
				}
				resObj = *env.NewDict(data)
			}
			return resObj
		},
	},
	"dropped-files": {
		Doc:   "ebiten.DroppedFiles",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.DroppedFiles()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fs-fs")
				}
			}
			return res0Obj
		},
	},
	"even-odd": {
		Doc:   "Get ebiten.EvenOdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.EvenOdd)))
			return resObj
		},
	},
	"fill-all": {
		Doc:   "Get ebiten.FillAll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FillAll)))
			return resObj
		},
	},
	"filter-linear": {
		Doc:   "Get ebiten.FilterLinear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterLinear)))
			return resObj
		},
	},
	"filter-nearest": {
		Doc:   "Get ebiten.FilterNearest value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FilterNearest)))
			return resObj
		},
	},
	"ebiten-final-screen-drawer//draw-final-screen": {
		Doc:   "ebiten.FinalScreenDrawer.DrawFinalScreen",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreenDrawer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreenDrawer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected native of type ebiten.FinalScreenDrawer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 1: expected native")
			}
			var arg1Val ebiten.FinalScreen
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 2: expected native")
			}
			var arg2Val *ebiten.Image
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 3: expected native")
			}
			var arg3Val ebiten.GeoM
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen-drawer//draw-final-screen: arg 4: expected native")
			}
			arg0Val.DrawFinalScreen(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ebiten-final-screen//bounds": {
		Doc:   "ebiten.FinalScreen.Bounds",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//bounds: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//bounds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//bounds: arg 1: expected native")
			}
			res0 := arg0Val.Bounds()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-rectangle")
			return res0Obj
		},
	},
	"ebiten-final-screen//clear": {
		Doc:   "ebiten.FinalScreen.Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//clear: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//clear: arg 1: expected native")
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"ebiten-final-screen//draw-image": {
		Doc:   "ebiten.FinalScreen.DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-image: arg 2: expected native")
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 3: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-image: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-image: arg 3: expected native")
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-rect-shader": {
		Doc:   "ebiten.FinalScreen.DrawRectShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 3: expected integer")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawRectShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawRectShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected native of type *ebiten.DrawRectShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-rect-shader: arg 5: expected native")
			}
			arg0Val.DrawRectShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-triangles": {
		Doc:   "ebiten.FinalScreen.DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-final-screen//draw-triangles: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles: arg 5: expected native")
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//draw-triangles-shader": {
		Doc:   "ebiten.FinalScreen.DrawTrianglesShader",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Shader
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesShaderOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//draw-triangles-shader: arg 5: expected native")
			}
			arg0Val.DrawTrianglesShader(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ebiten-final-screen//fill": {
		Doc:   "ebiten.FinalScreen.Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//fill: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//fill: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//fill: arg 2: expected native")
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"ebiten-final-screen//private": {
		Doc:   "ebiten.FinalScreen.private",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FinalScreen
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.FinalScreen)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//private: arg 1: expected native of type ebiten.FinalScreen")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-final-screen//private: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-final-screen//private: arg 1: expected native")
			}
			arg0Val.private()
			return arg0
		},
	},
	"fps-mode": {
		Doc:   "ebiten.FPSMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.FPSMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"fps-mode-vsync-off-maximum": {
		Doc:   "Get ebiten.FPSModeVsyncOffMaximum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOffMaximum)))
			return resObj
		},
	},
	"fps-mode-vsync-off-minimum": {
		Doc:   "Get ebiten.FPSModeVsyncOffMinimum value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOffMinimum)))
			return resObj
		},
	},
	"fps-mode-vsync-on": {
		Doc:   "Get ebiten.FPSModeVsyncOn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.FPSModeVsyncOn)))
			return resObj
		},
	},
	"ebiten-game//draw": {
		Doc:   "ebiten.Game.Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ebiten-game//layout": {
		Doc:   "ebiten.Game.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//layout: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"screen-width":  res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"ebiten-game//update": {
		Doc:   "ebiten.Game.Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//update: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-game//update: arg 1: expected native")
			}
			res0 := arg0Val.Update()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"gamepad-axis": {
		Doc:   "ebiten.GamepadAxis",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxis(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-count": {
		Doc:   "ebiten.GamepadAxisCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-count: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadAxisCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-num": {
		Doc:   "ebiten.GamepadAxisNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-num: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadAxisNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-axis-value": {
		Doc:   "ebiten.GamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadAxisType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadAxisType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadAxisType)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-axis-value: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadAxisType(u)
				}
			}
			res0 := ebiten.GamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"gamepad-button-0": {
		Doc:   "Get ebiten.GamepadButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton0)))
			return resObj
		},
	},
	"gamepad-button-1": {
		Doc:   "Get ebiten.GamepadButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton1)))
			return resObj
		},
	},
	"gamepad-button-10": {
		Doc:   "Get ebiten.GamepadButton10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton10)))
			return resObj
		},
	},
	"gamepad-button-11": {
		Doc:   "Get ebiten.GamepadButton11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton11)))
			return resObj
		},
	},
	"gamepad-button-12": {
		Doc:   "Get ebiten.GamepadButton12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton12)))
			return resObj
		},
	},
	"gamepad-button-13": {
		Doc:   "Get ebiten.GamepadButton13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton13)))
			return resObj
		},
	},
	"gamepad-button-14": {
		Doc:   "Get ebiten.GamepadButton14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton14)))
			return resObj
		},
	},
	"gamepad-button-15": {
		Doc:   "Get ebiten.GamepadButton15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton15)))
			return resObj
		},
	},
	"gamepad-button-16": {
		Doc:   "Get ebiten.GamepadButton16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton16)))
			return resObj
		},
	},
	"gamepad-button-17": {
		Doc:   "Get ebiten.GamepadButton17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton17)))
			return resObj
		},
	},
	"gamepad-button-18": {
		Doc:   "Get ebiten.GamepadButton18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton18)))
			return resObj
		},
	},
	"gamepad-button-19": {
		Doc:   "Get ebiten.GamepadButton19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton19)))
			return resObj
		},
	},
	"gamepad-button-2": {
		Doc:   "Get ebiten.GamepadButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton2)))
			return resObj
		},
	},
	"gamepad-button-20": {
		Doc:   "Get ebiten.GamepadButton20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton20)))
			return resObj
		},
	},
	"gamepad-button-21": {
		Doc:   "Get ebiten.GamepadButton21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton21)))
			return resObj
		},
	},
	"gamepad-button-22": {
		Doc:   "Get ebiten.GamepadButton22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton22)))
			return resObj
		},
	},
	"gamepad-button-23": {
		Doc:   "Get ebiten.GamepadButton23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton23)))
			return resObj
		},
	},
	"gamepad-button-24": {
		Doc:   "Get ebiten.GamepadButton24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton24)))
			return resObj
		},
	},
	"gamepad-button-25": {
		Doc:   "Get ebiten.GamepadButton25 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton25)))
			return resObj
		},
	},
	"gamepad-button-26": {
		Doc:   "Get ebiten.GamepadButton26 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton26)))
			return resObj
		},
	},
	"gamepad-button-27": {
		Doc:   "Get ebiten.GamepadButton27 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton27)))
			return resObj
		},
	},
	"gamepad-button-28": {
		Doc:   "Get ebiten.GamepadButton28 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton28)))
			return resObj
		},
	},
	"gamepad-button-29": {
		Doc:   "Get ebiten.GamepadButton29 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton29)))
			return resObj
		},
	},
	"gamepad-button-3": {
		Doc:   "Get ebiten.GamepadButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton3)))
			return resObj
		},
	},
	"gamepad-button-30": {
		Doc:   "Get ebiten.GamepadButton30 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton30)))
			return resObj
		},
	},
	"gamepad-button-31": {
		Doc:   "Get ebiten.GamepadButton31 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton31)))
			return resObj
		},
	},
	"gamepad-button-4": {
		Doc:   "Get ebiten.GamepadButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton4)))
			return resObj
		},
	},
	"gamepad-button-5": {
		Doc:   "Get ebiten.GamepadButton5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton5)))
			return resObj
		},
	},
	"gamepad-button-6": {
		Doc:   "Get ebiten.GamepadButton6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton6)))
			return resObj
		},
	},
	"gamepad-button-7": {
		Doc:   "Get ebiten.GamepadButton7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton7)))
			return resObj
		},
	},
	"gamepad-button-8": {
		Doc:   "Get ebiten.GamepadButton8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton8)))
			return resObj
		},
	},
	"gamepad-button-9": {
		Doc:   "Get ebiten.GamepadButton9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButton9)))
			return resObj
		},
	},
	"gamepad-button-count": {
		Doc:   "ebiten.GamepadButtonCount",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-button-count: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadButtonCount(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-button-max": {
		Doc:   "Get ebiten.GamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GamepadButtonMax)))
			return resObj
		},
	},
	"gamepad-button-num": {
		Doc:   "ebiten.GamepadButtonNum",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-button-num: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadButtonNum(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"gamepad-i-ds": {
		Doc:   "ebiten.GamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.GamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"gamepad-name": {
		Doc:   "ebiten.GamepadName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-name: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"gamepad-sdlid": {
		Doc:   "ebiten.GamepadSDLID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("gamepad-sdlid: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.GamepadSDLID(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"graphics-library-auto": {
		Doc:   "Get ebiten.GraphicsLibraryAuto value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryAuto)))
			return resObj
		},
	},
	"graphics-library-direct-x": {
		Doc:   "Get ebiten.GraphicsLibraryDirectX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryDirectX)))
			return resObj
		},
	},
	"graphics-library-metal": {
		Doc:   "Get ebiten.GraphicsLibraryMetal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryMetal)))
			return resObj
		},
	},
	"graphics-library-open-gl": {
		Doc:   "Get ebiten.GraphicsLibraryOpenGL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryOpenGL)))
			return resObj
		},
	},
	"graphics-library-play-station-5": {
		Doc:   "Get ebiten.GraphicsLibraryPlayStation5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryPlayStation5)))
			return resObj
		},
	},
	"graphics-library-unknown": {
		Doc:   "Get ebiten.GraphicsLibraryUnknown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.GraphicsLibraryUnknown)))
			return resObj
		},
	},
	"ebiten-graphics-library//string": {
		Doc:   "ebiten.GraphicsLibrary.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GraphicsLibrary
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-graphics-library//string: arg 1: expected integer")
					}
					arg0Val = ebiten.GraphicsLibrary(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"input-chars": {
		Doc:   "ebiten.InputChars",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.InputChars()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"is-focused": {
		Doc:   "ebiten.IsFocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsFocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-fullscreen": {
		Doc:   "ebiten.IsFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-gamepad-button-pressed": {
		Doc:   "ebiten.IsGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-gamepad-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-gamepad-button-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := ebiten.IsGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-key-pressed": {
		Doc:   "ebiten.IsKeyPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-key-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.IsKeyPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-mouse-button-pressed": {
		Doc:   "ebiten.IsMouseButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-mouse-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := ebiten.IsMouseButtonPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-runnable-on-unfocused": {
		Doc:   "ebiten.IsRunnableOnUnfocused",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsRunnableOnUnfocused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-cleared-every-frame": {
		Doc:   "ebiten.IsScreenClearedEveryFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenClearedEveryFrame()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-filter-enabled": {
		Doc:   "ebiten.IsScreenFilterEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenFilterEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-screen-transparent": {
		Doc:   "ebiten.IsScreenTransparent",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsScreenTransparent()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-axis-available": {
		Doc:   "ebiten.IsStandardGamepadAxisAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-axis-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadAxis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadAxis
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadAxis)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-axis-available: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadAxis(u)
				}
			}
			res0 := ebiten.IsStandardGamepadAxisAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-available": {
		Doc:   "ebiten.IsStandardGamepadButtonAvailable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-available: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.IsStandardGamepadButtonAvailable(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-button-pressed": {
		Doc:   "ebiten.IsStandardGamepadButtonPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-button-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.IsStandardGamepadButtonPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-standard-gamepad-layout-available": {
		Doc:   "ebiten.IsStandardGamepadLayoutAvailable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-standard-gamepad-layout-available: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := ebiten.IsStandardGamepadLayoutAvailable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-vsync-enabled": {
		Doc:   "ebiten.IsVsyncEnabled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsVsyncEnabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-being-closed": {
		Doc:   "ebiten.IsWindowBeingClosed",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowBeingClosed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-closing-handled": {
		Doc:   "ebiten.IsWindowClosingHandled",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowClosingHandled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-decorated": {
		Doc:   "ebiten.IsWindowDecorated",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowDecorated()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-floating": {
		Doc:   "ebiten.IsWindowFloating",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowFloating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-maximized": {
		Doc:   "ebiten.IsWindowMaximized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMaximized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-minimized": {
		Doc:   "ebiten.IsWindowMinimized",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMinimized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-mouse-passthrough": {
		Doc:   "ebiten.IsWindowMousePassthrough",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowMousePassthrough()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-window-resizable": {
		Doc:   "ebiten.IsWindowResizable",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.IsWindowResizable()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"key-0": {
		Doc:   "Get ebiten.Key0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key0)))
			return resObj
		},
	},
	"key-1": {
		Doc:   "Get ebiten.Key1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key1)))
			return resObj
		},
	},
	"key-2": {
		Doc:   "Get ebiten.Key2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key2)))
			return resObj
		},
	},
	"key-3": {
		Doc:   "Get ebiten.Key3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key3)))
			return resObj
		},
	},
	"key-4": {
		Doc:   "Get ebiten.Key4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key4)))
			return resObj
		},
	},
	"key-5": {
		Doc:   "Get ebiten.Key5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key5)))
			return resObj
		},
	},
	"key-6": {
		Doc:   "Get ebiten.Key6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key6)))
			return resObj
		},
	},
	"key-7": {
		Doc:   "Get ebiten.Key7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key7)))
			return resObj
		},
	},
	"key-8": {
		Doc:   "Get ebiten.Key8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key8)))
			return resObj
		},
	},
	"key-9": {
		Doc:   "Get ebiten.Key9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.Key9)))
			return resObj
		},
	},
	"key-a": {
		Doc:   "Get ebiten.KeyA value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyA)))
			return resObj
		},
	},
	"key-alt": {
		Doc:   "Get ebiten.KeyAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAlt)))
			return resObj
		},
	},
	"key-alt-left": {
		Doc:   "Get ebiten.KeyAltLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltLeft)))
			return resObj
		},
	},
	"key-alt-right": {
		Doc:   "Get ebiten.KeyAltRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyAltRight)))
			return resObj
		},
	},
	"key-apostrophe": {
		Doc:   "Get ebiten.KeyApostrophe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyApostrophe)))
			return resObj
		},
	},
	"key-arrow-down": {
		Doc:   "Get ebiten.KeyArrowDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowDown)))
			return resObj
		},
	},
	"key-arrow-left": {
		Doc:   "Get ebiten.KeyArrowLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowLeft)))
			return resObj
		},
	},
	"key-arrow-right": {
		Doc:   "Get ebiten.KeyArrowRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowRight)))
			return resObj
		},
	},
	"key-arrow-up": {
		Doc:   "Get ebiten.KeyArrowUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyArrowUp)))
			return resObj
		},
	},
	"key-b": {
		Doc:   "Get ebiten.KeyB value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyB)))
			return resObj
		},
	},
	"key-backquote": {
		Doc:   "Get ebiten.KeyBackquote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackquote)))
			return resObj
		},
	},
	"key-backslash": {
		Doc:   "Get ebiten.KeyBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackslash)))
			return resObj
		},
	},
	"key-backspace": {
		Doc:   "Get ebiten.KeyBackspace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBackspace)))
			return resObj
		},
	},
	"key-bracket-left": {
		Doc:   "Get ebiten.KeyBracketLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketLeft)))
			return resObj
		},
	},
	"key-bracket-right": {
		Doc:   "Get ebiten.KeyBracketRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyBracketRight)))
			return resObj
		},
	},
	"key-c": {
		Doc:   "Get ebiten.KeyC value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyC)))
			return resObj
		},
	},
	"key-caps-lock": {
		Doc:   "Get ebiten.KeyCapsLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyCapsLock)))
			return resObj
		},
	},
	"key-comma": {
		Doc:   "Get ebiten.KeyComma value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyComma)))
			return resObj
		},
	},
	"key-context-menu": {
		Doc:   "Get ebiten.KeyContextMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyContextMenu)))
			return resObj
		},
	},
	"key-control": {
		Doc:   "Get ebiten.KeyControl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControl)))
			return resObj
		},
	},
	"key-control-left": {
		Doc:   "Get ebiten.KeyControlLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlLeft)))
			return resObj
		},
	},
	"key-control-right": {
		Doc:   "Get ebiten.KeyControlRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyControlRight)))
			return resObj
		},
	},
	"key-d": {
		Doc:   "Get ebiten.KeyD value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyD)))
			return resObj
		},
	},
	"key-delete": {
		Doc:   "Get ebiten.KeyDelete value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDelete)))
			return resObj
		},
	},
	"key-digit-0": {
		Doc:   "Get ebiten.KeyDigit0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit0)))
			return resObj
		},
	},
	"key-digit-1": {
		Doc:   "Get ebiten.KeyDigit1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit1)))
			return resObj
		},
	},
	"key-digit-2": {
		Doc:   "Get ebiten.KeyDigit2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit2)))
			return resObj
		},
	},
	"key-digit-3": {
		Doc:   "Get ebiten.KeyDigit3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit3)))
			return resObj
		},
	},
	"key-digit-4": {
		Doc:   "Get ebiten.KeyDigit4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit4)))
			return resObj
		},
	},
	"key-digit-5": {
		Doc:   "Get ebiten.KeyDigit5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit5)))
			return resObj
		},
	},
	"key-digit-6": {
		Doc:   "Get ebiten.KeyDigit6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit6)))
			return resObj
		},
	},
	"key-digit-7": {
		Doc:   "Get ebiten.KeyDigit7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit7)))
			return resObj
		},
	},
	"key-digit-8": {
		Doc:   "Get ebiten.KeyDigit8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit8)))
			return resObj
		},
	},
	"key-digit-9": {
		Doc:   "Get ebiten.KeyDigit9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDigit9)))
			return resObj
		},
	},
	"key-down": {
		Doc:   "Get ebiten.KeyDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyDown)))
			return resObj
		},
	},
	"key-e": {
		Doc:   "Get ebiten.KeyE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyE)))
			return resObj
		},
	},
	"key-end": {
		Doc:   "Get ebiten.KeyEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnd)))
			return resObj
		},
	},
	"key-enter": {
		Doc:   "Get ebiten.KeyEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEnter)))
			return resObj
		},
	},
	"key-equal": {
		Doc:   "Get ebiten.KeyEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEqual)))
			return resObj
		},
	},
	"key-escape": {
		Doc:   "Get ebiten.KeyEscape value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyEscape)))
			return resObj
		},
	},
	"key-f": {
		Doc:   "Get ebiten.KeyF value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF)))
			return resObj
		},
	},
	"key-f-1": {
		Doc:   "Get ebiten.KeyF1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF1)))
			return resObj
		},
	},
	"key-f-10": {
		Doc:   "Get ebiten.KeyF10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF10)))
			return resObj
		},
	},
	"key-f-11": {
		Doc:   "Get ebiten.KeyF11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF11)))
			return resObj
		},
	},
	"key-f-12": {
		Doc:   "Get ebiten.KeyF12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF12)))
			return resObj
		},
	},
	"key-f-13": {
		Doc:   "Get ebiten.KeyF13 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF13)))
			return resObj
		},
	},
	"key-f-14": {
		Doc:   "Get ebiten.KeyF14 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF14)))
			return resObj
		},
	},
	"key-f-15": {
		Doc:   "Get ebiten.KeyF15 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF15)))
			return resObj
		},
	},
	"key-f-16": {
		Doc:   "Get ebiten.KeyF16 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF16)))
			return resObj
		},
	},
	"key-f-17": {
		Doc:   "Get ebiten.KeyF17 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF17)))
			return resObj
		},
	},
	"key-f-18": {
		Doc:   "Get ebiten.KeyF18 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF18)))
			return resObj
		},
	},
	"key-f-19": {
		Doc:   "Get ebiten.KeyF19 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF19)))
			return resObj
		},
	},
	"key-f-2": {
		Doc:   "Get ebiten.KeyF2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF2)))
			return resObj
		},
	},
	"key-f-20": {
		Doc:   "Get ebiten.KeyF20 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF20)))
			return resObj
		},
	},
	"key-f-21": {
		Doc:   "Get ebiten.KeyF21 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF21)))
			return resObj
		},
	},
	"key-f-22": {
		Doc:   "Get ebiten.KeyF22 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF22)))
			return resObj
		},
	},
	"key-f-23": {
		Doc:   "Get ebiten.KeyF23 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF23)))
			return resObj
		},
	},
	"key-f-24": {
		Doc:   "Get ebiten.KeyF24 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF24)))
			return resObj
		},
	},
	"key-f-3": {
		Doc:   "Get ebiten.KeyF3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF3)))
			return resObj
		},
	},
	"key-f-4": {
		Doc:   "Get ebiten.KeyF4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF4)))
			return resObj
		},
	},
	"key-f-5": {
		Doc:   "Get ebiten.KeyF5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF5)))
			return resObj
		},
	},
	"key-f-6": {
		Doc:   "Get ebiten.KeyF6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF6)))
			return resObj
		},
	},
	"key-f-7": {
		Doc:   "Get ebiten.KeyF7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF7)))
			return resObj
		},
	},
	"key-f-8": {
		Doc:   "Get ebiten.KeyF8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF8)))
			return resObj
		},
	},
	"key-f-9": {
		Doc:   "Get ebiten.KeyF9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyF9)))
			return resObj
		},
	},
	"key-g": {
		Doc:   "Get ebiten.KeyG value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyG)))
			return resObj
		},
	},
	"key-grave-accent": {
		Doc:   "Get ebiten.KeyGraveAccent value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyGraveAccent)))
			return resObj
		},
	},
	"key-h": {
		Doc:   "Get ebiten.KeyH value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyH)))
			return resObj
		},
	},
	"key-home": {
		Doc:   "Get ebiten.KeyHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyHome)))
			return resObj
		},
	},
	"key-i": {
		Doc:   "Get ebiten.KeyI value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyI)))
			return resObj
		},
	},
	"key-insert": {
		Doc:   "Get ebiten.KeyInsert value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyInsert)))
			return resObj
		},
	},
	"key-intl-backslash": {
		Doc:   "Get ebiten.KeyIntlBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyIntlBackslash)))
			return resObj
		},
	},
	"key-j": {
		Doc:   "Get ebiten.KeyJ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyJ)))
			return resObj
		},
	},
	"key-k": {
		Doc:   "Get ebiten.KeyK value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyK)))
			return resObj
		},
	},
	"key-kp-0": {
		Doc:   "Get ebiten.KeyKP0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP0)))
			return resObj
		},
	},
	"key-kp-1": {
		Doc:   "Get ebiten.KeyKP1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP1)))
			return resObj
		},
	},
	"key-kp-2": {
		Doc:   "Get ebiten.KeyKP2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP2)))
			return resObj
		},
	},
	"key-kp-3": {
		Doc:   "Get ebiten.KeyKP3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP3)))
			return resObj
		},
	},
	"key-kp-4": {
		Doc:   "Get ebiten.KeyKP4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP4)))
			return resObj
		},
	},
	"key-kp-5": {
		Doc:   "Get ebiten.KeyKP5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP5)))
			return resObj
		},
	},
	"key-kp-6": {
		Doc:   "Get ebiten.KeyKP6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP6)))
			return resObj
		},
	},
	"key-kp-7": {
		Doc:   "Get ebiten.KeyKP7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP7)))
			return resObj
		},
	},
	"key-kp-8": {
		Doc:   "Get ebiten.KeyKP8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP8)))
			return resObj
		},
	},
	"key-kp-9": {
		Doc:   "Get ebiten.KeyKP9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKP9)))
			return resObj
		},
	},
	"key-kp-add": {
		Doc:   "Get ebiten.KeyKPAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPAdd)))
			return resObj
		},
	},
	"key-kp-decimal": {
		Doc:   "Get ebiten.KeyKPDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDecimal)))
			return resObj
		},
	},
	"key-kp-divide": {
		Doc:   "Get ebiten.KeyKPDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPDivide)))
			return resObj
		},
	},
	"key-kp-enter": {
		Doc:   "Get ebiten.KeyKPEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEnter)))
			return resObj
		},
	},
	"key-kp-equal": {
		Doc:   "Get ebiten.KeyKPEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPEqual)))
			return resObj
		},
	},
	"key-kp-multiply": {
		Doc:   "Get ebiten.KeyKPMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPMultiply)))
			return resObj
		},
	},
	"key-kp-subtract": {
		Doc:   "Get ebiten.KeyKPSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyKPSubtract)))
			return resObj
		},
	},
	"key-l": {
		Doc:   "Get ebiten.KeyL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyL)))
			return resObj
		},
	},
	"key-left": {
		Doc:   "Get ebiten.KeyLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeft)))
			return resObj
		},
	},
	"key-left-bracket": {
		Doc:   "Get ebiten.KeyLeftBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyLeftBracket)))
			return resObj
		},
	},
	"key-m": {
		Doc:   "Get ebiten.KeyM value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyM)))
			return resObj
		},
	},
	"key-max": {
		Doc:   "Get ebiten.KeyMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMax)))
			return resObj
		},
	},
	"key-menu": {
		Doc:   "Get ebiten.KeyMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMenu)))
			return resObj
		},
	},
	"key-meta": {
		Doc:   "Get ebiten.KeyMeta value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMeta)))
			return resObj
		},
	},
	"key-meta-left": {
		Doc:   "Get ebiten.KeyMetaLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaLeft)))
			return resObj
		},
	},
	"key-meta-right": {
		Doc:   "Get ebiten.KeyMetaRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMetaRight)))
			return resObj
		},
	},
	"key-minus": {
		Doc:   "Get ebiten.KeyMinus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyMinus)))
			return resObj
		},
	},
	"key-n": {
		Doc:   "Get ebiten.KeyN value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyN)))
			return resObj
		},
	},
	"key-name": {
		Doc:   "ebiten.KeyName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("key-name: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := ebiten.KeyName(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"key-num-lock": {
		Doc:   "Get ebiten.KeyNumLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumLock)))
			return resObj
		},
	},
	"key-numpad-0": {
		Doc:   "Get ebiten.KeyNumpad0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad0)))
			return resObj
		},
	},
	"key-numpad-1": {
		Doc:   "Get ebiten.KeyNumpad1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad1)))
			return resObj
		},
	},
	"key-numpad-2": {
		Doc:   "Get ebiten.KeyNumpad2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad2)))
			return resObj
		},
	},
	"key-numpad-3": {
		Doc:   "Get ebiten.KeyNumpad3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad3)))
			return resObj
		},
	},
	"key-numpad-4": {
		Doc:   "Get ebiten.KeyNumpad4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad4)))
			return resObj
		},
	},
	"key-numpad-5": {
		Doc:   "Get ebiten.KeyNumpad5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad5)))
			return resObj
		},
	},
	"key-numpad-6": {
		Doc:   "Get ebiten.KeyNumpad6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad6)))
			return resObj
		},
	},
	"key-numpad-7": {
		Doc:   "Get ebiten.KeyNumpad7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad7)))
			return resObj
		},
	},
	"key-numpad-8": {
		Doc:   "Get ebiten.KeyNumpad8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad8)))
			return resObj
		},
	},
	"key-numpad-9": {
		Doc:   "Get ebiten.KeyNumpad9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpad9)))
			return resObj
		},
	},
	"key-numpad-add": {
		Doc:   "Get ebiten.KeyNumpadAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadAdd)))
			return resObj
		},
	},
	"key-numpad-decimal": {
		Doc:   "Get ebiten.KeyNumpadDecimal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDecimal)))
			return resObj
		},
	},
	"key-numpad-divide": {
		Doc:   "Get ebiten.KeyNumpadDivide value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadDivide)))
			return resObj
		},
	},
	"key-numpad-enter": {
		Doc:   "Get ebiten.KeyNumpadEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEnter)))
			return resObj
		},
	},
	"key-numpad-equal": {
		Doc:   "Get ebiten.KeyNumpadEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadEqual)))
			return resObj
		},
	},
	"key-numpad-multiply": {
		Doc:   "Get ebiten.KeyNumpadMultiply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadMultiply)))
			return resObj
		},
	},
	"key-numpad-subtract": {
		Doc:   "Get ebiten.KeyNumpadSubtract value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyNumpadSubtract)))
			return resObj
		},
	},
	"key-o": {
		Doc:   "Get ebiten.KeyO value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyO)))
			return resObj
		},
	},
	"key-p": {
		Doc:   "Get ebiten.KeyP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyP)))
			return resObj
		},
	},
	"key-page-down": {
		Doc:   "Get ebiten.KeyPageDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageDown)))
			return resObj
		},
	},
	"key-page-up": {
		Doc:   "Get ebiten.KeyPageUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPageUp)))
			return resObj
		},
	},
	"key-pause": {
		Doc:   "Get ebiten.KeyPause value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPause)))
			return resObj
		},
	},
	"key-period": {
		Doc:   "Get ebiten.KeyPeriod value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPeriod)))
			return resObj
		},
	},
	"key-print-screen": {
		Doc:   "Get ebiten.KeyPrintScreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyPrintScreen)))
			return resObj
		},
	},
	"key-q": {
		Doc:   "Get ebiten.KeyQ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQ)))
			return resObj
		},
	},
	"key-quote": {
		Doc:   "Get ebiten.KeyQuote value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyQuote)))
			return resObj
		},
	},
	"key-r": {
		Doc:   "Get ebiten.KeyR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyR)))
			return resObj
		},
	},
	"key-right": {
		Doc:   "Get ebiten.KeyRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRight)))
			return resObj
		},
	},
	"key-right-bracket": {
		Doc:   "Get ebiten.KeyRightBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyRightBracket)))
			return resObj
		},
	},
	"key-s": {
		Doc:   "Get ebiten.KeyS value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyS)))
			return resObj
		},
	},
	"key-scroll-lock": {
		Doc:   "Get ebiten.KeyScrollLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyScrollLock)))
			return resObj
		},
	},
	"key-semicolon": {
		Doc:   "Get ebiten.KeySemicolon value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySemicolon)))
			return resObj
		},
	},
	"key-shift": {
		Doc:   "Get ebiten.KeyShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShift)))
			return resObj
		},
	},
	"key-shift-left": {
		Doc:   "Get ebiten.KeyShiftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftLeft)))
			return resObj
		},
	},
	"key-shift-right": {
		Doc:   "Get ebiten.KeyShiftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyShiftRight)))
			return resObj
		},
	},
	"key-slash": {
		Doc:   "Get ebiten.KeySlash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySlash)))
			return resObj
		},
	},
	"key-space": {
		Doc:   "Get ebiten.KeySpace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeySpace)))
			return resObj
		},
	},
	"key-t": {
		Doc:   "Get ebiten.KeyT value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyT)))
			return resObj
		},
	},
	"key-tab": {
		Doc:   "Get ebiten.KeyTab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyTab)))
			return resObj
		},
	},
	"key-u": {
		Doc:   "Get ebiten.KeyU value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyU)))
			return resObj
		},
	},
	"key-up": {
		Doc:   "Get ebiten.KeyUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyUp)))
			return resObj
		},
	},
	"key-v": {
		Doc:   "Get ebiten.KeyV value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyV)))
			return resObj
		},
	},
	"key-w": {
		Doc:   "Get ebiten.KeyW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyW)))
			return resObj
		},
	},
	"key-x": {
		Doc:   "Get ebiten.KeyX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyX)))
			return resObj
		},
	},
	"key-y": {
		Doc:   "Get ebiten.KeyY value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyY)))
			return resObj
		},
	},
	"key-z": {
		Doc:   "Get ebiten.KeyZ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.KeyZ)))
			return resObj
		},
	},
	"ebiten-key//marshal-text": {
		Doc:   "ebiten.Key.MarshalText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-key//marshal-text: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, res1 := arg0Val.MarshalText()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ebiten-key//string": {
		Doc:   "ebiten.Key.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-key//string: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ebiten-layout-fer//layout-f": {
		Doc:   "ebiten.LayoutFer.LayoutF",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.LayoutFer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.LayoutFer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected native of type ebiten.LayoutFer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-layout-fer//layout-f: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-layout-fer//layout-f: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-layout-fer//layout-f: arg 3: expected decimal")
			}
			res0, res1 := arg0Val.LayoutF(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"screen-width":  res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"max-tps": {
		Doc:   "ebiten.MaxTPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.MaxTPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"maximize-window": {
		Doc:   "ebiten.MaximizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			ebiten.MaximizeWindow()
			return nil
		},
	},
	"minimize-window": {
		Doc:   "ebiten.MinimizeWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			ebiten.MinimizeWindow()
			return nil
		},
	},
	"monitor": {
		Doc:   "ebiten.Monitor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.Monitor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-monitor-type")
			return res0Obj
		},
	},
	"mouse-button-0": {
		Doc:   "Get ebiten.MouseButton0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton0)))
			return resObj
		},
	},
	"mouse-button-1": {
		Doc:   "Get ebiten.MouseButton1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton1)))
			return resObj
		},
	},
	"mouse-button-2": {
		Doc:   "Get ebiten.MouseButton2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton2)))
			return resObj
		},
	},
	"mouse-button-3": {
		Doc:   "Get ebiten.MouseButton3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton3)))
			return resObj
		},
	},
	"mouse-button-4": {
		Doc:   "Get ebiten.MouseButton4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButton4)))
			return resObj
		},
	},
	"mouse-button-left": {
		Doc:   "Get ebiten.MouseButtonLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonLeft)))
			return resObj
		},
	},
	"mouse-button-max": {
		Doc:   "Get ebiten.MouseButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonMax)))
			return resObj
		},
	},
	"mouse-button-middle": {
		Doc:   "Get ebiten.MouseButtonMiddle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonMiddle)))
			return resObj
		},
	},
	"mouse-button-right": {
		Doc:   "Get ebiten.MouseButtonRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.MouseButtonRight)))
			return resObj
		},
	},
	"shader": {
		Doc:   "ebiten.NewShader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("shader: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("shader: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("shader: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("shader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("shader: arg 1: expected block, native or nil")
			}
			res0, res1 := ebiten.NewShader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-shader")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"non-zero": {
		Doc:   "Get ebiten.NonZero value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.NonZero)))
			return resObj
		},
	},
	"read-debug-info": {
		Doc:   "ebiten.ReadDebugInfo",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("read-debug-info: arg 1: expected native of type *ebiten.DebugInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("read-debug-info: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("read-debug-info: arg 1: expected native")
			}
			ebiten.ReadDebugInfo(arg0Val)
			return nil
		},
	},
	"restore-window": {
		Doc:   "ebiten.RestoreWindow",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			ebiten.RestoreWindow()
			return nil
		},
	},
	"run-game": {
		Doc:   "ebiten.RunGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game: arg 1: expected native")
			}
			res0 := ebiten.RunGame(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ebiten-run-game-options//graphics-library!": {
		Doc:   "Set ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//graphics-library!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ebiten-run-game-options//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ebiten-run-game-options//graphics-library?": {
		Doc:   "Get ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//graphics-library?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ebiten-run-game-options//init-unfocused!": {
		Doc:   "Set ebiten.RunGameOptions InitUnfocused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//init-unfocused!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//init-unfocused!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.InitUnfocused = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//init-unfocused!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//init-unfocused?": {
		Doc:   "Get ebiten.RunGameOptions InitUnfocused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//init-unfocused?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//init-unfocused?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.InitUnfocused))
			return resObj
		},
	},
	"ebiten-run-game-options//screen-transparent!": {
		Doc:   "Set ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//screen-transparent!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//screen-transparent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScreenTransparent = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//screen-transparent!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//screen-transparent?": {
		Doc:   "Get ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//screen-transparent?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//screen-transparent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScreenTransparent))
			return resObj
		},
	},
	"ebiten-run-game-options//single-thread!": {
		Doc:   "Set ebiten.RunGameOptions SingleThread value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//single-thread!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//single-thread!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SingleThread = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//single-thread!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//single-thread?": {
		Doc:   "Get ebiten.RunGameOptions SingleThread value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//single-thread?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//single-thread?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleThread))
			return resObj
		},
	},
	"ebiten-run-game-options//skip-taskbar!": {
		Doc:   "Set ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//skip-taskbar!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//skip-taskbar!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SkipTaskbar = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//skip-taskbar!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//skip-taskbar?": {
		Doc:   "Get ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//skip-taskbar?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//skip-taskbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SkipTaskbar))
			return resObj
		},
	},
	"ebiten-run-game-options//x-11-class-name!": {
		Doc:   "Set ebiten.RunGameOptions X11ClassName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//x-11-class-name!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//x-11-class-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11ClassName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//x-11-class-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//x-11-class-name?": {
		Doc:   "Get ebiten.RunGameOptions X11ClassName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//x-11-class-name?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//x-11-class-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11ClassName)
			return resObj
		},
	},
	"ebiten-run-game-options//x-11-instance-name!": {
		Doc:   "Set ebiten.RunGameOptions X11InstanceName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//x-11-instance-name!: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//x-11-instance-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11InstanceName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//x-11-instance-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ebiten-run-game-options//x-11-instance-name?": {
		Doc:   "Get ebiten.RunGameOptions X11InstanceName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-run-game-options//x-11-instance-name?: arg 1: expected native of type ebiten.RunGameOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-run-game-options//x-11-instance-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11InstanceName)
			return resObj
		},
	},
	"run-game-with-options": {
		Doc:   "ebiten.RunGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-with-options: arg 1: expected native")
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 2: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-with-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-with-options: arg 2: expected native")
			}
			res0 := ebiten.RunGameWithOptions(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"run-game-without-main-loop": {
		Doc:   "ebiten.RunGameWithoutMainLoop",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game-without-main-loop: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-without-main-loop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-without-main-loop: arg 1: expected native")
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("run-game-without-main-loop: arg 2: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("run-game-without-main-loop: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("run-game-without-main-loop: arg 2: expected native")
			}
			ebiten.RunGameWithoutMainLoop(arg0Val, arg1Val)
			return nil
		},
	},
	"schedule-frame": {
		Doc:   "ebiten.ScheduleFrame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			ebiten.ScheduleFrame()
			return nil
		},
	},
	"screen-size-in-fullscreen": {
		Doc:   "ebiten.ScreenSizeInFullscreen",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := ebiten.ScreenSizeInFullscreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"set-cursor-mode": {
		Doc:   "ebiten.SetCursorMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.CursorModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CursorModeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-cursor-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.CursorModeType(u)
				}
			}
			ebiten.SetCursorMode(arg0Val)
			return nil
		},
	},
	"set-cursor-shape": {
		Doc:   "ebiten.SetCursorShape",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.CursorShapeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.CursorShapeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CursorShapeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-cursor-shape: arg 1: expected integer")
					}
					arg0Val = ebiten.CursorShapeType(u)
				}
			}
			ebiten.SetCursorShape(arg0Val)
			return nil
		},
	},
	"set-fps-mode": {
		Doc:   "ebiten.SetFPSMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.FPSModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.FPSModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FPSModeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-fps-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.FPSModeType(u)
				}
			}
			ebiten.SetFPSMode(arg0Val)
			return nil
		},
	},
	"set-fullscreen": {
		Doc:   "ebiten.SetFullscreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-fullscreen: arg 1: expected integer")
			}
			ebiten.SetFullscreen(arg0Val)
			return nil
		},
	},
	"set-init-focused": {
		Doc:   "ebiten.SetInitFocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-init-focused: arg 1: expected integer")
			}
			ebiten.SetInitFocused(arg0Val)
			return nil
		},
	},
	"set-max-tps": {
		Doc:   "ebiten.SetMaxTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-max-tps: arg 1: expected integer")
			}
			ebiten.SetMaxTPS(arg0Val)
			return nil
		},
	},
	"set-monitor": {
		Doc:   "ebiten.SetMonitor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("set-monitor: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-monitor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-monitor: arg 1: expected native")
			}
			ebiten.SetMonitor(arg0Val)
			return nil
		},
	},
	"set-runnable-on-unfocused": {
		Doc:   "ebiten.SetRunnableOnUnfocused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-runnable-on-unfocused: arg 1: expected integer")
			}
			ebiten.SetRunnableOnUnfocused(arg0Val)
			return nil
		},
	},
	"set-screen-cleared-every-frame": {
		Doc:   "ebiten.SetScreenClearedEveryFrame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-cleared-every-frame: arg 1: expected integer")
			}
			ebiten.SetScreenClearedEveryFrame(arg0Val)
			return nil
		},
	},
	"set-screen-filter-enabled": {
		Doc:   "ebiten.SetScreenFilterEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-filter-enabled: arg 1: expected integer")
			}
			ebiten.SetScreenFilterEnabled(arg0Val)
			return nil
		},
	},
	"set-screen-transparent": {
		Doc:   "ebiten.SetScreenTransparent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-screen-transparent: arg 1: expected integer")
			}
			ebiten.SetScreenTransparent(arg0Val)
			return nil
		},
	},
	"set-tps": {
		Doc:   "ebiten.SetTPS",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-tps: arg 1: expected integer")
			}
			ebiten.SetTPS(arg0Val)
			return nil
		},
	},
	"set-vsync-enabled": {
		Doc:   "ebiten.SetVsyncEnabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-vsync-enabled: arg 1: expected integer")
			}
			ebiten.SetVsyncEnabled(arg0Val)
			return nil
		},
	},
	"set-window-closing-handled": {
		Doc:   "ebiten.SetWindowClosingHandled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-closing-handled: arg 1: expected integer")
			}
			ebiten.SetWindowClosingHandled(arg0Val)
			return nil
		},
	},
	"set-window-decorated": {
		Doc:   "ebiten.SetWindowDecorated",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-decorated: arg 1: expected integer")
			}
			ebiten.SetWindowDecorated(arg0Val)
			return nil
		},
	},
	"set-window-floating": {
		Doc:   "ebiten.SetWindowFloating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-floating: arg 1: expected integer")
			}
			ebiten.SetWindowFloating(arg0Val)
			return nil
		},
	},
	"set-window-icon": {
		Doc:   "ebiten.SetWindowIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []image.Image
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]image.Image, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(image.Image)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("set-window-icon: arg 1: block item: expected native of type image.Image")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("set-window-icon: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("set-window-icon: arg 1: expected native of type []image.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-window-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-window-icon: arg 1: expected block, native or nil")
			}
			ebiten.SetWindowIcon(arg0Val)
			return nil
		},
	},
	"set-window-mouse-passthrough": {
		Doc:   "ebiten.SetWindowMousePassthrough",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-mouse-passthrough: arg 1: expected integer")
			}
			ebiten.SetWindowMousePassthrough(arg0Val)
			return nil
		},
	},
	"set-window-position": {
		Doc:   "ebiten.SetWindowPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-position: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-position: arg 2: expected integer")
			}
			ebiten.SetWindowPosition(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-resizable": {
		Doc:   "ebiten.SetWindowResizable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-resizable: arg 1: expected integer")
			}
			ebiten.SetWindowResizable(arg0Val)
			return nil
		},
	},
	"set-window-resizing-mode": {
		Doc:   "ebiten.SetWindowResizingMode",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.WindowResizingModeType
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.WindowResizingModeType
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.WindowResizingModeType)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("set-window-resizing-mode: arg 1: expected integer")
					}
					arg0Val = ebiten.WindowResizingModeType(u)
				}
			}
			ebiten.SetWindowResizingMode(arg0Val)
			return nil
		},
	},
	"set-window-size": {
		Doc:   "ebiten.SetWindowSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size: arg 2: expected integer")
			}
			ebiten.SetWindowSize(arg0Val, arg1Val)
			return nil
		},
	},
	"set-window-size-limits": {
		Doc:   "ebiten.SetWindowSizeLimits",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-size-limits: arg 4: expected integer")
			}
			ebiten.SetWindowSizeLimits(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"set-window-title": {
		Doc:   "ebiten.SetWindowTitle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("set-window-title: arg 1: expected string")
			}
			ebiten.SetWindowTitle(arg0Val)
			return nil
		},
	},
	"standard-gamepad-axis-left-stick-horizontal": {
		Doc:   "Get ebiten.StandardGamepadAxisLeftStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisLeftStickHorizontal)))
			return resObj
		},
	},
	"standard-gamepad-axis-left-stick-vertical": {
		Doc:   "Get ebiten.StandardGamepadAxisLeftStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisLeftStickVertical)))
			return resObj
		},
	},
	"standard-gamepad-axis-max": {
		Doc:   "Get ebiten.StandardGamepadAxisMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisMax)))
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-horizontal": {
		Doc:   "Get ebiten.StandardGamepadAxisRightStickHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisRightStickHorizontal)))
			return resObj
		},
	},
	"standard-gamepad-axis-right-stick-vertical": {
		Doc:   "Get ebiten.StandardGamepadAxisRightStickVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadAxisRightStickVertical)))
			return resObj
		},
	},
	"standard-gamepad-axis-value": {
		Doc:   "ebiten.StandardGamepadAxisValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-axis-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadAxis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadAxis
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadAxis)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-axis-value: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadAxis(u)
				}
			}
			res0 := ebiten.StandardGamepadAxisValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"standard-gamepad-button-center-center": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterCenter)))
			return resObj
		},
	},
	"standard-gamepad-button-center-left": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-center-right": {
		Doc:   "Get ebiten.StandardGamepadButtonCenterRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonCenterRight)))
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-left": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontBottomLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontBottomLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-front-bottom-right": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontBottomRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontBottomRight)))
			return resObj
		},
	},
	"standard-gamepad-button-front-top-left": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontTopLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontTopLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-front-top-right": {
		Doc:   "Get ebiten.StandardGamepadButtonFrontTopRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonFrontTopRight)))
			return resObj
		},
	},
	"standard-gamepad-button-left-bottom": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftBottom)))
			return resObj
		},
	},
	"standard-gamepad-button-left-left": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-left-right": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftRight)))
			return resObj
		},
	},
	"standard-gamepad-button-left-stick": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftStick)))
			return resObj
		},
	},
	"standard-gamepad-button-left-top": {
		Doc:   "Get ebiten.StandardGamepadButtonLeftTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonLeftTop)))
			return resObj
		},
	},
	"standard-gamepad-button-max": {
		Doc:   "Get ebiten.StandardGamepadButtonMax value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonMax)))
			return resObj
		},
	},
	"standard-gamepad-button-right-bottom": {
		Doc:   "Get ebiten.StandardGamepadButtonRightBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightBottom)))
			return resObj
		},
	},
	"standard-gamepad-button-right-left": {
		Doc:   "Get ebiten.StandardGamepadButtonRightLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightLeft)))
			return resObj
		},
	},
	"standard-gamepad-button-right-right": {
		Doc:   "Get ebiten.StandardGamepadButtonRightRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightRight)))
			return resObj
		},
	},
	"standard-gamepad-button-right-stick": {
		Doc:   "Get ebiten.StandardGamepadButtonRightStick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightStick)))
			return resObj
		},
	},
	"standard-gamepad-button-right-top": {
		Doc:   "Get ebiten.StandardGamepadButtonRightTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.StandardGamepadButtonRightTop)))
			return resObj
		},
	},
	"standard-gamepad-button-value": {
		Doc:   "ebiten.StandardGamepadButtonValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-button-value: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("standard-gamepad-button-value: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := ebiten.StandardGamepadButtonValue(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"touch-i-ds": {
		Doc:   "ebiten.TouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.TouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"touch-position": {
		Doc:   "ebiten.TouchPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("touch-position: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0, res1 := ebiten.TouchPosition(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"tps": {
		Doc:   "ebiten.TPS",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.TPS()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"update-standard-gamepad-layout-mappings": {
		Doc:   "ebiten.UpdateStandardGamepadLayoutMappings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("update-standard-gamepad-layout-mappings: arg 1: expected string")
			}
			res0, res1 := ebiten.UpdateStandardGamepadLayoutMappings(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ebiten-vertex//color-a!": {
		Doc:   "Set ebiten.Vertex ColorA value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-a!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorA = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-a!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-a?": {
		Doc:   "Get ebiten.Vertex ColorA value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-a?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorA))
			return resObj
		},
	},
	"ebiten-vertex//color-b!": {
		Doc:   "Set ebiten.Vertex ColorB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-b!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorB = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-b!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-b?": {
		Doc:   "Get ebiten.Vertex ColorB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-b?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorB))
			return resObj
		},
	},
	"ebiten-vertex//color-g!": {
		Doc:   "Set ebiten.Vertex ColorG value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-g!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorG = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-g!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-g?": {
		Doc:   "Get ebiten.Vertex ColorG value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-g?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorG))
			return resObj
		},
	},
	"ebiten-vertex//color-r!": {
		Doc:   "Set ebiten.Vertex ColorR value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-r!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorR = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-r!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//color-r?": {
		Doc:   "Get ebiten.Vertex ColorR value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//color-r?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//color-r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorR))
			return resObj
		},
	},
	"ebiten-vertex//dst-x!": {
		Doc:   "Set ebiten.Vertex DstX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//dst-x!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//dst-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//dst-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//dst-x?": {
		Doc:   "Get ebiten.Vertex DstX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//dst-x?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//dst-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstX))
			return resObj
		},
	},
	"ebiten-vertex//dst-y!": {
		Doc:   "Set ebiten.Vertex DstY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//dst-y!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//dst-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//dst-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//dst-y?": {
		Doc:   "Get ebiten.Vertex DstY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//dst-y?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//dst-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstY))
			return resObj
		},
	},
	"ebiten-vertex//src-x!": {
		Doc:   "Set ebiten.Vertex SrcX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//src-x!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//src-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//src-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//src-x?": {
		Doc:   "Get ebiten.Vertex SrcX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//src-x?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//src-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcX))
			return resObj
		},
	},
	"ebiten-vertex//src-y!": {
		Doc:   "Set ebiten.Vertex SrcY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//src-y!: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//src-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//src-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vertex//src-y?": {
		Doc:   "Get ebiten.Vertex SrcY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vertex//src-y?: arg 1: expected native of type ebiten.Vertex")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vertex//src-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcY))
			return resObj
		},
	},
	"vibrate": {
		Doc:   "ebiten.Vibrate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vibrate: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vibrate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate: arg 1: expected native")
			}
			ebiten.Vibrate(arg0Val)
			return nil
		},
	},
	"vibrate-gamepad": {
		Doc:   "ebiten.VibrateGamepad",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("vibrate-gamepad: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val *ebiten.VibrateGamepadOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 2: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vibrate-gamepad: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vibrate-gamepad: arg 2: expected native")
			}
			ebiten.VibrateGamepad(arg0Val, arg1Val)
			return nil
		},
	},
	"ebiten-vibrate-gamepad-options//duration!": {
		Doc:   "Set ebiten.VibrateGamepadOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-vibrate-gamepad-options//duration?": {
		Doc:   "Get ebiten.VibrateGamepadOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//duration?: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ebiten-vibrate-gamepad-options//strong-magnitude!": {
		Doc:   "Set ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrongMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vibrate-gamepad-options//strong-magnitude?": {
		Doc:   "Get ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrongMagnitude))
			return resObj
		},
	},
	"ebiten-vibrate-gamepad-options//weak-magnitude!": {
		Doc:   "Set ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.WeakMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vibrate-gamepad-options//weak-magnitude?": {
		Doc:   "Get ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native of type ebiten.VibrateGamepadOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeakMagnitude))
			return resObj
		},
	},
	"ebiten-vibrate-options//duration!": {
		Doc:   "Set ebiten.VibrateOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-options//duration!: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ebiten-vibrate-options//duration?": {
		Doc:   "Get ebiten.VibrateOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-options//duration?: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ebiten-vibrate-options//magnitude!": {
		Doc:   "Set ebiten.VibrateOptions Magnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-options//magnitude!: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-options//magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Magnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-options//magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ebiten-vibrate-options//magnitude?": {
		Doc:   "Get ebiten.VibrateOptions Magnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebiten-vibrate-options//magnitude?: arg 1: expected native of type ebiten.VibrateOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ebiten-vibrate-options//magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Magnitude))
			return resObj
		},
	},
	"wheel": {
		Doc:   "ebiten.Wheel",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := ebiten.Wheel()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"xoff": res0Obj,
				"yoff": res1Obj,
			})
		},
	},
	"window-position": {
		Doc:   "ebiten.WindowPosition",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"x": res0Obj,
				"y": res1Obj,
			})
		},
	},
	"window-resizing-mode": {
		Doc:   "ebiten.WindowResizingMode",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebiten.WindowResizingMode()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"window-resizing-mode-disabled": {
		Doc:   "Get ebiten.WindowResizingModeDisabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeDisabled)))
			return resObj
		},
	},
	"window-resizing-mode-enabled": {
		Doc:   "Get ebiten.WindowResizingModeEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeEnabled)))
			return resObj
		},
	},
	"window-resizing-mode-only-fullscreen-enabled": {
		Doc:   "Get ebiten.WindowResizingModeOnlyFullscreenEnabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(ebiten.WindowResizingModeOnlyFullscreenEnabled)))
			return resObj
		},
	},
	"window-size": {
		Doc:   "ebiten.WindowSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := ebiten.WindowSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"window-size-limits": {
		Doc:   "ebiten.WindowSizeLimits",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1, res2, res3 := ebiten.WindowSizeLimits()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewInteger(int64(res3))
			return env.NewDict(map[string]any{
				"minw": res0Obj,
				"minh": res1Obj,
				"maxw": res2Obj,
				"maxh": res3Obj,
			})
		},
	},
	"ebitenmobileview-device-scale": {
		Doc:   "ebitenmobileview.DeviceScale",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebitenmobileview.DeviceScale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ebitenmobileview-is-gl": {
		Doc:   "ebitenmobileview.IsGL",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := ebitenmobileview.IsGL()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ebitenmobileview-layout": {
		Doc:   "ebitenmobileview.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-layout: arg 1: expected decimal")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-layout: arg 2: expected decimal")
			}
			ebitenmobileview.Layout(arg0Val, arg1Val)
			return nil
		},
	},
	"ebitenmobileview-on-gamepad-axis-changed": {
		Doc:   "ebitenmobileview.OnGamepadAxisChanged",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-axis-changed: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-axis-changed: arg 2: expected integer")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-axis-changed: arg 3: expected decimal")
			}
			ebitenmobileview.OnGamepadAxisChanged(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"ebitenmobileview-on-gamepad-hat-changed": {
		Doc:   "ebitenmobileview.OnGamepadHatChanged",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-hat-changed: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-hat-changed: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-hat-changed: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-gamepad-hat-changed: arg 4: expected integer")
			}
			ebitenmobileview.OnGamepadHatChanged(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"ebitenmobileview-on-input-device-removed": {
		Doc:   "ebitenmobileview.OnInputDeviceRemoved",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-input-device-removed: arg 1: expected integer")
			}
			ebitenmobileview.OnInputDeviceRemoved(arg0Val)
			return nil
		},
	},
	"ebitenmobileview-on-key-down-on-android": {
		Doc:   "ebitenmobileview.OnKeyDownOnAndroid",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-down-on-android: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-down-on-android: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-down-on-android: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-down-on-android: arg 4: expected integer")
			}
			ebitenmobileview.OnKeyDownOnAndroid(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"ebitenmobileview-on-key-up-on-android": {
		Doc:   "ebitenmobileview.OnKeyUpOnAndroid",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-up-on-android: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-up-on-android: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-on-key-up-on-android: arg 3: expected integer")
			}
			ebitenmobileview.OnKeyUpOnAndroid(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"ebitenmobileview-render-requester//request-render-if-needed": {
		Doc:   "ebitenmobileview.RenderRequester.RequestRenderIfNeeded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebitenmobileview.RenderRequester
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebitenmobileview.RenderRequester)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-render-requester//request-render-if-needed: arg 1: expected native of type ebitenmobileview.RenderRequester")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-render-requester//request-render-if-needed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-render-requester//request-render-if-needed: arg 1: expected native")
			}
			arg0Val.RequestRenderIfNeeded()
			return arg0
		},
	},
	"ebitenmobileview-render-requester//set-explicit-rendering-mode": {
		Doc:   "ebitenmobileview.RenderRequester.SetExplicitRenderingMode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebitenmobileview.RenderRequester
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebitenmobileview.RenderRequester)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-render-requester//set-explicit-rendering-mode: arg 1: expected native of type ebitenmobileview.RenderRequester")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-render-requester//set-explicit-rendering-mode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-render-requester//set-explicit-rendering-mode: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-render-requester//set-explicit-rendering-mode: arg 2: expected integer")
			}
			arg0Val.SetExplicitRenderingMode(arg1Val)
			return arg0
		},
	},
	"ebitenmobileview-resume": {
		Doc:   "ebitenmobileview.Resume",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebitenmobileview.Resume()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ebitenmobileview-set-game": {
		Doc:   "ebitenmobileview.SetGame",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-game: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-game: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-set-game: arg 1: expected native")
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-game: arg 2: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-game: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-set-game: arg 2: expected native")
			}
			ebitenmobileview.SetGame(arg0Val, arg1Val)
			return nil
		},
	},
	"ebitenmobileview-set-game-notifier//notify-set-game": {
		Doc:   "ebitenmobileview.SetGameNotifier.NotifySetGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebitenmobileview.SetGameNotifier
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebitenmobileview.SetGameNotifier)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-game-notifier//notify-set-game: arg 1: expected native of type ebitenmobileview.SetGameNotifier")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-game-notifier//notify-set-game: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-set-game-notifier//notify-set-game: arg 1: expected native")
			}
			arg0Val.NotifySetGame()
			return arg0
		},
	},
	"ebitenmobileview-set-render-requester": {
		Doc:   "ebitenmobileview.SetRenderRequester",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebitenmobileview.RenderRequester
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebitenmobileview.RenderRequester)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-render-requester: arg 1: expected native of type ebitenmobileview.RenderRequester")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-render-requester: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-set-render-requester: arg 1: expected native")
			}
			ebitenmobileview.SetRenderRequester(arg0Val)
			return nil
		},
	},
	"ebitenmobileview-set-set-game-notifier": {
		Doc:   "ebitenmobileview.SetSetGameNotifier",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebitenmobileview.SetGameNotifier
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebitenmobileview.SetGameNotifier)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-set-game-notifier: arg 1: expected native of type ebitenmobileview.SetGameNotifier")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ebitenmobileview-set-set-game-notifier: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-set-set-game-notifier: arg 1: expected native")
			}
			ebitenmobileview.SetSetGameNotifier(arg0Val)
			return nil
		},
	},
	"ebitenmobileview-set-ui-view": {
		Doc:   "ebitenmobileview.SetUIView",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int64
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-set-ui-view: arg 1: expected integer")
			}
			res0 := ebitenmobileview.SetUIView(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ebitenmobileview-suspend": {
		Doc:   "ebitenmobileview.Suspend",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebitenmobileview.Suspend()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ebitenmobileview-update": {
		Doc:   "ebitenmobileview.Update",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := ebitenmobileview.Update()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ebitenmobileview-update-presses-on-ios": {
		Doc:   "ebitenmobileview.UpdatePressesOnIOS",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-presses-on-ios: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-presses-on-ios: arg 2: expected integer")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-presses-on-ios: arg 3: expected string")
			}
			ebitenmobileview.UpdatePressesOnIOS(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"ebitenmobileview-update-touches-on-android": {
		Doc:   "ebitenmobileview.UpdateTouchesOnAndroid",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-android: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-android: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-android: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-android: arg 4: expected integer")
			}
			ebitenmobileview.UpdateTouchesOnAndroid(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"ebitenmobileview-update-touches-on-ios": {
		Doc:   "ebitenmobileview.UpdateTouchesOnIOS",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-ios: arg 1: expected integer")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-ios: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-ios: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ebitenmobileview-update-touches-on-ios: arg 4: expected integer")
			}
			ebitenmobileview.UpdateTouchesOnIOS(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"debug-print": {
		Doc:   "ebitenutil.DebugPrint",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("debug-print: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("debug-print: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("debug-print: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print: arg 2: expected string")
			}
			ebitenutil.DebugPrint(arg0Val, arg1Val)
			return nil
		},
	},
	"debug-print-at": {
		Doc:   "ebitenutil.DebugPrintAt",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("debug-print-at: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("debug-print-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("debug-print-at: arg 4: expected integer")
			}
			ebitenutil.DebugPrintAt(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"draw-circle": {
		Doc:   "ebitenutil.DrawCircle",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 4: expected decimal")
			}
			var arg4Val color.Color
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("draw-circle: arg 5: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("draw-circle: arg 5: expected native")
			}
			ebitenutil.DrawCircle(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val)
			return nil
		},
	},
	"image-from-file": {
		Doc:   "ebitenutil.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-file: arg 1: expected string")
			}
			res0, res1, res2 := ebitenutil.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"image-from-file-system": {
		Doc:   "ebitenutil.NewImageFromFileSystem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fs.FS
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fs.FS)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: expected native of type fs.FS")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-file-system: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-file-system: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-file-system: arg 2: expected string")
			}
			res0, res1, res2 := ebitenutil.NewImageFromFileSystem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"image-from-reader": {
		Doc:   "ebitenutil.NewImageFromReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("image-from-reader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("image-from-reader: arg 1: expected native")
			}
			res0, res1, res2 := ebitenutil.NewImageFromReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "image-image")
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"image-from-url": {
		Doc:   "ebitenutil.NewImageFromURL",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("image-from-url: arg 1: expected string")
			}
			res0, res1 := ebitenutil.NewImageFromURL(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-ebiten-image")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"open-file": {
		Doc:   "ebitenutil.OpenFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("open-file: arg 1: expected string")
			}
			res0, res1 := ebitenutil.OpenFile(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "ebitenutil-read-seek-closer")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"flappy-gopher-png": {
		Doc:   "Get flappy.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Gopher_png))
				for i, it := range flappy.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"flappy-tiles-png": {
		Doc:   "Get flappy.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(flappy.Tiles_png))
				for i, it := range flappy.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-m-plus-1-p-regular-ttf": {
		Doc:   "Get fonts.MPlus1pRegular_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.MPlus1pRegular_ttf))
				for i, it := range fonts.MPlus1pRegular_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fonts-press-start-2-p-ttf": {
		Doc:   "Get fonts.PressStart2P_ttf value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(fonts.PressStart2P_ttf))
				for i, it := range fonts.PressStart2P_ttf {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ebiten-png": {
		Doc:   "Get images.Ebiten_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Ebiten_png))
				for i, it := range images.Ebiten_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-five-years-jpg": {
		Doc:   "Get images.FiveYears_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.FiveYears_jpg))
				for i, it := range images.FiveYears_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-gophers-jpg": {
		Doc:   "Get images.Gophers_jpg value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Gophers_jpg))
				for i, it := range images.Gophers_jpg {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-runner-png": {
		Doc:   "Get images.Runner_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Runner_png))
				for i, it := range images.Runner_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-smoke-png": {
		Doc:   "Get images.Smoke_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Smoke_png))
				for i, it := range images.Smoke_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-spritesheet-png": {
		Doc:   "Get images.Spritesheet_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Spritesheet_png))
				for i, it := range images.Spritesheet_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tile-png": {
		Doc:   "Get images.Tile_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tile_png))
				for i, it := range images.Tile_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-tiles-png": {
		Doc:   "Get images.Tiles_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.Tiles_png))
				for i, it := range images.Tiles_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"images-ui-png": {
		Doc:   "Get images.UI_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(images.UI_png))
				for i, it := range images.UI_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"inpututil-append-just-connected-gamepad-i-ds": {
		Doc:   "inpututil.AppendJustConnectedGamepadIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.GamepadID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.GamepadID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.GamepadID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.GamepadID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected native of type []ebiten.GamepadID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-connected-gamepad-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustConnectedGamepadIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-gamepad-buttons": {
		Doc:   "inpututil.AppendJustPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-keys": {
		Doc:   "inpututil.AppendJustPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendJustPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-pressed-touch-i-ds": {
		Doc:   "inpututil.AppendJustPressedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-pressed-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustPressedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-gamepad-buttons": {
		Doc:   "inpututil.AppendJustReleasedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-keys": {
		Doc:   "inpututil.AppendJustReleasedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendJustReleasedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-just-released-touch-i-ds": {
		Doc:   "inpututil.AppendJustReleasedTouchIDs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.TouchID
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.TouchID, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.TouchID
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.TouchID)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.TouchID(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.TouchID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected native of type []ebiten.TouchID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-just-released-touch-i-ds: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendJustReleasedTouchIDs(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-gamepad-buttons": {
		Doc:   "inpututil.AppendPressedGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.GamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.GamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.GamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.GamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.GamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.GamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected native of type []ebiten.GamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-keys": {
		Doc:   "inpututil.AppendPressedKeys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []ebiten.Key
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]ebiten.Key, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.Key
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.Key)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-keys: arg 1: block item: expected integer")
							}
							arg0Val[i] = ebiten.Key(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-keys: arg 1: expected native of type []ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-keys: arg 1: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedKeys(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-append-pressed-standard-gamepad-buttons": {
		Doc:   "inpututil.AppendPressedStandardGamepadButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val []ebiten.StandardGamepadButton
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.StandardGamepadButton, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal ebiten.StandardGamepadButton
						if natOk {
							natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
						}
						if natOk && natValOk {
							arg1Val[i] = natVal
						} else {
							var u int
							if v, ok := it.(env.Integer); ok {
								u = int(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: block item: expected integer")
							}
							arg1Val[i] = ebiten.StandardGamepadButton(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.StandardGamepadButton)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected native of type []ebiten.StandardGamepadButton")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inpututil-append-pressed-standard-gamepad-buttons: arg 2: expected block, native or nil")
			}
			res0 := inpututil.AppendPressedStandardGamepadButtons(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-gamepad-button-press-duration": {
		Doc:   "inpututil.GamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-gamepad-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-gamepad-button-press-duration: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.GamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-pressed": {
		Doc:   "inpututil.IsGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.IsGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-button-just-released": {
		Doc:   "inpututil.IsGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.GamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-button-just-released: arg 2: expected integer")
					}
					arg1Val = ebiten.GamepadButton(u)
				}
			}
			res0 := inpututil.IsGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-gamepad-just-disconnected": {
		Doc:   "inpututil.IsGamepadJustDisconnected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-gamepad-just-disconnected: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			res0 := inpututil.IsGamepadJustDisconnected(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-pressed": {
		Doc:   "inpututil.IsKeyJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-key-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-key-just-released": {
		Doc:   "inpututil.IsKeyJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-key-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.IsKeyJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-pressed": {
		Doc:   "inpututil.IsMouseButtonJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-mouse-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.IsMouseButtonJustPressed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-mouse-button-just-released": {
		Doc:   "inpututil.IsMouseButtonJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-mouse-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.IsMouseButtonJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-pressed": {
		Doc:   "inpututil.IsStandardGamepadButtonJustPressed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-pressed: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.IsStandardGamepadButtonJustPressed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-standard-gamepad-button-just-released": {
		Doc:   "inpututil.IsStandardGamepadButtonJustReleased",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-standard-gamepad-button-just-released: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.IsStandardGamepadButtonJustReleased(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-is-touch-just-released": {
		Doc:   "inpututil.IsTouchJustReleased",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-is-touch-just-released: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0 := inpututil.IsTouchJustReleased(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"inpututil-just-connected-gamepad-i-ds": {
		Doc:   "inpututil.JustConnectedGamepadIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := inpututil.JustConnectedGamepadIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-just-pressed-touch-i-ds": {
		Doc:   "inpututil.JustPressedTouchIDs",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := inpututil.JustPressedTouchIDs()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-key-press-duration": {
		Doc:   "inpututil.KeyPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-key-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0 := inpututil.KeyPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-mouse-button-press-duration": {
		Doc:   "inpututil.MouseButtonPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.MouseButton
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.MouseButton)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-mouse-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.MouseButton(u)
				}
			}
			res0 := inpututil.MouseButtonPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-pressed-keys": {
		Doc:   "inpututil.PressedKeys",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := inpututil.PressedKeys()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(int(it)))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"inpututil-standard-gamepad-button-press-duration": {
		Doc:   "inpututil.StandardGamepadButtonPressDuration",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.GamepadID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.GamepadID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GamepadID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.GamepadID(u)
				}
			}
			var arg1Val ebiten.StandardGamepadButton
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.StandardGamepadButton
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.StandardGamepadButton)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-standard-gamepad-button-press-duration: arg 2: expected integer")
					}
					arg1Val = ebiten.StandardGamepadButton(u)
				}
			}
			res0 := inpututil.StandardGamepadButtonPressDuration(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"inpututil-touch-position-in-previous-tick": {
		Doc:   "inpututil.TouchPositionInPreviousTick",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-touch-position-in-previous-tick: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0, res1 := inpututil.TouchPositionInPreviousTick(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"inpututil-touch-press-duration": {
		Doc:   "inpututil.TouchPressDuration",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.TouchID
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.TouchID
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.TouchID)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("inpututil-touch-press-duration: arg 1: expected integer")
					}
					arg0Val = ebiten.TouchID(u)
				}
			}
			res0 := inpututil.TouchPressDuration(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"io-closer//close": {
		Doc:   "io.Closer.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Closer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Closer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-closer//close: arg 1: expected native of type io.Closer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-closer//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-closer//close: arg 1: expected native")
			}
			res0 := arg0Val.Close()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"io-reader//read": {
		Doc:   "io.Reader.Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-reader//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("io-reader//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("io-reader//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-reader//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-reader//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"n":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"io-seeker//seek": {
		Doc:   "io.Seeker.Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Seeker
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Seeker)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("io-seeker//seek: arg 1: expected native of type io.Seeker")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("io-seeker//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("io-seeker//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("io-seeker//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("io-seeker//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"keyboard-1-keyboard-png": {
		Doc:   "Get keyboard_1.Keyboard_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(keyboard_1.Keyboard_png))
				for i, it := range keyboard_1.Keyboard_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"keyboard-key-rect": {
		Doc:   "keyboard.KeyRect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Key
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal ebiten.Key
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Key)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("keyboard-key-rect: arg 1: expected integer")
					}
					arg0Val = ebiten.Key(u)
				}
			}
			res0, res1 := keyboard.KeyRect(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-rectangle")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"mascot-out-01-png": {
		Doc:   "Get mascot.Out01_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out01_png))
				for i, it := range mascot.Out01_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-02-png": {
		Doc:   "Get mascot.Out02_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out02_png))
				for i, it := range mascot.Out02_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mascot-out-03-png": {
		Doc:   "Get mascot.Out03_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(mascot.Out03_png))
				for i, it := range mascot.Out03_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"mobile-run-on-jvm": {
		Doc:   "mobile.RunOnJVM",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(uintptr, uintptr, uintptr) error
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(func(uintptr, uintptr, uintptr) error)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-run-on-jvm: arg 1: expected native of type func(uintptr, uintptr, uintptr) (error)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-run-on-jvm: arg 1: expected native")
			}
			res0 := mobile.RunOnJVM(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"mobile-set-game": {
		Doc:   "mobile.SetGame",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game: arg 1: expected native")
			}
			mobile.SetGame(arg0Val)
			return nil
		},
	},
	"mobile-set-game-with-options": {
		Doc:   "mobile.SetGameWithOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val ebiten.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(ebiten.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: expected native of type ebiten.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game-with-options: arg 1: expected native")
			}
			var arg1Val *ebiten.RunGameOptions
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 2: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-set-game-with-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-set-game-with-options: arg 2: expected native")
			}
			mobile.SetGameWithOptions(arg0Val, arg1Val)
			return nil
		},
	},
	"mp-3-decode": {
		Doc:   "mp3.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode: arg 2: expected native")
			}
			res0, res1 := mp3.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"mp-3-decode-with-sample-rate": {
		Doc:   "mp3.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-with-sample-rate: arg 2: expected native")
			}
			res0, res1 := mp3.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"mp-3-decode-without-resampling": {
		Doc:   "mp3.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mp-3-decode-without-resampling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mp-3-decode-without-resampling: arg 1: expected native")
			}
			res0, res1 := mp3.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-mp-3-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"platformer-background-png": {
		Doc:   "Get platformer.Background_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Background_png))
				for i, it := range platformer.Background_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-left-png": {
		Doc:   "Get platformer.Left_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Left_png))
				for i, it := range platformer.Left_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-main-char-png": {
		Doc:   "Get platformer.MainChar_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.MainChar_png))
				for i, it := range platformer.MainChar_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"platformer-right-png": {
		Doc:   "Get platformer.Right_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(platformer.Right_png))
				for i, it := range platformer.Right_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-audio-infinite-loop//read": {
		Doc:   "(*audio.InfiniteLoop).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.InfiniteLoop)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected native of type *audio.InfiniteLoop")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-audio-infinite-loop//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-audio-infinite-loop//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-audio-infinite-loop//seek": {
		Doc:   "(*audio.InfiniteLoop).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *audio.InfiniteLoop
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.InfiniteLoop)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected native of type *audio.InfiniteLoop")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-audio-infinite-loop//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-blocks-field//absorb-piece": {
		Doc:   "(*blocks.Field).AbsorbPiece",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//absorb-piece: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//absorb-piece: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//absorb-piece: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbPiece(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-field//draw": {
		Doc:   "(*blocks.Field).Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//draw: arg 4: expected integer")
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-blocks-field//drop-piece": {
		Doc:   "(*blocks.Field).DropPiece",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//drop-piece: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//drop-piece: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//drop-piece: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.DropPiece(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//is-blocked": {
		Doc:   "(*blocks.Field).IsBlocked",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-blocked: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-blocked: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-blocked: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-blocked: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-blocked: arg 3: expected integer")
			}
			res0 := arg0Val.IsBlocked(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//is-flush-animating": {
		Doc:   "(*blocks.Field).IsFlushAnimating",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-flush-animating: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//is-flush-animating: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//is-flush-animating: arg 1: expected native")
			}
			res0 := arg0Val.IsFlushAnimating()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//move-piece-to-left": {
		Doc:   "(*blocks.Field).MovePieceToLeft",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-left: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-left: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//move-piece-to-left: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.MovePieceToLeft(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//move-piece-to-right": {
		Doc:   "(*blocks.Field).MovePieceToRight",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//move-piece-to-right: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//move-piece-to-right: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//move-piece-to-right: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.MovePieceToRight(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//piece-droppable": {
		Doc:   "(*blocks.Field).PieceDroppable",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//piece-droppable: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//piece-droppable: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//piece-droppable: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.PieceDroppable(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-field//rotate-piece-left": {
		Doc:   "(*blocks.Field).RotatePieceLeft",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-left: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-left: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//rotate-piece-left: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotatePieceLeft(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-field//rotate-piece-right": {
		Doc:   "(*blocks.Field).RotatePieceRight",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 1: expected native")
			}
			var arg1Val *blocks.Piece
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 2: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//rotate-piece-right: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//rotate-piece-right: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-field//rotate-piece-right: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			res0 := arg0Val.RotatePieceRight(arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-field//set-end-flush-animating": {
		Doc:   "(*blocks.Field).SetEndFlushAnimating",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 1: expected native")
			}
			var arg1Val func(int)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 int) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//set-end-flush-animating: arg 2: expected function or nil")
			}
			arg0Val.SetEndFlushAnimating(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-field//update": {
		Doc:   "(*blocks.Field).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Field
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//update: arg 1: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-field//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-field//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-blocks-game-scene//draw": {
		Doc:   "(*blocks.GameScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GameScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected native of type *blocks.GameScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-game-scene//update": {
		Doc:   "(*blocks.GameScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.GameScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GameScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 1: expected native of type *blocks.GameScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-game-state//input!": {
		Doc:   "Set *blocks.GameState Input value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//input!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Input, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input!: arg 2: expected integer to be 0 or nil")
				}
				self.Input = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//input!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//input?": {
		Doc:   "Get *blocks.GameState Input value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input?: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//input?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//input?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Input, "ptr-blocks-input")
			return resObj
		},
	},
	"ptr-blocks-game-state//scene-manager!": {
		Doc:   "Set *blocks.GameState SceneManager value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//scene-manager!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SceneManager, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected integer to be 0 or nil")
				}
				self.SceneManager = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//scene-manager!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-blocks-game-state//scene-manager?": {
		Doc:   "Get *blocks.GameState SceneManager value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *blocks.GameState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game-state//scene-manager?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SceneManager, "ptr-blocks-scene-manager")
			return resObj
		},
	},
	"ptr-blocks-game//draw": {
		Doc:   "(*blocks.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-game//layout": {
		Doc:   "(*blocks.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//layout: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"screen-width":  res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"ptr-blocks-game//update": {
		Doc:   "(*blocks.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//update: arg 1: expected native of type *blocks.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-game//update: arg 1: expected native")
			}
			res0 := arg0Val.Update()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-gamepad-scene//draw": {
		Doc:   "(*blocks.GamepadScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GamepadScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected native of type *blocks.GamepadScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-gamepad-scene//update": {
		Doc:   "(*blocks.GamepadScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.GamepadScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.GamepadScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected native of type *blocks.GamepadScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-gamepad-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-input//gamepad-id-button-pressed": {
		Doc:   "(*blocks.Input).GamepadIDButtonPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//gamepad-id-button-pressed: arg 1: expected native")
			}
			res0 := arg0Val.GamepadIDButtonPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-blocks-input//is-rotate-left-just-pressed": {
		Doc:   "(*blocks.Input).IsRotateLeftJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//is-rotate-left-just-pressed: arg 1: expected native")
			}
			res0 := arg0Val.IsRotateLeftJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//is-rotate-right-just-pressed": {
		Doc:   "(*blocks.Input).IsRotateRightJustPressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//is-rotate-right-just-pressed: arg 1: expected native")
			}
			res0 := arg0Val.IsRotateRightJustPressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-down": {
		Doc:   "(*blocks.Input).StateForDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//state-for-down: arg 1: expected native")
			}
			res0 := arg0Val.StateForDown()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-left": {
		Doc:   "(*blocks.Input).StateForLeft",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//state-for-left: arg 1: expected native")
			}
			res0 := arg0Val.StateForLeft()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//state-for-right": {
		Doc:   "(*blocks.Input).StateForRight",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//state-for-right: arg 1: expected native")
			}
			res0 := arg0Val.StateForRight()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-blocks-input//update": {
		Doc:   "(*blocks.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//update: arg 1: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-input//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-input//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-blocks-piece//absorb-into": {
		Doc:   "(*blocks.Piece).AbsorbInto",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 1: expected native")
			}
			var arg1Val *blocks.Field
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Field)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected native of type *blocks.Field")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//absorb-into: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-piece//absorb-into: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.AbsorbInto(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-piece//draw": {
		Doc:   "(*blocks.Piece).Draw",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 3: expected integer")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//draw: arg 4: expected integer")
			}
			var arg4Val blocks.Angle
			{
				nat, natOk := arg4.(env.Native)
				var natValOk bool
				var natVal blocks.Angle
				if natOk {
					natVal, natValOk = nat.Value.(blocks.Angle)
				}
				if natOk && natValOk {
					arg4Val = natVal
				} else {
					var u int
					if v, ok := arg4.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-blocks-piece//draw: arg 5: expected integer")
					}
					arg4Val = blocks.Angle(u)
				}
			}
			arg0Val.Draw(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-blocks-piece//initial-position": {
		Doc:   "(*blocks.Piece).InitialPosition",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.Piece
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.Piece)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected native of type *blocks.Piece")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-piece//initial-position: arg 1: expected native")
			}
			res0, res1 := arg0Val.InitialPosition()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-blocks-scene-manager//draw": {
		Doc:   "(*blocks.SceneManager).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-scene-manager//go-to": {
		Doc:   "(*blocks.SceneManager).GoTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//go-to: arg 1: expected native")
			}
			var arg1Val blocks.Scene
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(blocks.Scene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected native of type blocks.Scene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//go-to: arg 2: expected native")
			}
			arg0Val.GoTo(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-scene-manager//update": {
		Doc:   "(*blocks.SceneManager).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.SceneManager
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.SceneManager)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected native of type *blocks.SceneManager")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//update: arg 1: expected native")
			}
			var arg1Val *blocks.Input
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected native of type *blocks.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-scene-manager//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-blocks-title-scene//draw": {
		Doc:   "(*blocks.TitleScene).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.TitleScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected native of type *blocks.TitleScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-blocks-title-scene//update": {
		Doc:   "(*blocks.TitleScene).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *blocks.TitleScene
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*blocks.TitleScene)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 1: expected native of type *blocks.TitleScene")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//update: arg 1: expected native")
			}
			var arg1Val *blocks.GameState
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*blocks.GameState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 2: expected native of type *blocks.GameState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-blocks-title-scene//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-blocks-title-scene//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-colorm-color-m//apply": {
		Doc:   "(*colorm.ColorM).Apply",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//apply: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//apply: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//apply: arg 2: expected native")
			}
			res0 := arg0Val.Apply(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"ptr-colorm-color-m//change-hsv": {
		Doc:   "(*colorm.ColorM).ChangeHSV",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//change-hsv: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//change-hsv: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//change-hsv: arg 4: expected decimal")
			}
			arg0Val.ChangeHSV(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//concat": {
		Doc:   "(*colorm.ColorM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//concat: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//concat: arg 1: expected native")
			}
			var arg1Val colorm.ColorM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//concat: arg 2: expected native of type colorm.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//element": {
		Doc:   "(*colorm.ColorM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//element: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-colorm-color-m//invert": {
		Doc:   "(*colorm.ColorM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//invert: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-colorm-color-m//is-invertible": {
		Doc:   "(*colorm.ColorM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//is-invertible: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-colorm-color-m//read-elements": {
		Doc:   "(*colorm.ColorM).ReadElements",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//read-elements: arg 1: expected native")
			}
			var arg1Val []float32
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]float32, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg1Val[i] = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-color-m//read-elements: arg 2: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]float32)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 2: expected native of type []float32")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//read-elements: arg 2: expected block, native or nil")
			}
			var arg2Val []float32
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float32, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-color-m//read-elements: arg 3: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float32)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 3: expected native of type []float32")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//read-elements: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//read-elements: arg 3: expected block, native or nil")
			}
			arg0Val.ReadElements(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//reset": {
		Doc:   "(*colorm.ColorM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//reset: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-colorm-color-m//rotate-hue": {
		Doc:   "(*colorm.ColorM).RotateHue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//rotate-hue: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//rotate-hue: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//rotate-hue: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//rotate-hue: arg 2: expected decimal")
			}
			arg0Val.RotateHue(arg1Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//scale": {
		Doc:   "(*colorm.ColorM).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//scale-with-color": {
		Doc:   "(*colorm.ColorM).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//scale-with-color: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//set-element": {
		Doc:   "(*colorm.ColorM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//set-element: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-colorm-color-m//string": {
		Doc:   "(*colorm.ColorM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//string: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-colorm-color-m//translate": {
		Doc:   "(*colorm.ColorM).Translate",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *colorm.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*colorm.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//translate: arg 1: expected native of type *colorm.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-color-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-color-m//translate: arg 5: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//blend!": {
		Doc:   "Set *colorm.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//blend?": {
		Doc:   "Get *colorm.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-colorm-draw-image-options//filter!": {
		Doc:   "Set *colorm.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//filter?": {
		Doc:   "Get *colorm.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-colorm-draw-image-options//geo-m!": {
		Doc:   "Set *colorm.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-image-options//geo-m?": {
		Doc:   "Get *colorm.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected native of type *colorm.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//address!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//address?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//anti-alias!": {
		Doc:   "Set *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//anti-alias?": {
		Doc:   "Get *colorm.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//blend!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//blend?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//color-scale-mode!": {
		Doc:   "Set *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//color-scale-mode?": {
		Doc:   "Get *colorm.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//fill-rule!": {
		Doc:   "Set *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//fill-rule?": {
		Doc:   "Get *colorm.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-colorm-draw-triangles-options//filter!": {
		Doc:   "Set *colorm.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-colorm-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-colorm-draw-triangles-options//filter?": {
		Doc:   "Get *colorm.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *colorm.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*colorm.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected native of type *colorm.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-colorm-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-alpha!": {
		Doc:   "Set *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha!: arg 2: expected native")
					}
					self.BlendFactorDestinationAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-alpha?": {
		Doc:   "Get *ebiten.Blend BlendFactorDestinationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-rgb!": {
		Doc:   "Set *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorDestinationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb!: arg 2: expected native")
					}
					self.BlendFactorDestinationRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-destination-rgb?": {
		Doc:   "Get *ebiten.Blend BlendFactorDestinationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-destination-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorDestinationRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-source-alpha!": {
		Doc:   "Set *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha!: arg 2: expected native")
					}
					self.BlendFactorSourceAlpha = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-source-alpha?": {
		Doc:   "Get *ebiten.Blend BlendFactorSourceAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-factor-source-rgb!": {
		Doc:   "Set *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendFactor
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendFactor)
				}
				if natOk && natValOk {
					self.BlendFactorSourceRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb!: arg 2: expected native")
					}
					self.BlendFactorSourceRGB = ebiten.BlendFactor(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-factor-source-rgb?": {
		Doc:   "Get *ebiten.Blend BlendFactorSourceRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-factor-source-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendFactorSourceRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-operation-alpha!": {
		Doc:   "Set *ebiten.Blend BlendOperationAlpha value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationAlpha = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-operation-alpha!: arg 2: expected native")
					}
					self.BlendOperationAlpha = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-operation-alpha?": {
		Doc:   "Get *ebiten.Blend BlendOperationAlpha value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-alpha?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationAlpha), "byte")
			return resObj
		},
	},
	"ptr-ebiten-blend//blend-operation-rgb!": {
		Doc:   "Set *ebiten.Blend BlendOperationRGB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.BlendOperation
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.BlendOperation)
				}
				if natOk && natValOk {
					self.BlendOperationRGB = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-blend//blend-operation-rgb!: arg 2: expected native")
					}
					self.BlendOperationRGB = ebiten.BlendOperation(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-blend//blend-operation-rgb?": {
		Doc:   "Get *ebiten.Blend BlendOperationRGB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Blend
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected native of type *ebiten.Blend")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-blend//blend-operation-rgb?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.BlendOperationRGB), "byte")
			return resObj
		},
	},
	"ptr-ebiten-color-m//apply": {
		Doc:   "(*ebiten.ColorM).Apply",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//apply: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//apply: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//apply: arg 2: expected native")
			}
			res0 := arg0Val.Apply(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//change-hsv": {
		Doc:   "(*ebiten.ColorM).ChangeHSV",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//change-hsv: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//change-hsv: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//change-hsv: arg 4: expected decimal")
			}
			arg0Val.ChangeHSV(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//concat": {
		Doc:   "(*ebiten.ColorM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//concat: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//concat: arg 1: expected native")
			}
			var arg1Val ebiten.ColorM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//concat: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//element": {
		Doc:   "(*ebiten.ColorM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//element: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//invert": {
		Doc:   "(*ebiten.ColorM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//invert: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-ebiten-color-m//is-invertible": {
		Doc:   "(*ebiten.ColorM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//is-invertible: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//reset": {
		Doc:   "(*ebiten.ColorM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//reset: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-color-m//rotate-hue": {
		Doc:   "(*ebiten.ColorM).RotateHue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//rotate-hue: arg 2: expected decimal")
			}
			arg0Val.RotateHue(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//scale": {
		Doc:   "(*ebiten.ColorM).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//scale-with-color": {
		Doc:   "(*ebiten.ColorM).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//set-element": {
		Doc:   "(*ebiten.ColorM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//set-element: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-color-m//string": {
		Doc:   "(*ebiten.ColorM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//string: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-color-m//translate": {
		Doc:   "(*ebiten.ColorM).Translate",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//translate: arg 1: expected native of type *ebiten.ColorM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 3: expected decimal")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-m//translate: arg 5: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//a": {
		Doc:   "(*ebiten.ColorScale).A",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//a: arg 1: expected native")
			}
			res0 := arg0Val.A()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//b": {
		Doc:   "(*ebiten.ColorScale).B",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//b: arg 1: expected native")
			}
			res0 := arg0Val.B()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//g": {
		Doc:   "(*ebiten.ColorScale).G",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//g: arg 1: expected native")
			}
			res0 := arg0Val.G()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//r": {
		Doc:   "(*ebiten.ColorScale).R",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//r: arg 1: expected native")
			}
			res0 := arg0Val.R()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-color-scale//reset": {
		Doc:   "(*ebiten.ColorScale).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale": {
		Doc:   "(*ebiten.ColorScale).Scale",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale: arg 5: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-alpha": {
		Doc:   "(*ebiten.ColorScale).ScaleAlpha",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-alpha: arg 2: expected decimal")
			}
			arg0Val.ScaleAlpha(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-with-color": {
		Doc:   "(*ebiten.ColorScale).ScaleWithColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color: arg 2: expected native")
			}
			arg0Val.ScaleWithColor(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//scale-with-color-scale": {
		Doc:   "(*ebiten.ColorScale).ScaleWithColorScale",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 1: expected native")
			}
			var arg1Val ebiten.ColorScale
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//scale-with-color-scale: arg 2: expected native")
			}
			arg0Val.ScaleWithColorScale(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-a": {
		Doc:   "(*ebiten.ColorScale).SetA",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-a: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-a: arg 2: expected decimal")
			}
			arg0Val.SetA(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-b": {
		Doc:   "(*ebiten.ColorScale).SetB",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-b: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-b: arg 2: expected decimal")
			}
			arg0Val.SetB(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-g": {
		Doc:   "(*ebiten.ColorScale).SetG",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-g: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-g: arg 2: expected decimal")
			}
			arg0Val.SetG(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//set-r": {
		Doc:   "(*ebiten.ColorScale).SetR",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-r: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//set-r: arg 2: expected decimal")
			}
			arg0Val.SetR(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-color-scale//string": {
		Doc:   "(*ebiten.ColorScale).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.ColorScale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected native of type *ebiten.ColorScale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-color-scale//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-debug-info//graphics-library!": {
		Doc:   "Set *ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 1: expected native of type *ebiten.DebugInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-debug-info//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-debug-info//graphics-library?": {
		Doc:   "Get *ebiten.DebugInfo GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DebugInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DebugInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library?: arg 1: expected native of type *ebiten.DebugInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-debug-info//graphics-library?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-debug-info//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//blend!": {
		Doc:   "Set *ebiten.DrawImageOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//blend?": {
		Doc:   "Get *ebiten.DrawImageOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//color-m!": {
		Doc:   "Set *ebiten.DrawImageOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//color-m?": {
		Doc:   "Get *ebiten.DrawImageOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//color-scale!": {
		Doc:   "Set *ebiten.DrawImageOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//color-scale?": {
		Doc:   "Get *ebiten.DrawImageOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//composite-mode!": {
		Doc:   "Set *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-image-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//composite-mode?": {
		Doc:   "Get *ebiten.DrawImageOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//filter!": {
		Doc:   "Set *ebiten.DrawImageOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-image-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//filter?": {
		Doc:   "Get *ebiten.DrawImageOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-draw-image-options//geo-m!": {
		Doc:   "Set *ebiten.DrawImageOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-image-options//geo-m?": {
		Doc:   "Get *ebiten.DrawImageOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawImageOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-image-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//address!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Address value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Address
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Address)
				}
				if natOk && natValOk {
					self.Address = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//address!: arg 2: expected integer")
					}
					self.Address = ebiten.Address(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//address?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Address value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//address?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Address)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//anti-alias!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//anti-alias?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//blend!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//blend?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//color-m!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//color-m?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//color-scale-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.ColorScaleMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.ColorScaleMode)
				}
				if natOk && natValOk {
					self.ColorScaleMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode!: arg 2: expected integer")
					}
					self.ColorScaleMode = ebiten.ColorScaleMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//color-scale-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions ColorScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//color-scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.ColorScaleMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//composite-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//composite-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//fill-rule!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//fill-rule?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-options//filter!": {
		Doc:   "Set *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-options//filter?": {
		Doc:   "Get *ebiten.DrawTrianglesOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//anti-alias!": {
		Doc:   "Set *ebiten.DrawTrianglesShaderOptions AntiAlias value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias!: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AntiAlias = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//anti-alias?": {
		Doc:   "Get *ebiten.DrawTrianglesShaderOptions AntiAlias value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias?: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//anti-alias?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AntiAlias))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//blend!": {
		Doc:   "Set *ebiten.DrawTrianglesShaderOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend!: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//blend?": {
		Doc:   "Get *ebiten.DrawTrianglesShaderOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend?: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//composite-mode!": {
		Doc:   "Set *ebiten.DrawTrianglesShaderOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode!: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//composite-mode?": {
		Doc:   "Get *ebiten.DrawTrianglesShaderOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode?: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//fill-rule!": {
		Doc:   "Set *ebiten.DrawTrianglesShaderOptions FillRule value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule!: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.FillRule
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.FillRule)
				}
				if natOk && natValOk {
					self.FillRule = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule!: arg 2: expected integer")
					}
					self.FillRule = ebiten.FillRule(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//fill-rule?": {
		Doc:   "Get *ebiten.DrawTrianglesShaderOptions FillRule value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule?: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//fill-rule?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillRule)))
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//images!": {
		Doc:   "Set *ebiten.DrawTrianglesShaderOptions Images value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Images = make([]*ebiten.Image, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Images[i], ok = v.Value.(*ebiten.Image)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 2: block item: expected native of type *ebiten.Image")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Images[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Images, ok = v.Value.([]*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 2: expected native of type []*ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 2: expected integer to be 0 or nil")
				}
				self.Images = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//images!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//images?": {
		Doc:   "Get *ebiten.DrawTrianglesShaderOptions Images value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//images?: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//images?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//images?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Images))
				for i, it := range self.Images {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-ebiten-image")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//uniforms!": {
		Doc:   "Set *ebiten.DrawTrianglesShaderOptions Uniforms value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected block to have length of multiple of 2")
				}
				self.Uniforms = make(map[string]any, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: map key: expected string")
					}
					var mapV any
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native")
					}
					self.Uniforms[mapK] = mapV
				}
			case env.Dict:
				self.Uniforms = make(map[string]any, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV any
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: map value: expected native")
					}
					self.Uniforms[mapK] = mapV
				}
			case env.Native:
				var ok bool
				self.Uniforms, ok = v.Value.(map[string]any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected native of type map[string]any")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected integer to be 0 or nil")
				}
				self.Uniforms = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms!: arg 2: expected native, block, dict or nil")
			}
			return arg0
		},
	},
	"ptr-ebiten-draw-triangles-shader-options//uniforms?": {
		Doc:   "Get *ebiten.DrawTrianglesShaderOptions Uniforms value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.DrawTrianglesShaderOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.DrawTrianglesShaderOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms?: arg 1: expected native of type *ebiten.DrawTrianglesShaderOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-draw-triangles-shader-options//uniforms?: arg 1: expected native")
			}
			var resObj env.Object
			{
				data := make(map[string]any, len(self.Uniforms))
				for mKey, mVal := range self.Uniforms {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "any")
					data[mKey] = dVal
				}
				resObj = *env.NewDict(data)
			}
			return resObj
		},
	},
	"ptr-ebiten-geo-m//apply": {
		Doc:   "(*ebiten.GeoM).Apply",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//apply: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//apply: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//apply: arg 3: expected decimal")
			}
			res0, res1 := arg0Val.Apply(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-ebiten-geo-m//concat": {
		Doc:   "(*ebiten.GeoM).Concat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//concat: arg 1: expected native")
			}
			var arg1Val ebiten.GeoM
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//concat: arg 2: expected native")
			}
			arg0Val.Concat(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//element": {
		Doc:   "(*ebiten.GeoM).Element",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//element: arg 3: expected integer")
			}
			res0 := arg0Val.Element(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//invert": {
		Doc:   "(*ebiten.GeoM).Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//invert: arg 1: expected native")
			}
			arg0Val.Invert()
			return arg0
		},
	},
	"ptr-ebiten-geo-m//is-invertible": {
		Doc:   "(*ebiten.GeoM).IsInvertible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//is-invertible: arg 1: expected native")
			}
			res0 := arg0Val.IsInvertible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//reset": {
		Doc:   "(*ebiten.GeoM).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"ptr-ebiten-geo-m//rotate": {
		Doc:   "(*ebiten.GeoM).Rotate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//rotate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//rotate: arg 2: expected decimal")
			}
			arg0Val.Rotate(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//scale": {
		Doc:   "(*ebiten.GeoM).Scale",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//scale: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//scale: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//scale: arg 3: expected decimal")
			}
			arg0Val.Scale(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//set-element": {
		Doc:   "(*ebiten.GeoM).SetElement",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 3: expected integer")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//set-element: arg 4: expected decimal")
			}
			arg0Val.SetElement(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//skew": {
		Doc:   "(*ebiten.GeoM).Skew",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//skew: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//skew: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//skew: arg 3: expected decimal")
			}
			arg0Val.Skew(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-geo-m//string": {
		Doc:   "(*ebiten.GeoM).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-geo-m//translate": {
		Doc:   "(*ebiten.GeoM).Translate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.GeoM
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected native of type *ebiten.GeoM")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//translate: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//translate: arg 2: expected decimal")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-geo-m//translate: arg 3: expected decimal")
			}
			arg0Val.Translate(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-image//clear": {
		Doc:   "(*ebiten.Image).Clear",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//clear: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//clear: arg 1: expected native")
			}
			arg0Val.Clear()
			return arg0
		},
	},
	"ptr-ebiten-image//draw-image": {
		Doc:   "(*ebiten.Image).DrawImage",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-image: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-image: arg 2: expected native")
			}
			var arg2Val *ebiten.DrawImageOptions
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-image: arg 3: expected native")
			}
			arg0Val.DrawImage(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-ebiten-image//draw-triangles": {
		Doc:   "(*ebiten.Image).DrawTriangles",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 3: expected block, native or nil")
			}
			var arg3Val *ebiten.Image
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 4: expected native")
			}
			var arg4Val *ebiten.DrawTrianglesOptions
			switch v := arg4.(type) {
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.(*ebiten.DrawTrianglesOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected native of type *ebiten.DrawTrianglesOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//draw-triangles: arg 5: expected native")
			}
			arg0Val.DrawTriangles(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-ebiten-image//fill": {
		Doc:   "(*ebiten.Image).Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//fill: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//fill: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//fill: arg 2: expected native")
			}
			arg0Val.Fill(arg1Val)
			return arg0
		},
	},
	"ptr-ebiten-image//size": {
		Doc:   "(*ebiten.Image).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//size: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-image//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-image//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"width":  res0Obj,
				"height": res1Obj,
			})
		},
	},
	"ptr-ebiten-key//unmarshal-text": {
		Doc:   "(*ebiten.Key).UnmarshalText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Key
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Key)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected native of type *ebiten.Key")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-key//unmarshal-text: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-key//unmarshal-text: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.UnmarshalText(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//device-scale-factor": {
		Doc:   "(*ebiten.MonitorType).DeviceScaleFactor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-monitor-type//device-scale-factor: arg 1: expected native")
			}
			res0 := arg0Val.DeviceScaleFactor()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//name": {
		Doc:   "(*ebiten.MonitorType).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-monitor-type//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-ebiten-monitor-type//size": {
		Doc:   "(*ebiten.MonitorType).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.MonitorType
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.MonitorType)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected native of type *ebiten.MonitorType")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-monitor-type//size: arg 1: expected native")
			}
			res0, res1 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-ebiten-run-game-options//graphics-library!": {
		Doc:   "Set *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.GraphicsLibrary
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.GraphicsLibrary)
				}
				if natOk && natValOk {
					self.GraphicsLibrary = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-ebiten-run-game-options//graphics-library!: arg 2: expected integer")
					}
					self.GraphicsLibrary = ebiten.GraphicsLibrary(u)
				}
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//graphics-library?": {
		Doc:   "Get *ebiten.RunGameOptions GraphicsLibrary value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//graphics-library?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.GraphicsLibrary)))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//init-unfocused!": {
		Doc:   "Set *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.InitUnfocused = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//init-unfocused!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//init-unfocused?": {
		Doc:   "Get *ebiten.RunGameOptions InitUnfocused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//init-unfocused?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.InitUnfocused))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//screen-transparent!": {
		Doc:   "Set *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScreenTransparent = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//screen-transparent!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//screen-transparent?": {
		Doc:   "Get *ebiten.RunGameOptions ScreenTransparent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//screen-transparent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScreenTransparent))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//single-thread!": {
		Doc:   "Set *ebiten.RunGameOptions SingleThread value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SingleThread = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//single-thread!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//single-thread?": {
		Doc:   "Get *ebiten.RunGameOptions SingleThread value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//single-thread?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleThread))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//skip-taskbar!": {
		Doc:   "Set *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.SkipTaskbar = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//skip-taskbar!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//skip-taskbar?": {
		Doc:   "Get *ebiten.RunGameOptions SkipTaskbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//skip-taskbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SkipTaskbar))
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//x-11-class-name!": {
		Doc:   "Set *ebiten.RunGameOptions X11ClassName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11ClassName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-class-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//x-11-class-name?": {
		Doc:   "Get *ebiten.RunGameOptions X11ClassName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-class-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11ClassName)
			return resObj
		},
	},
	"ptr-ebiten-run-game-options//x-11-instance-name!": {
		Doc:   "Set *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.X11InstanceName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-ebiten-run-game-options//x-11-instance-name?": {
		Doc:   "Get *ebiten.RunGameOptions X11InstanceName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.RunGameOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.RunGameOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected native of type *ebiten.RunGameOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-run-game-options//x-11-instance-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.X11InstanceName)
			return resObj
		},
	},
	"ptr-ebiten-shader//deallocate": {
		Doc:   "(*ebiten.Shader).Deallocate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-shader//deallocate: arg 1: expected native")
			}
			arg0Val.Deallocate()
			return arg0
		},
	},
	"ptr-ebiten-shader//dispose": {
		Doc:   "(*ebiten.Shader).Dispose",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Shader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Shader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected native of type *ebiten.Shader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-shader//dispose: arg 1: expected native")
			}
			arg0Val.Dispose()
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-a!": {
		Doc:   "Set *ebiten.Vertex ColorA value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-a!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorA = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-a!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-a?": {
		Doc:   "Get *ebiten.Vertex ColorA value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-a?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorA))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-b!": {
		Doc:   "Set *ebiten.Vertex ColorB value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-b!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorB = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-b!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-b?": {
		Doc:   "Get *ebiten.Vertex ColorB value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-b?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorB))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-g!": {
		Doc:   "Set *ebiten.Vertex ColorG value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-g!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorG = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-g!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-g?": {
		Doc:   "Get *ebiten.Vertex ColorG value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-g?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorG))
			return resObj
		},
	},
	"ptr-ebiten-vertex//color-r!": {
		Doc:   "Set *ebiten.Vertex ColorR value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-r!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.ColorR = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-r!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//color-r?": {
		Doc:   "Get *ebiten.Vertex ColorR value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//color-r?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.ColorR))
			return resObj
		},
	},
	"ptr-ebiten-vertex//dst-x!": {
		Doc:   "Set *ebiten.Vertex DstX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//dst-x?": {
		Doc:   "Get *ebiten.Vertex DstX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstX))
			return resObj
		},
	},
	"ptr-ebiten-vertex//dst-y!": {
		Doc:   "Set *ebiten.Vertex DstY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DstY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//dst-y?": {
		Doc:   "Get *ebiten.Vertex DstY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//dst-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DstY))
			return resObj
		},
	},
	"ptr-ebiten-vertex//src-x!": {
		Doc:   "Set *ebiten.Vertex SrcX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//src-x?": {
		Doc:   "Get *ebiten.Vertex SrcX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcX))
			return resObj
		},
	},
	"ptr-ebiten-vertex//src-y!": {
		Doc:   "Set *ebiten.Vertex SrcY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.SrcY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vertex//src-y?": {
		Doc:   "Get *ebiten.Vertex SrcY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.Vertex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected native of type *ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vertex//src-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.SrcY))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//duration!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//duration?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//strong-magnitude!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrongMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//strong-magnitude?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions StrongMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//strong-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrongMagnitude))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//weak-magnitude!": {
		Doc:   "Set *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.WeakMagnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-gamepad-options//weak-magnitude?": {
		Doc:   "Get *ebiten.VibrateGamepadOptions WeakMagnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateGamepadOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateGamepadOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native of type *ebiten.VibrateGamepadOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-gamepad-options//weak-magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeakMagnitude))
			return resObj
		},
	},
	"ptr-ebiten-vibrate-options//duration!": {
		Doc:   "Set *ebiten.VibrateOptions Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-options//duration?": {
		Doc:   "Get *ebiten.VibrateOptions Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-ebiten-vibrate-options//magnitude!": {
		Doc:   "Set *ebiten.VibrateOptions Magnitude value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Magnitude = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//magnitude!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-ebiten-vibrate-options//magnitude?": {
		Doc:   "Get *ebiten.VibrateOptions Magnitude value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *ebiten.VibrateOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*ebiten.VibrateOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected native of type *ebiten.VibrateOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-ebiten-vibrate-options//magnitude?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Magnitude))
			return resObj
		},
	},
	"ptr-mp-3-stream//length": {
		Doc:   "(*mp3.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//length: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-mp-3-stream//read": {
		Doc:   "(*mp3.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-mp-3-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-mp-3-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-mp-3-stream//seek": {
		Doc:   "(*mp3.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *mp3.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*mp3.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//seek: arg 1: expected native of type *mp3.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mp-3-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-mp-3-stream//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-text-1-draw-options//blend!": {
		Doc:   "Set *text_1.DrawOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//blend!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//blend!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//blend?": {
		Doc:   "Get *text_1.DrawOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//blend?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//blend?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"ptr-text-1-draw-options//color-m!": {
		Doc:   "Set *text_1.DrawOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-m!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//color-m?": {
		Doc:   "Get *text_1.DrawOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-m?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"ptr-text-1-draw-options//color-scale!": {
		Doc:   "Set *text_1.DrawOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-scale!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//color-scale?": {
		Doc:   "Get *text_1.DrawOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-scale?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//color-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"ptr-text-1-draw-options//composite-mode!": {
		Doc:   "Set *text_1.DrawOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-draw-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//composite-mode?": {
		Doc:   "Get *text_1.DrawOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//composite-mode?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//composite-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"ptr-text-1-draw-options//filter!": {
		Doc:   "Set *text_1.DrawOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//filter!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-draw-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//filter?": {
		Doc:   "Get *text_1.DrawOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//filter?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"ptr-text-1-draw-options//geo-m!": {
		Doc:   "Set *text_1.DrawOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//geo-m!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//geo-m!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//geo-m?": {
		Doc:   "Get *text_1.DrawOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//geo-m?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//geo-m?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"ptr-text-1-draw-options//line-spacing!": {
		Doc:   "Set *text_1.DrawOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//line-spacing?": {
		Doc:   "Get *text_1.DrawOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//line-spacing?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//line-spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"ptr-text-1-draw-options//primary-align!": {
		Doc:   "Set *text_1.DrawOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//primary-align!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//primary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-draw-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//primary-align?": {
		Doc:   "Get *text_1.DrawOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//primary-align?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//primary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-draw-options//secondary-align!": {
		Doc:   "Set *text_1.DrawOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-draw-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-draw-options//secondary-align?": {
		Doc:   "Get *text_1.DrawOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//secondary-align?: arg 1: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-draw-options//secondary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-draw-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-glyph//end-index-in-bytes!": {
		Doc:   "Set *text_1.Glyph EndIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.EndIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//end-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//end-index-in-bytes?": {
		Doc:   "Get *text_1.Glyph EndIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//end-index-in-bytes?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//end-index-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//end-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.EndIndexInBytes))
			return resObj
		},
	},
	"ptr-text-1-glyph//gid!": {
		Doc:   "Set *text_1.Glyph GID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//gid!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//gid!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//gid!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.GID = uint32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//gid!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//gid?": {
		Doc:   "Get *text_1.Glyph GID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//gid?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//gid?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//gid?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.GID))
			return resObj
		},
	},
	"ptr-text-1-glyph//image!": {
		Doc:   "Set *text_1.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//image!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//image?": {
		Doc:   "Get *text_1.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//image?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"ptr-text-1-glyph//start-index-in-bytes!": {
		Doc:   "Set *text_1.Glyph StartIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StartIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//start-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//start-index-in-bytes?": {
		Doc:   "Get *text_1.Glyph StartIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//start-index-in-bytes?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//start-index-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//start-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StartIndexInBytes))
			return resObj
		},
	},
	"ptr-text-1-glyph//x!": {
		Doc:   "Set *text_1.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//x!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//x?": {
		Doc:   "Get *text_1.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//x?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-text-1-glyph//y!": {
		Doc:   "Set *text_1.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//y!: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-glyph//y?": {
		Doc:   "Get *text_1.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//y?: arg 1: expected native of type *text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-glyph//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-text-1-go-text-face//direction!": {
		Doc:   "Set *text_1.GoTextFace Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//direction!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//direction!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//direction!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Direction
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Direction)
				}
				if natOk && natValOk {
					self.Direction = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-go-text-face//direction!: arg 2: expected integer")
					}
					self.Direction = text_1.Direction(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//direction?": {
		Doc:   "Get *text_1.GoTextFace Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//direction?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//direction?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//direction?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Direction)))
			return resObj
		},
	},
	"ptr-text-1-go-text-face//language!": {
		Doc:   "Set *text_1.GoTextFace Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//language!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//language!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//language!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Language, ok = v.Value.(language.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//language!: arg 2: expected native of type language.Tag")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//language!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//language?": {
		Doc:   "Get *text_1.GoTextFace Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//language?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//language?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//language?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Language, "language-tag")
			return resObj
		},
	},
	"ptr-text-1-go-text-face//metrics": {
		Doc:   "(*text_1.GoTextFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//metrics: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"ptr-text-1-go-text-face//remove-feature": {
		Doc:   "(*text_1.GoTextFace).RemoveFeature",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-go-text-face//remove-feature: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			arg0Val.RemoveFeature(arg1Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//remove-variation": {
		Doc:   "(*text_1.GoTextFace).RemoveVariation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-go-text-face//remove-variation: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			arg0Val.RemoveVariation(arg1Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//script!": {
		Doc:   "Set *text_1.GoTextFace Script value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//script!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//script!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//script!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Script, ok = v.Value.(language.Script)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//script!: arg 2: expected native of type language.Script")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//script!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//script?": {
		Doc:   "Get *text_1.GoTextFace Script value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//script?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//script?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//script?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Script, "language-script")
			return resObj
		},
	},
	"ptr-text-1-go-text-face//set-feature": {
		Doc:   "(*text_1.GoTextFace).SetFeature",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//set-feature: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//set-feature: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//set-feature: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-go-text-face//set-feature: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			var arg2Val uint32
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = uint32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//set-feature: arg 3: expected integer")
			}
			arg0Val.SetFeature(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//set-variation": {
		Doc:   "(*text_1.GoTextFace).SetVariation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//set-variation: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//set-variation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//set-variation: arg 1: expected native")
			}
			var arg1Val text_1.Tag
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-go-text-face//set-variation: arg 2: expected integer")
					}
					arg1Val = text_1.Tag(u)
				}
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//set-variation: arg 3: expected decimal")
			}
			arg0Val.SetVariation(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-1-go-text-face//size!": {
		Doc:   "Set *text_1.GoTextFace Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//size!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Size = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//size?": {
		Doc:   "Get *text_1.GoTextFace Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//size?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Size))
			return resObj
		},
	},
	"ptr-text-1-go-text-face//source!": {
		Doc:   "Set *text_1.GoTextFace Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//source!: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(*text_1.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//source!: arg 2: expected native of type *text_1.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//source!: arg 2: expected integer to be 0 or nil")
				}
				self.Source = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-1-go-text-face//source?": {
		Doc:   "Get *text_1.GoTextFace Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//source?: arg 1: expected native of type *text_1.GoTextFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-go-text-face//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-go-text-face//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "ptr-text-1-go-text-face-source")
			return resObj
		},
	},
	"ptr-text-1-layout-options//line-spacing!": {
		Doc:   "Set *text_1.LayoutOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-layout-options//line-spacing?": {
		Doc:   "Get *text_1.LayoutOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//line-spacing?: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//line-spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"ptr-text-1-layout-options//primary-align!": {
		Doc:   "Set *text_1.LayoutOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//primary-align!: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//primary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-layout-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-layout-options//primary-align?": {
		Doc:   "Get *text_1.LayoutOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//primary-align?: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//primary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-layout-options//secondary-align!": {
		Doc:   "Set *text_1.LayoutOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-layout-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-layout-options//secondary-align?": {
		Doc:   "Get *text_1.LayoutOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//secondary-align?: arg 1: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-layout-options//secondary-align?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-layout-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"ptr-text-1-limited-face//add-unicode-range": {
		Doc:   "(*text_1.LimitedFace).AddUnicodeRange",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.LimitedFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 1: expected native of type *text_1.LimitedFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 2: expected native")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 3: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-limited-face//add-unicode-range: arg 3: expected native")
			}
			arg0Val.AddUnicodeRange(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-1-limited-face//metrics": {
		Doc:   "(*text_1.LimitedFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.LimitedFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.LimitedFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-limited-face//metrics: arg 1: expected native of type *text_1.LimitedFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-limited-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-limited-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"ptr-text-1-metadata//family!": {
		Doc:   "Set *text_1.Metadata Family value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//family!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//family!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//family!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Family = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//family!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//family?": {
		Doc:   "Get *text_1.Metadata Family value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//family?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//family?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//family?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Family)
			return resObj
		},
	},
	"ptr-text-1-metadata//stretch!": {
		Doc:   "Set *text_1.Metadata Stretch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//stretch!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//stretch!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//stretch!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Stretch
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Stretch)
				}
				if natOk && natValOk {
					self.Stretch = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-metadata//stretch!: arg 2: expected decimal")
					}
					self.Stretch = text_1.Stretch(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//stretch?": {
		Doc:   "Get *text_1.Metadata Stretch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//stretch?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//stretch?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//stretch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Stretch)))
			return resObj
		},
	},
	"ptr-text-1-metadata//style!": {
		Doc:   "Set *text_1.Metadata Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//style!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//style!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Style
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Style)
				}
				if natOk && natValOk {
					self.Style = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-metadata//style!: arg 2: expected integer")
					}
					self.Style = text_1.Style(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//style?": {
		Doc:   "Get *text_1.Metadata Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//style?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Style)))
			return resObj
		},
	},
	"ptr-text-1-metadata//weight!": {
		Doc:   "Set *text_1.Metadata Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//weight!: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//weight!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//weight!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Weight
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Weight)
				}
				if natOk && natValOk {
					self.Weight = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-text-1-metadata//weight!: arg 2: expected decimal")
					}
					self.Weight = text_1.Weight(u)
				}
			}
			return arg0
		},
	},
	"ptr-text-1-metadata//weight?": {
		Doc:   "Get *text_1.Metadata Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//weight?: arg 1: expected native of type *text_1.Metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metadata//weight?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metadata//weight?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Weight)))
			return resObj
		},
	},
	"ptr-text-1-metrics//h-ascent!": {
		Doc:   "Set *text_1.Metrics HAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-ascent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//h-ascent?": {
		Doc:   "Get *text_1.Metrics HAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-ascent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HAscent))
			return resObj
		},
	},
	"ptr-text-1-metrics//h-descent!": {
		Doc:   "Set *text_1.Metrics HDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-descent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//h-descent?": {
		Doc:   "Get *text_1.Metrics HDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-descent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HDescent))
			return resObj
		},
	},
	"ptr-text-1-metrics//h-line-gap!": {
		Doc:   "Set *text_1.Metrics HLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//h-line-gap?": {
		Doc:   "Get *text_1.Metrics HLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-line-gap?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//h-line-gap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//h-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HLineGap))
			return resObj
		},
	},
	"ptr-text-1-metrics//v-ascent!": {
		Doc:   "Set *text_1.Metrics VAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-ascent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//v-ascent?": {
		Doc:   "Get *text_1.Metrics VAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-ascent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VAscent))
			return resObj
		},
	},
	"ptr-text-1-metrics//v-descent!": {
		Doc:   "Set *text_1.Metrics VDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-descent!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//v-descent?": {
		Doc:   "Get *text_1.Metrics VDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-descent?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VDescent))
			return resObj
		},
	},
	"ptr-text-1-metrics//v-line-gap!": {
		Doc:   "Set *text_1.Metrics VLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-1-metrics//v-line-gap?": {
		Doc:   "Get *text_1.Metrics VLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-line-gap?: arg 1: expected native of type *text_1.Metrics")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-metrics//v-line-gap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-metrics//v-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VLineGap))
			return resObj
		},
	},
	"ptr-text-1-multi-face//metrics": {
		Doc:   "(*text_1.MultiFace).Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *text_1.MultiFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text_1.MultiFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-multi-face//metrics: arg 1: expected native of type *text_1.MultiFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-1-multi-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-1-multi-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"ptr-text-glyph//image!": {
		Doc:   "Set *text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-glyph//image?": {
		Doc:   "Get *text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"ptr-text-glyph//rune!": {
		Doc:   "Set *text.Glyph Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//rune!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//rune!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-text-glyph//rune?": {
		Doc:   "Get *text.Glyph Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//rune?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//rune?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"ptr-text-glyph//x!": {
		Doc:   "Set *text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-glyph//x?": {
		Doc:   "Get *text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-text-glyph//y!": {
		Doc:   "Set *text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-text-glyph//y?": {
		Doc:   "Get *text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-text-glyph//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-text-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-textinput-state//committed!": {
		Doc:   "Set *textinput.State Committed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//committed!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Committed = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//committed!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//committed?": {
		Doc:   "Get *textinput.State Committed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//committed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//committed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Committed))
			return resObj
		},
	},
	"ptr-textinput-state//composition-selection-end-in-bytes!": {
		Doc:   "Set *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionEndInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//composition-selection-end-in-bytes?": {
		Doc:   "Get *textinput.State CompositionSelectionEndInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-end-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionEndInBytes))
			return resObj
		},
	},
	"ptr-textinput-state//composition-selection-start-in-bytes!": {
		Doc:   "Set *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionStartInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-textinput-state//composition-selection-start-in-bytes?": {
		Doc:   "Get *textinput.State CompositionSelectionStartInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//composition-selection-start-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionStartInBytes))
			return resObj
		},
	},
	"ptr-textinput-state//error!": {
		Doc:   "Set *textinput.State Error value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//error!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.String:
				self.Error = errors.New(v.Value)
			case env.Error:
				self.Error = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error!: arg 2: expected integer to be 0 or nil")
				}
				self.Error = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//error!: arg 2: expected error, string or nil")
			}
			return arg0
		},
	},
	"ptr-textinput-state//error?": {
		Doc:   "Get *textinput.State Error value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//error?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//error?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewError(self.Error.Error())
			return resObj
		},
	},
	"ptr-textinput-state//text!": {
		Doc:   "Set *textinput.State Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text!: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-textinput-state//text?": {
		Doc:   "Get *textinput.State Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text?: arg 1: expected native of type *textinput.State")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-textinput-state//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-textinput-state//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-twenty-48-game//draw": {
		Doc:   "(*twenty48.Game).Draw",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//draw: arg 1: expected native")
			}
			var arg1Val *ebiten.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//draw: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//draw: arg 2: expected native")
			}
			arg0Val.Draw(arg1Val)
			return arg0
		},
	},
	"ptr-twenty-48-game//layout": {
		Doc:   "(*twenty48.Game).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//layout: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//layout: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//layout: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//layout: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Layout(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"screen-width":  res0Obj,
				"screen-height": res1Obj,
			})
		},
	},
	"ptr-twenty-48-game//update": {
		Doc:   "(*twenty48.Game).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Game
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Game)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//update: arg 1: expected native of type *twenty48.Game")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-game//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-game//update: arg 1: expected native")
			}
			res0 := arg0Val.Update()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-twenty-48-input//dir": {
		Doc:   "(*twenty48.Input).Dir",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//dir: arg 1: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//dir: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-input//dir: arg 1: expected native")
			}
			res0, res1 := arg0Val.Dir()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-twenty-48-input//update": {
		Doc:   "(*twenty48.Input).Update",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Input
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Input)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//update: arg 1: expected native of type *twenty48.Input")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-input//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-input//update: arg 1: expected native")
			}
			arg0Val.Update()
			return arg0
		},
	},
	"ptr-twenty-48-tile//is-moving": {
		Doc:   "(*twenty48.Tile).IsMoving",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//is-moving: arg 1: expected native")
			}
			res0 := arg0Val.IsMoving()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-twenty-48-tile//next-pos": {
		Doc:   "(*twenty48.Tile).NextPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//next-pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.NextPos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-twenty-48-tile//next-value": {
		Doc:   "(*twenty48.Tile).NextValue",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//next-value: arg 1: expected native")
			}
			res0 := arg0Val.NextValue()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-twenty-48-tile//pos": {
		Doc:   "(*twenty48.Tile).Pos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.Pos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-twenty-48-tile//value": {
		Doc:   "(*twenty48.Tile).Value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *twenty48.Tile
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*twenty48.Tile)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//value: arg 1: expected native of type *twenty48.Tile")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-twenty-48-tile//value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-twenty-48-tile//value: arg 1: expected native")
			}
			res0 := arg0Val.Value()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-vector-path//append-vertices-and-indices-for-filling": {
		Doc:   "(*vector.Path).AppendVerticesAndIndicesForFilling",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-filling: arg 3: expected block, native or nil")
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForFilling(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-vertex")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-vector-path//append-vertices-and-indices-for-stroke": {
		Doc:   "(*vector.Path).AppendVerticesAndIndicesForStroke",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 1: expected native")
			}
			var arg1Val []ebiten.Vertex
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]ebiten.Vertex, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(ebiten.Vertex)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: block item: expected native of type ebiten.Vertex")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]ebiten.Vertex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected native of type []ebiten.Vertex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 2: expected block, native or nil")
			}
			var arg2Val []uint16
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]uint16, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]uint16)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected native of type []uint16")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 3: expected block, native or nil")
			}
			var arg3Val *vector.StrokeOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//append-vertices-and-indices-for-stroke: arg 4: expected native")
			}
			res0, res1 := arg0Val.AppendVerticesAndIndicesForStroke(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "ebiten-vertex")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewInteger(int64(it))
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"ptr-vector-path//close": {
		Doc:   "(*vector.Path).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//close: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//close: arg 1: expected native")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"ptr-vector-path//line-to": {
		Doc:   "(*vector.Path).LineTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//line-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//line-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//line-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//line-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//line-to: arg 3: expected decimal")
			}
			arg0Val.LineTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-vector-path//move-to": {
		Doc:   "(*vector.Path).MoveTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//move-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//move-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//move-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//move-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//move-to: arg 3: expected decimal")
			}
			arg0Val.MoveTo(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-vector-path//quad-to": {
		Doc:   "(*vector.Path).QuadTo",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//quad-to: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-path//quad-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-path//quad-to: arg 5: expected decimal")
			}
			arg0Val.QuadTo(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-cap!": {
		Doc:   "Set *vector.StrokeOptions LineCap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-cap!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineCap
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineCap)
				}
				if natOk && natValOk {
					self.LineCap = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-stroke-options//line-cap!: arg 2: expected integer")
					}
					self.LineCap = vector.LineCap(u)
				}
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-cap?": {
		Doc:   "Get *vector.StrokeOptions LineCap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-cap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineCap)))
			return resObj
		},
	},
	"ptr-vector-stroke-options//line-join!": {
		Doc:   "Set *vector.StrokeOptions LineJoin value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-join!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineJoin
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineJoin)
				}
				if natOk && natValOk {
					self.LineJoin = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-vector-stroke-options//line-join!: arg 2: expected integer")
					}
					self.LineJoin = vector.LineJoin(u)
				}
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//line-join?": {
		Doc:   "Get *vector.StrokeOptions LineJoin value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//line-join?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineJoin)))
			return resObj
		},
	},
	"ptr-vector-stroke-options//miter-limit!": {
		Doc:   "Set *vector.StrokeOptions MiterLimit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.MiterLimit = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//miter-limit!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//miter-limit?": {
		Doc:   "Get *vector.StrokeOptions MiterLimit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//miter-limit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.MiterLimit))
			return resObj
		},
	},
	"ptr-vector-stroke-options//width!": {
		Doc:   "Set *vector.StrokeOptions Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-vector-stroke-options//width?": {
		Doc:   "Get *vector.StrokeOptions Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected native of type *vector.StrokeOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vector-stroke-options//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"ptr-vorbis-stream//length": {
		Doc:   "(*vorbis.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//length: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-vorbis-stream//read": {
		Doc:   "(*vorbis.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-vorbis-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-vorbis-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-vorbis-stream//seek": {
		Doc:   "(*vorbis.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vorbis.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vorbis.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//seek: arg 1: expected native of type *vorbis.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-vorbis-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-vorbis-stream//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-wav-stream//length": {
		Doc:   "(*wav.Stream).Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//length: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-wav-stream//read": {
		Doc:   "(*wav.Stream).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-wav-stream//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-wav-stream//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//read: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"ptr-wav-stream//seek": {
		Doc:   "(*wav.Stream).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *wav.Stream
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*wav.Stream)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//seek: arg 1: expected native of type *wav.Stream")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-wav-stream//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-wav-stream//seek: arg 3: expected integer")
			}
			res0, res1 := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"shader-1-gopher-bg-png": {
		Doc:   "Get shader_1.GopherBg_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.GopherBg_png))
				for i, it := range shader_1.GopherBg_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"shader-1-gopher-png": {
		Doc:   "Get shader_1.Gopher_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.Gopher_png))
				for i, it := range shader_1.Gopher_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"shader-1-noise-png": {
		Doc:   "Get shader_1.Noise_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.Noise_png))
				for i, it := range shader_1.Noise_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"shader-1-normal-png": {
		Doc:   "Get shader_1.Normal_png value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				items := make([]env.Object, len(shader_1.Normal_png))
				for i, it := range shader_1.Normal_png {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"text-1-advance": {
		Doc:   "text_1.Advance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-advance: arg 1: expected string")
			}
			var arg1Val text_1.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-advance: arg 2: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-advance: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-advance: arg 2: expected native")
			}
			res0 := text_1.Advance(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-1-align-center": {
		Doc:   "Get text_1.AlignCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.AlignCenter)))
			return resObj
		},
	},
	"text-1-align-end": {
		Doc:   "Get text_1.AlignEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.AlignEnd)))
			return resObj
		},
	},
	"text-1-align-start": {
		Doc:   "Get text_1.AlignStart value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.AlignStart)))
			return resObj
		},
	},
	"text-1-append-glyphs": {
		Doc:   "text_1.AppendGlyphs",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []text_1.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text_1.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text_1.Glyph)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("text-1-append-glyphs: arg 1: block item: expected native of type text_1.Glyph")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("text-1-append-glyphs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-append-glyphs: arg 1: expected native of type []text_1.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-append-glyphs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-append-glyphs: arg 1: expected block, native or nil")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-append-glyphs: arg 2: expected string")
			}
			var arg2Val text_1.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-append-glyphs: arg 3: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-append-glyphs: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-append-glyphs: arg 3: expected native")
			}
			var arg3Val *text_1.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-append-glyphs: arg 4: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-append-glyphs: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-append-glyphs: arg 4: expected native")
			}
			res0 := text_1.AppendGlyphs(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "text-1-glyph")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"text-1-append-vector-path": {
		Doc:   "text_1.AppendVectorPath",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *vector.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-append-vector-path: arg 1: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-append-vector-path: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-append-vector-path: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-append-vector-path: arg 2: expected string")
			}
			var arg2Val text_1.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-append-vector-path: arg 3: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-append-vector-path: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-append-vector-path: arg 3: expected native")
			}
			var arg3Val *text_1.LayoutOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-append-vector-path: arg 4: expected native of type *text_1.LayoutOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-append-vector-path: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-append-vector-path: arg 4: expected native")
			}
			text_1.AppendVectorPath(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-1-cache-glyphs": {
		Doc:   "text_1.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-cache-glyphs: arg 1: expected string")
			}
			var arg1Val text_1.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-cache-glyphs: arg 2: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-cache-glyphs: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-cache-glyphs: arg 2: expected native")
			}
			text_1.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"text-1-direction-left-to-right": {
		Doc:   "Get text_1.DirectionLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionLeftToRight)))
			return resObj
		},
	},
	"text-1-direction-right-to-left": {
		Doc:   "Get text_1.DirectionRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionRightToLeft)))
			return resObj
		},
	},
	"text-1-direction-top-to-bottom-and-left-to-right": {
		Doc:   "Get text_1.DirectionTopToBottomAndLeftToRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionTopToBottomAndLeftToRight)))
			return resObj
		},
	},
	"text-1-direction-top-to-bottom-and-right-to-left": {
		Doc:   "Get text_1.DirectionTopToBottomAndRightToLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(text_1.DirectionTopToBottomAndRightToLeft)))
			return resObj
		},
	},
	"text-1-draw": {
		Doc:   "text_1.Draw",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-draw: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-draw: arg 2: expected string")
			}
			var arg2Val text_1.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw: arg 3: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-draw: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw: arg 3: expected native")
			}
			var arg3Val *text_1.DrawOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw: arg 4: expected native of type *text_1.DrawOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-draw: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw: arg 4: expected native")
			}
			text_1.Draw(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-1-draw-options//blend!": {
		Doc:   "Set text_1.DrawOptions Blend value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//blend!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//blend!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Blend, ok = v.Value.(ebiten.Blend)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//blend!: arg 2: expected native of type ebiten.Blend")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//blend!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//blend?": {
		Doc:   "Get text_1.DrawOptions Blend value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//blend?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//blend?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Blend, "ebiten-blend")
			return resObj
		},
	},
	"text-1-draw-options//color-m!": {
		Doc:   "Set text_1.DrawOptions ColorM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//color-m!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//color-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorM, ok = v.Value.(ebiten.ColorM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//color-m!: arg 2: expected native of type ebiten.ColorM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//color-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//color-m?": {
		Doc:   "Get text_1.DrawOptions ColorM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//color-m?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//color-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorM, "ebiten-color-m")
			return resObj
		},
	},
	"text-1-draw-options//color-scale!": {
		Doc:   "Set text_1.DrawOptions ColorScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//color-scale!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//color-scale!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorScale, ok = v.Value.(ebiten.ColorScale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//color-scale!: arg 2: expected native of type ebiten.ColorScale")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//color-scale!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//color-scale?": {
		Doc:   "Get text_1.DrawOptions ColorScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//color-scale?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//color-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorScale, "ebiten-color-scale")
			return resObj
		},
	},
	"text-1-draw-options//composite-mode!": {
		Doc:   "Set text_1.DrawOptions CompositeMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//composite-mode!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//composite-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.CompositeMode
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.CompositeMode)
				}
				if natOk && natValOk {
					self.CompositeMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-draw-options//composite-mode!: arg 2: expected integer")
					}
					self.CompositeMode = ebiten.CompositeMode(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//composite-mode?": {
		Doc:   "Get text_1.DrawOptions CompositeMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//composite-mode?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//composite-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.CompositeMode)))
			return resObj
		},
	},
	"text-1-draw-options//filter!": {
		Doc:   "Set text_1.DrawOptions Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//filter!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//filter!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal ebiten.Filter
				if natOk {
					natVal, natValOk = nat.Value.(ebiten.Filter)
				}
				if natOk && natValOk {
					self.Filter = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-draw-options//filter!: arg 2: expected integer")
					}
					self.Filter = ebiten.Filter(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//filter?": {
		Doc:   "Get text_1.DrawOptions Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//filter?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Filter)))
			return resObj
		},
	},
	"text-1-draw-options//geo-m!": {
		Doc:   "Set text_1.DrawOptions GeoM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//geo-m!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//geo-m!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.GeoM, ok = v.Value.(ebiten.GeoM)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//geo-m!: arg 2: expected native of type ebiten.GeoM")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//geo-m!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-draw-options//geo-m?": {
		Doc:   "Get text_1.DrawOptions GeoM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//geo-m?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//geo-m?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.GeoM, "ebiten-geo-m")
			return resObj
		},
	},
	"text-1-draw-options//line-spacing!": {
		Doc:   "Set text_1.DrawOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//line-spacing!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-draw-options//line-spacing?": {
		Doc:   "Get text_1.DrawOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//line-spacing?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"text-1-draw-options//primary-align!": {
		Doc:   "Set text_1.DrawOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//primary-align!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-draw-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//primary-align?": {
		Doc:   "Get text_1.DrawOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//primary-align?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"text-1-draw-options//secondary-align!": {
		Doc:   "Set text_1.DrawOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//secondary-align!: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-draw-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-draw-options//secondary-align?": {
		Doc:   "Get text_1.DrawOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.DrawOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.DrawOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-draw-options//secondary-align?: arg 1: expected native of type text_1.DrawOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-draw-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"text-1-face//advance": {
		Doc:   "text_1.Face.advance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//advance: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//advance: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//advance: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-face//advance: arg 2: expected string")
			}
			res0 := arg0Val.advance(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-1-face//append-vector-path-for-line": {
		Doc:   "text_1.Face.appendVectorPathForLine",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//append-vector-path-for-line: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//append-vector-path-for-line: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//append-vector-path-for-line: arg 1: expected native")
			}
			var arg1Val *vector.Path
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*vector.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//append-vector-path-for-line: arg 2: expected native of type *vector.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//append-vector-path-for-line: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//append-vector-path-for-line: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-face//append-vector-path-for-line: arg 3: expected string")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-face//append-vector-path-for-line: arg 4: expected decimal")
			}
			var arg4Val float64
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-face//append-vector-path-for-line: arg 5: expected decimal")
			}
			arg0Val.appendVectorPathForLine(arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"text-1-face//direction": {
		Doc:   "text_1.Face.direction",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//direction: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//direction: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//direction: arg 1: expected native")
			}
			res0 := arg0Val.direction()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"text-1-face//has-glyph": {
		Doc:   "text_1.Face.hasGlyph",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//has-glyph: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//has-glyph: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//has-glyph: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//has-glyph: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//has-glyph: arg 2: expected native")
			}
			res0 := arg0Val.hasGlyph(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"text-1-face//metrics": {
		Doc:   "text_1.Face.Metrics",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//metrics: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//metrics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//metrics: arg 1: expected native")
			}
			res0 := arg0Val.Metrics()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-1-metrics")
			return res0Obj
		},
	},
	"text-1-face//private": {
		Doc:   "text_1.Face.private",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-face//private: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-face//private: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-face//private: arg 1: expected native")
			}
			arg0Val.private()
			return arg0
		},
	},
	"text-1-glyph//end-index-in-bytes!": {
		Doc:   "Set text_1.Glyph EndIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//end-index-in-bytes!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//end-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.EndIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//end-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"text-1-glyph//end-index-in-bytes?": {
		Doc:   "Get text_1.Glyph EndIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//end-index-in-bytes?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//end-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.EndIndexInBytes))
			return resObj
		},
	},
	"text-1-glyph//gid!": {
		Doc:   "Set text_1.Glyph GID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//gid!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//gid!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.GID = uint32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//gid!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"text-1-glyph//gid?": {
		Doc:   "Get text_1.Glyph GID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//gid?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//gid?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.GID))
			return resObj
		},
	},
	"text-1-glyph//image!": {
		Doc:   "Set text_1.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//image!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-glyph//image?": {
		Doc:   "Get text_1.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//image?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"text-1-glyph//start-index-in-bytes!": {
		Doc:   "Set text_1.Glyph StartIndexInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//start-index-in-bytes!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//start-index-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StartIndexInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//start-index-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"text-1-glyph//start-index-in-bytes?": {
		Doc:   "Get text_1.Glyph StartIndexInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//start-index-in-bytes?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//start-index-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StartIndexInBytes))
			return resObj
		},
	},
	"text-1-glyph//x!": {
		Doc:   "Set text_1.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//x!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-glyph//x?": {
		Doc:   "Get text_1.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//x?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"text-1-glyph//y!": {
		Doc:   "Set text_1.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//y!: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-glyph//y?": {
		Doc:   "Get text_1.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-glyph//y?: arg 1: expected native of type text_1.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"text-1-go-text-face//direction!": {
		Doc:   "Set text_1.GoTextFace Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//direction!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//direction!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Direction
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Direction)
				}
				if natOk && natValOk {
					self.Direction = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-go-text-face//direction!: arg 2: expected integer")
					}
					self.Direction = text_1.Direction(u)
				}
			}
			return arg0
		},
	},
	"text-1-go-text-face//direction?": {
		Doc:   "Get text_1.GoTextFace Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//direction?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//direction?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Direction)))
			return resObj
		},
	},
	"text-1-go-text-face//language!": {
		Doc:   "Set text_1.GoTextFace Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//language!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//language!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Language, ok = v.Value.(language.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//language!: arg 2: expected native of type language.Tag")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//language!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-go-text-face//language?": {
		Doc:   "Get text_1.GoTextFace Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//language?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//language?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Language, "language-tag")
			return resObj
		},
	},
	"text-1-go-text-face//script!": {
		Doc:   "Set text_1.GoTextFace Script value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//script!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//script!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Script, ok = v.Value.(language.Script)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//script!: arg 2: expected native of type language.Script")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//script!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-go-text-face//script?": {
		Doc:   "Get text_1.GoTextFace Script value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//script?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//script?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Script, "language-script")
			return resObj
		},
	},
	"text-1-go-text-face//size!": {
		Doc:   "Set text_1.GoTextFace Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//size!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Size = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-go-text-face//size?": {
		Doc:   "Get text_1.GoTextFace Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//size?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Size))
			return resObj
		},
	},
	"text-1-go-text-face//source!": {
		Doc:   "Set text_1.GoTextFace Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//source!: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(*text_1.GoTextFaceSource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//source!: arg 2: expected native of type *text_1.GoTextFaceSource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//source!: arg 2: expected integer to be 0 or nil")
				}
				self.Source = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-1-go-text-face//source?": {
		Doc:   "Get text_1.GoTextFace Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.GoTextFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.GoTextFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-go-text-face//source?: arg 1: expected native of type text_1.GoTextFace")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-go-text-face//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "ptr-text-1-go-text-face-source")
			return resObj
		},
	},
	"text-1-layout-options//line-spacing!": {
		Doc:   "Set text_1.LayoutOptions LineSpacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-layout-options//line-spacing!: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//line-spacing!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.LineSpacing = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//line-spacing!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-layout-options//line-spacing?": {
		Doc:   "Get text_1.LayoutOptions LineSpacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-layout-options//line-spacing?: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//line-spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineSpacing))
			return resObj
		},
	},
	"text-1-layout-options//primary-align!": {
		Doc:   "Set text_1.LayoutOptions PrimaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-layout-options//primary-align!: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//primary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.PrimaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-layout-options//primary-align!: arg 2: expected integer")
					}
					self.PrimaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-layout-options//primary-align?": {
		Doc:   "Get text_1.LayoutOptions PrimaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-layout-options//primary-align?: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//primary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.PrimaryAlign)))
			return resObj
		},
	},
	"text-1-layout-options//secondary-align!": {
		Doc:   "Set text_1.LayoutOptions SecondaryAlign value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-layout-options//secondary-align!: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//secondary-align!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Align
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Align)
				}
				if natOk && natValOk {
					self.SecondaryAlign = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-layout-options//secondary-align!: arg 2: expected integer")
					}
					self.SecondaryAlign = text_1.Align(u)
				}
			}
			return arg0
		},
	},
	"text-1-layout-options//secondary-align?": {
		Doc:   "Get text_1.LayoutOptions SecondaryAlign value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.LayoutOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.LayoutOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-layout-options//secondary-align?: arg 1: expected native of type text_1.LayoutOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-layout-options//secondary-align?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.SecondaryAlign)))
			return resObj
		},
	},
	"text-1-measure": {
		Doc:   "text_1.Measure",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-measure: arg 1: expected string")
			}
			var arg1Val text_1.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-measure: arg 2: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-measure: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-measure: arg 2: expected native")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-measure: arg 3: expected decimal")
			}
			res0, res1 := text_1.Measure(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"width":  res0Obj,
				"height": res1Obj,
			})
		},
	},
	"text-1-metadata//family!": {
		Doc:   "Set text_1.Metadata Family value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//family!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//family!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Family = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//family!: arg 2: expected string")
			}
			return arg0
		},
	},
	"text-1-metadata//family?": {
		Doc:   "Get text_1.Metadata Family value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//family?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//family?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Family)
			return resObj
		},
	},
	"text-1-metadata//stretch!": {
		Doc:   "Set text_1.Metadata Stretch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//stretch!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//stretch!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Stretch
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Stretch)
				}
				if natOk && natValOk {
					self.Stretch = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-metadata//stretch!: arg 2: expected decimal")
					}
					self.Stretch = text_1.Stretch(u)
				}
			}
			return arg0
		},
	},
	"text-1-metadata//stretch?": {
		Doc:   "Get text_1.Metadata Stretch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//stretch?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//stretch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Stretch)))
			return resObj
		},
	},
	"text-1-metadata//style!": {
		Doc:   "Set text_1.Metadata Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//style!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//style!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Style
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Style)
				}
				if natOk && natValOk {
					self.Style = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-metadata//style!: arg 2: expected integer")
					}
					self.Style = text_1.Style(u)
				}
			}
			return arg0
		},
	},
	"text-1-metadata//style?": {
		Doc:   "Get text_1.Metadata Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//style?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Style)))
			return resObj
		},
	},
	"text-1-metadata//weight!": {
		Doc:   "Set text_1.Metadata Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//weight!: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//weight!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text_1.Weight
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Weight)
				}
				if natOk && natValOk {
					self.Weight = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-metadata//weight!: arg 2: expected decimal")
					}
					self.Weight = text_1.Weight(u)
				}
			}
			return arg0
		},
	},
	"text-1-metadata//weight?": {
		Doc:   "Get text_1.Metadata Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metadata//weight?: arg 1: expected native of type text_1.Metadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metadata//weight?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Weight)))
			return resObj
		},
	},
	"text-1-metrics//h-ascent!": {
		Doc:   "Set text_1.Metrics HAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//h-ascent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//h-ascent?": {
		Doc:   "Get text_1.Metrics HAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//h-ascent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HAscent))
			return resObj
		},
	},
	"text-1-metrics//h-descent!": {
		Doc:   "Set text_1.Metrics HDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//h-descent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//h-descent?": {
		Doc:   "Get text_1.Metrics HDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//h-descent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HDescent))
			return resObj
		},
	},
	"text-1-metrics//h-line-gap!": {
		Doc:   "Set text_1.Metrics HLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//h-line-gap!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.HLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//h-line-gap?": {
		Doc:   "Get text_1.Metrics HLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//h-line-gap?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//h-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.HLineGap))
			return resObj
		},
	},
	"text-1-metrics//v-ascent!": {
		Doc:   "Set text_1.Metrics VAscent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//v-ascent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-ascent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VAscent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-ascent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//v-ascent?": {
		Doc:   "Get text_1.Metrics VAscent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//v-ascent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VAscent))
			return resObj
		},
	},
	"text-1-metrics//v-descent!": {
		Doc:   "Set text_1.Metrics VDescent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//v-descent!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-descent!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VDescent = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-descent!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//v-descent?": {
		Doc:   "Get text_1.Metrics VDescent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//v-descent?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VDescent))
			return resObj
		},
	},
	"text-1-metrics//v-line-gap!": {
		Doc:   "Set text_1.Metrics VLineGap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//v-line-gap!: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-line-gap!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.VLineGap = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-line-gap!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-1-metrics//v-line-gap?": {
		Doc:   "Get text_1.Metrics VLineGap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text_1.Metrics
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text_1.Metrics)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-metrics//v-line-gap?: arg 1: expected native of type text_1.Metrics")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-metrics//v-line-gap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.VLineGap))
			return resObj
		},
	},
	"text-1-must-parse-tag": {
		Doc:   "text_1.MustParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-must-parse-tag: arg 1: expected string")
			}
			res0 := text_1.MustParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			return res0Obj
		},
	},
	"text-1-limited-face": {
		Doc:   "text_1.NewLimitedFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-limited-face: arg 1: expected native of type text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-limited-face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-limited-face: arg 1: expected native")
			}
			res0 := text_1.NewLimitedFace(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-1-limited-face")
			return res0Obj
		},
	},
	"text-1-multi-face": {
		Doc:   "text_1.NewMultiFace",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []text_1.Face
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text_1.Face, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text_1.Face)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("text-1-multi-face: arg 1: block item: expected native of type text_1.Face")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("text-1-multi-face: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("text-1-multi-face: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text_1.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-1-multi-face: arg 1: expected native of type []text_1.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-1-multi-face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-1-multi-face: arg 1: expected block, native or nil")
			}
			res0, res1 := text_1.NewMultiFace(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-1-multi-face")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"text-1-parse-tag": {
		Doc:   "text_1.ParseTag",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-1-parse-tag: arg 1: expected string")
			}
			res0, res1 := text_1.ParseTag(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint32(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"text-1-stretch-condensed": {
		Doc:   "Get text_1.StretchCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchCondensed)))
			return resObj
		},
	},
	"text-1-stretch-expanded": {
		Doc:   "Get text_1.StretchExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchExpanded)))
			return resObj
		},
	},
	"text-1-stretch-extra-condensed": {
		Doc:   "Get text_1.StretchExtraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchExtraCondensed)))
			return resObj
		},
	},
	"text-1-stretch-extra-expanded": {
		Doc:   "Get text_1.StretchExtraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchExtraExpanded)))
			return resObj
		},
	},
	"text-1-stretch-normal": {
		Doc:   "Get text_1.StretchNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchNormal)))
			return resObj
		},
	},
	"text-1-stretch-semi-condensed": {
		Doc:   "Get text_1.StretchSemiCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchSemiCondensed)))
			return resObj
		},
	},
	"text-1-stretch-semi-expanded": {
		Doc:   "Get text_1.StretchSemiExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchSemiExpanded)))
			return resObj
		},
	},
	"text-1-stretch-ultra-condensed": {
		Doc:   "Get text_1.StretchUltraCondensed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchUltraCondensed)))
			return resObj
		},
	},
	"text-1-stretch-ultra-expanded": {
		Doc:   "Get text_1.StretchUltraExpanded value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.StretchUltraExpanded)))
			return resObj
		},
	},
	"text-1-style-italic": {
		Doc:   "Get text_1.StyleItalic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text_1.StyleItalic)))
			return resObj
		},
	},
	"text-1-style-normal": {
		Doc:   "Get text_1.StyleNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text_1.StyleNormal)))
			return resObj
		},
	},
	"text-1-tag//string": {
		Doc:   "text_1.Tag.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val text_1.Tag
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text_1.Tag
				if natOk {
					natVal, natValOk = nat.Value.(text_1.Tag)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u uint32
					if v, ok := arg0.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("text-1-tag//string: arg 1: expected integer")
					}
					arg0Val = text_1.Tag(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"text-1-weight-black": {
		Doc:   "Get text_1.WeightBlack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightBlack)))
			return resObj
		},
	},
	"text-1-weight-bold": {
		Doc:   "Get text_1.WeightBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightBold)))
			return resObj
		},
	},
	"text-1-weight-extra-bold": {
		Doc:   "Get text_1.WeightExtraBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightExtraBold)))
			return resObj
		},
	},
	"text-1-weight-extra-light": {
		Doc:   "Get text_1.WeightExtraLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightExtraLight)))
			return resObj
		},
	},
	"text-1-weight-light": {
		Doc:   "Get text_1.WeightLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightLight)))
			return resObj
		},
	},
	"text-1-weight-medium": {
		Doc:   "Get text_1.WeightMedium value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightMedium)))
			return resObj
		},
	},
	"text-1-weight-normal": {
		Doc:   "Get text_1.WeightNormal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightNormal)))
			return resObj
		},
	},
	"text-1-weight-semibold": {
		Doc:   "Get text_1.WeightSemibold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightSemibold)))
			return resObj
		},
	},
	"text-1-weight-thin": {
		Doc:   "Get text_1.WeightThin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(text_1.WeightThin)))
			return resObj
		},
	},
	"text-append-glyphs": {
		Doc:   "text.AppendGlyphs",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []text.Glyph
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(text.Glyph)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("text-append-glyphs: arg 1: block item: expected native of type text.Glyph")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("text-append-glyphs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 1: expected native of type []text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 1: expected block, native or nil")
			}
			var arg1Val font.Face
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-append-glyphs: arg 2: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-append-glyphs: arg 3: expected string")
			}
			res0 := text.AppendGlyphs(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "text-glyph")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"text-bound-string": {
		Doc:   "text.BoundString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-bound-string: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-bound-string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-bound-string: arg 2: expected string")
			}
			res0 := text.BoundString(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-rectangle")
			return res0Obj
		},
	},
	"text-cache-glyphs": {
		Doc:   "text.CacheGlyphs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-cache-glyphs: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-cache-glyphs: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-cache-glyphs: arg 2: expected string")
			}
			text.CacheGlyphs(arg0Val, arg1Val)
			return nil
		},
	},
	"text-draw-with-options": {
		Doc:   "text.DrawWithOptions",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *ebiten.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-draw-with-options: arg 1: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw-with-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw-with-options: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-draw-with-options: arg 2: expected string")
			}
			var arg2Val font.Face
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-draw-with-options: arg 3: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw-with-options: arg 3: expected native")
			}
			var arg3Val *ebiten.DrawImageOptions
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*ebiten.DrawImageOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-draw-with-options: arg 4: expected native of type *ebiten.DrawImageOptions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-draw-with-options: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-draw-with-options: arg 4: expected native")
			}
			text.DrawWithOptions(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"text-face-with-line-height": {
		Doc:   "text.FaceWithLineHeight",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-face-with-line-height: arg 1: expected native of type font.Face")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-face-with-line-height: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-face-with-line-height: arg 2: expected decimal")
			}
			res0 := text.FaceWithLineHeight(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "font-face")
			return res0Obj
		},
	},
	"text-glyph//image!": {
		Doc:   "Set text.Glyph Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//image!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*ebiten.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//image!: arg 2: expected native of type *ebiten.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-glyph//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-glyph//image?": {
		Doc:   "Get text.Glyph Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//image?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-ebiten-image")
			return resObj
		},
	},
	"text-glyph//rune!": {
		Doc:   "Set text.Glyph Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//rune!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"text-glyph//rune?": {
		Doc:   "Get text.Glyph Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//rune?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"text-glyph//x!": {
		Doc:   "Set text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//x!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-glyph//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-glyph//x?": {
		Doc:   "Get text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//x?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"text-glyph//y!": {
		Doc:   "Set text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//y!: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-glyph//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"text-glyph//y?": {
		Doc:   "Get text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-glyph//y?: arg 1: expected native of type text.Glyph")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("text-glyph//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"textinput-state//committed!": {
		Doc:   "Set textinput.State Committed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//committed!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//committed!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Committed = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-state//committed!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"textinput-state//committed?": {
		Doc:   "Get textinput.State Committed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//committed?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//committed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Committed))
			return resObj
		},
	},
	"textinput-state//composition-selection-end-in-bytes!": {
		Doc:   "Set textinput.State CompositionSelectionEndInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//composition-selection-end-in-bytes!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//composition-selection-end-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionEndInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-state//composition-selection-end-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"textinput-state//composition-selection-end-in-bytes?": {
		Doc:   "Get textinput.State CompositionSelectionEndInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//composition-selection-end-in-bytes?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//composition-selection-end-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionEndInBytes))
			return resObj
		},
	},
	"textinput-state//composition-selection-start-in-bytes!": {
		Doc:   "Set textinput.State CompositionSelectionStartInBytes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//composition-selection-start-in-bytes!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//composition-selection-start-in-bytes!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CompositionSelectionStartInBytes = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-state//composition-selection-start-in-bytes!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"textinput-state//composition-selection-start-in-bytes?": {
		Doc:   "Get textinput.State CompositionSelectionStartInBytes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//composition-selection-start-in-bytes?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//composition-selection-start-in-bytes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CompositionSelectionStartInBytes))
			return resObj
		},
	},
	"textinput-state//error!": {
		Doc:   "Set textinput.State Error value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//error!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//error!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.String:
				self.Error = errors.New(v.Value)
			case env.Error:
				self.Error = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("textinput-state//error!: arg 2: expected integer to be 0 or nil")
				}
				self.Error = nil
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//error!: arg 2: expected error, string or nil")
			}
			return arg0
		},
	},
	"textinput-state//error?": {
		Doc:   "Get textinput.State Error value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//error?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//error?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewError(self.Error.Error())
			return resObj
		},
	},
	"textinput-state//text!": {
		Doc:   "Set textinput.State Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//text!: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("textinput-state//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"textinput-state//text?": {
		Doc:   "Get textinput.State Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self textinput.State
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(textinput.State)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("textinput-state//text?: arg 1: expected native of type textinput.State")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("textinput-state//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"twenty-48-dir-down": {
		Doc:   "Get twenty48.DirDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirDown)))
			return resObj
		},
	},
	"twenty-48-dir-left": {
		Doc:   "Get twenty48.DirLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirLeft)))
			return resObj
		},
	},
	"twenty-48-dir-right": {
		Doc:   "Get twenty48.DirRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirRight)))
			return resObj
		},
	},
	"twenty-48-dir-up": {
		Doc:   "Get twenty48.DirUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(twenty48.DirUp)))
			return resObj
		},
	},
	"twenty-48-dir//string": {
		Doc:   "twenty48.Dir.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("twenty-48-dir//string: arg 1: expected integer")
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"twenty-48-dir//vector": {
		Doc:   "twenty48.Dir.Vector",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val twenty48.Dir
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal twenty48.Dir
				if natOk {
					natVal, natValOk = nat.Value.(twenty48.Dir)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("twenty-48-dir//vector: arg 1: expected integer")
					}
					arg0Val = twenty48.Dir(u)
				}
			}
			res0, res1 := arg0Val.Vector()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"x": res0Obj,
				"y": res1Obj,
			})
		},
	},
	"twenty-48-game": {
		Doc:   "twenty48.NewGame",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0, res1 := twenty48.NewGame()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-game")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"twenty-48-input": {
		Doc:   "twenty48.NewInput",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := twenty48.NewInput()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-input")
			return res0Obj
		},
	},
	"twenty-48-tile": {
		Doc:   "twenty48.NewTile",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("twenty-48-tile: arg 3: expected integer")
			}
			res0 := twenty48.NewTile(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-twenty-48-tile")
			return res0Obj
		},
	},
	"vector-clockwise": {
		Doc:   "Get vector.Clockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.Clockwise)))
			return resObj
		},
	},
	"vector-counter-clockwise": {
		Doc:   "Get vector.CounterClockwise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.CounterClockwise)))
			return resObj
		},
	},
	"vector-line-cap-butt": {
		Doc:   "Get vector.LineCapButt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapButt)))
			return resObj
		},
	},
	"vector-line-cap-round": {
		Doc:   "Get vector.LineCapRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapRound)))
			return resObj
		},
	},
	"vector-line-cap-square": {
		Doc:   "Get vector.LineCapSquare value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineCapSquare)))
			return resObj
		},
	},
	"vector-line-join-bevel": {
		Doc:   "Get vector.LineJoinBevel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinBevel)))
			return resObj
		},
	},
	"vector-line-join-miter": {
		Doc:   "Get vector.LineJoinMiter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinMiter)))
			return resObj
		},
	},
	"vector-line-join-round": {
		Doc:   "Get vector.LineJoinRound value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(vector.LineJoinRound)))
			return resObj
		},
	},
	"vector-stroke-options//line-cap!": {
		Doc:   "Set vector.StrokeOptions LineCap value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//line-cap!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//line-cap!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineCap
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineCap)
				}
				if natOk && natValOk {
					self.LineCap = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("vector-stroke-options//line-cap!: arg 2: expected integer")
					}
					self.LineCap = vector.LineCap(u)
				}
			}
			return arg0
		},
	},
	"vector-stroke-options//line-cap?": {
		Doc:   "Get vector.StrokeOptions LineCap value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//line-cap?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//line-cap?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineCap)))
			return resObj
		},
	},
	"vector-stroke-options//line-join!": {
		Doc:   "Set vector.StrokeOptions LineJoin value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//line-join!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//line-join!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal vector.LineJoin
				if natOk {
					natVal, natValOk = nat.Value.(vector.LineJoin)
				}
				if natOk && natValOk {
					self.LineJoin = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("vector-stroke-options//line-join!: arg 2: expected integer")
					}
					self.LineJoin = vector.LineJoin(u)
				}
			}
			return arg0
		},
	},
	"vector-stroke-options//line-join?": {
		Doc:   "Get vector.StrokeOptions LineJoin value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//line-join?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//line-join?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.LineJoin)))
			return resObj
		},
	},
	"vector-stroke-options//miter-limit!": {
		Doc:   "Set vector.StrokeOptions MiterLimit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//miter-limit!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//miter-limit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.MiterLimit = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//miter-limit!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"vector-stroke-options//miter-limit?": {
		Doc:   "Get vector.StrokeOptions MiterLimit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//miter-limit?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//miter-limit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.MiterLimit))
			return resObj
		},
	},
	"vector-stroke-options//width!": {
		Doc:   "Set vector.StrokeOptions Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//width!: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"vector-stroke-options//width?": {
		Doc:   "Get vector.StrokeOptions Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self vector.StrokeOptions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(vector.StrokeOptions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vector-stroke-options//width?: arg 1: expected native of type vector.StrokeOptions")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("vector-stroke-options//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"vorbis-decode": {
		Doc:   "vorbis.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode: arg 2: expected native")
			}
			res0, res1 := vorbis.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"vorbis-decode-with-sample-rate": {
		Doc:   "vorbis.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-with-sample-rate: arg 2: expected native")
			}
			res0, res1 := vorbis.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"vorbis-decode-without-resampling": {
		Doc:   "vorbis.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("vorbis-decode-without-resampling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("vorbis-decode-without-resampling: arg 1: expected native")
			}
			res0, res1 := vorbis.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-vorbis-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"wav-decode": {
		Doc:   "wav.Decode",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *audio.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*audio.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 1: expected native of type *audio.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode: arg 1: expected native")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode: arg 2: expected native")
			}
			res0, res1 := wav.Decode(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"wav-decode-with-sample-rate": {
		Doc:   "wav.DecodeWithSampleRate",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("wav-decode-with-sample-rate: arg 1: expected integer")
			}
			var arg1Val io.Reader
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode-with-sample-rate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode-with-sample-rate: arg 2: expected native")
			}
			res0, res1 := wav.DecodeWithSampleRate(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"wav-decode-without-resampling": {
		Doc:   "wav.DecodeWithoutResampling",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: expected native of type io.Reader")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("wav-decode-without-resampling: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("wav-decode-without-resampling: arg 1: expected native")
			}
			res0, res1 := wav.DecodeWithoutResampling(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-wav-stream")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
}
